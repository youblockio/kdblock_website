/*! For license information please see bundle.js.LICENSE.txt */
!(function () {
  var t = {
      158: function (t, e, n) {
        var i, r
        'undefined' != typeof window && window,
          void 0 ===
            (r =
              'function' ==
              typeof (i = function () {
                'use strict'
                function t() {}
                var e = t.prototype
                return (
                  (e.on = function (t, e) {
                    if (t && e) {
                      var n = (this._events = this._events || {}),
                        i = (n[t] = n[t] || [])
                      return -1 == i.indexOf(e) && i.push(e), this
                    }
                  }),
                  (e.once = function (t, e) {
                    if (t && e) {
                      this.on(t, e)
                      var n = (this._onceEvents = this._onceEvents || {})
                      return ((n[t] = n[t] || {})[e] = !0), this
                    }
                  }),
                  (e.off = function (t, e) {
                    var n = this._events && this._events[t]
                    if (n && n.length) {
                      var i = n.indexOf(e)
                      return -1 != i && n.splice(i, 1), this
                    }
                  }),
                  (e.emitEvent = function (t, e) {
                    var n = this._events && this._events[t]
                    if (n && n.length) {
                      ;(n = n.slice(0)), (e = e || [])
                      for (
                        var i = this._onceEvents && this._onceEvents[t], r = 0;
                        r < n.length;
                        r++
                      ) {
                        var s = n[r]
                        i && i[s] && (this.off(t, s), delete i[s]),
                          s.apply(this, e)
                      }
                      return this
                    }
                  }),
                  (e.allOff = function () {
                    delete this._events, delete this._onceEvents
                  }),
                  t
                )
              })
                ? i.call(e, n, e, t)
                : i) || (t.exports = r)
      },
      347: function (t) {
        !(function () {
          function e(t, e) {
            document.addEventListener
              ? t.addEventListener('scroll', e, !1)
              : t.attachEvent('scroll', e)
          }
          function n(t) {
            ;(this.a = document.createElement('div')),
              this.a.setAttribute('aria-hidden', 'true'),
              this.a.appendChild(document.createTextNode(t)),
              (this.b = document.createElement('span')),
              (this.c = document.createElement('span')),
              (this.h = document.createElement('span')),
              (this.f = document.createElement('span')),
              (this.g = -1),
              (this.b.style.cssText =
                'max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;'),
              (this.c.style.cssText =
                'max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;'),
              (this.f.style.cssText =
                'max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;'),
              (this.h.style.cssText =
                'display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;'),
              this.b.appendChild(this.h),
              this.c.appendChild(this.f),
              this.a.appendChild(this.b),
              this.a.appendChild(this.c)
          }
          function i(t, e) {
            t.a.style.cssText =
              'max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:' +
              e +
              ';'
          }
          function r(t) {
            var e = t.a.offsetWidth,
              n = e + 100
            return (
              (t.f.style.width = n + 'px'),
              (t.c.scrollLeft = n),
              (t.b.scrollLeft = t.b.scrollWidth + 100),
              t.g !== e && ((t.g = e), !0)
            )
          }
          function s(t, n) {
            function i() {
              var t = s
              r(t) && t.a.parentNode && n(t.g)
            }
            var s = t
            e(t.b, i), e(t.c, i), r(t)
          }
          function o(t, e) {
            var n = e || {}
            ;(this.family = t),
              (this.style = n.style || 'normal'),
              (this.weight = n.weight || 'normal'),
              (this.stretch = n.stretch || 'normal')
          }
          var a = null,
            l = null,
            c = null,
            u = null
          function h() {
            return null === u && (u = !!document.fonts), u
          }
          function d() {
            if (null === c) {
              var t = document.createElement('div')
              try {
                t.style.font = 'condensed 100px sans-serif'
              } catch (t) {}
              c = '' !== t.style.font
            }
            return c
          }
          function p(t, e) {
            return [t.style, t.weight, d() ? t.stretch : '', '100px', e].join(
              ' ',
            )
          }
          ;(o.prototype.load = function (t, e) {
            var r = this,
              o = t || 'BESbswy',
              c = 0,
              u = e || 3e3,
              d = new Date().getTime()
            return new Promise(function (t, e) {
              if (
                h() &&
                !(function () {
                  if (null === l)
                    if (h() && /Apple/.test(window.navigator.vendor)) {
                      var t = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(
                        window.navigator.userAgent,
                      )
                      l = !!t && 603 > parseInt(t[1], 10)
                    } else l = !1
                  return l
                })()
              ) {
                var f = new Promise(function (t, e) {
                    !(function n() {
                      new Date().getTime() - d >= u
                        ? e(Error(u + 'ms timeout exceeded'))
                        : document.fonts
                            .load(p(r, '"' + r.family + '"'), o)
                            .then(function (e) {
                              1 <= e.length ? t() : setTimeout(n, 25)
                            }, e)
                    })()
                  }),
                  m = new Promise(function (t, e) {
                    c = setTimeout(function () {
                      e(Error(u + 'ms timeout exceeded'))
                    }, u)
                  })
                Promise.race([m, f]).then(function () {
                  clearTimeout(c), t(r)
                }, e)
              } else
                !(function (t) {
                  document.body
                    ? t()
                    : document.addEventListener
                    ? document.addEventListener(
                        'DOMContentLoaded',
                        function e() {
                          document.removeEventListener('DOMContentLoaded', e),
                            t()
                        },
                      )
                    : document.attachEvent('onreadystatechange', function e() {
                        ;('interactive' != document.readyState &&
                          'complete' != document.readyState) ||
                          (document.detachEvent('onreadystatechange', e), t())
                      })
                })(function () {
                  function l() {
                    var e
                    ;(e =
                      (-1 != g && -1 != v) ||
                      (-1 != g && -1 != _) ||
                      (-1 != v && -1 != _)) &&
                      ((e = g != v && g != _ && v != _) ||
                        (null === a &&
                          ((e = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(
                            window.navigator.userAgent,
                          )),
                          (a =
                            !!e &&
                            (536 > parseInt(e[1], 10) ||
                              (536 === parseInt(e[1], 10) &&
                                11 >= parseInt(e[2], 10))))),
                        (e =
                          a &&
                          ((g == y && v == y && _ == y) ||
                            (g == x && v == x && _ == x) ||
                            (g == b && v == b && _ == b)))),
                      (e = !e)),
                      e &&
                        (w.parentNode && w.parentNode.removeChild(w),
                        clearTimeout(c),
                        t(r))
                  }
                  var h = new n(o),
                    f = new n(o),
                    m = new n(o),
                    g = -1,
                    v = -1,
                    _ = -1,
                    y = -1,
                    x = -1,
                    b = -1,
                    w = document.createElement('div')
                  ;(w.dir = 'ltr'),
                    i(h, p(r, 'sans-serif')),
                    i(f, p(r, 'serif')),
                    i(m, p(r, 'monospace')),
                    w.appendChild(h.a),
                    w.appendChild(f.a),
                    w.appendChild(m.a),
                    document.body.appendChild(w),
                    (y = h.a.offsetWidth),
                    (x = f.a.offsetWidth),
                    (b = m.a.offsetWidth),
                    (function t() {
                      if (new Date().getTime() - d >= u)
                        w.parentNode && w.parentNode.removeChild(w),
                          e(Error(u + 'ms timeout exceeded'))
                      else {
                        var n = document.hidden
                        ;(!0 !== n && void 0 !== n) ||
                          ((g = h.a.offsetWidth),
                          (v = f.a.offsetWidth),
                          (_ = m.a.offsetWidth),
                          l()),
                          (c = setTimeout(t, 50))
                      }
                    })(),
                    s(h, function (t) {
                      ;(g = t), l()
                    }),
                    i(h, p(r, '"' + r.family + '",sans-serif')),
                    s(f, function (t) {
                      ;(v = t), l()
                    }),
                    i(f, p(r, '"' + r.family + '",serif')),
                    s(m, function (t) {
                      ;(_ = t), l()
                    }),
                    i(m, p(r, '"' + r.family + '",monospace'))
                })
            })
          }),
            (t.exports = o)
        })()
      },
      564: function (t, e, n) {
        var i, r
        !(function (s, o) {
          'use strict'
          ;(i = [n(158)]),
            (r = function (t) {
              return (function (t, e) {
                var n = t.jQuery,
                  i = t.console
                function r(t, e) {
                  for (var n in e) t[n] = e[n]
                  return t
                }
                var s = Array.prototype.slice
                function o(t, e, a) {
                  if (!(this instanceof o)) return new o(t, e, a)
                  var l,
                    c = t
                  'string' == typeof t && (c = document.querySelectorAll(t)),
                    c
                      ? ((this.elements =
                          ((l = c),
                          Array.isArray(l)
                            ? l
                            : 'object' == typeof l &&
                              'number' == typeof l.length
                            ? s.call(l)
                            : [l])),
                        (this.options = r({}, this.options)),
                        'function' == typeof e ? (a = e) : r(this.options, e),
                        a && this.on('always', a),
                        this.getImages(),
                        n && (this.jqDeferred = new n.Deferred()),
                        setTimeout(this.check.bind(this)))
                      : i.error('Bad element for imagesLoaded ' + (c || t))
                }
                ;(o.prototype = Object.create(e.prototype)),
                  (o.prototype.options = {}),
                  (o.prototype.getImages = function () {
                    ;(this.images = []),
                      this.elements.forEach(this.addElementImages, this)
                  }),
                  (o.prototype.addElementImages = function (t) {
                    'IMG' == t.nodeName && this.addImage(t),
                      !0 === this.options.background &&
                        this.addElementBackgroundImages(t)
                    var e = t.nodeType
                    if (e && a[e]) {
                      for (
                        var n = t.querySelectorAll('img'), i = 0;
                        i < n.length;
                        i++
                      ) {
                        var r = n[i]
                        this.addImage(r)
                      }
                      if ('string' == typeof this.options.background) {
                        var s = t.querySelectorAll(this.options.background)
                        for (i = 0; i < s.length; i++) {
                          var o = s[i]
                          this.addElementBackgroundImages(o)
                        }
                      }
                    }
                  })
                var a = { 1: !0, 9: !0, 11: !0 }
                function l(t) {
                  this.img = t
                }
                function c(t, e) {
                  ;(this.url = t), (this.element = e), (this.img = new Image())
                }
                return (
                  (o.prototype.addElementBackgroundImages = function (t) {
                    var e = getComputedStyle(t)
                    if (e)
                      for (
                        var n = /url\((['"])?(.*?)\1\)/gi,
                          i = n.exec(e.backgroundImage);
                        null !== i;

                      ) {
                        var r = i && i[2]
                        r && this.addBackground(r, t),
                          (i = n.exec(e.backgroundImage))
                      }
                  }),
                  (o.prototype.addImage = function (t) {
                    var e = new l(t)
                    this.images.push(e)
                  }),
                  (o.prototype.addBackground = function (t, e) {
                    var n = new c(t, e)
                    this.images.push(n)
                  }),
                  (o.prototype.check = function () {
                    var t = this
                    function e(e, n, i) {
                      setTimeout(function () {
                        t.progress(e, n, i)
                      })
                    }
                    ;(this.progressedCount = 0),
                      (this.hasAnyBroken = !1),
                      this.images.length
                        ? this.images.forEach(function (t) {
                            t.once('progress', e), t.check()
                          })
                        : this.complete()
                  }),
                  (o.prototype.progress = function (t, e, n) {
                    this.progressedCount++,
                      (this.hasAnyBroken = this.hasAnyBroken || !t.isLoaded),
                      this.emitEvent('progress', [this, t, e]),
                      this.jqDeferred &&
                        this.jqDeferred.notify &&
                        this.jqDeferred.notify(this, t),
                      this.progressedCount == this.images.length &&
                        this.complete(),
                      this.options.debug && i && i.log('progress: ' + n, t, e)
                  }),
                  (o.prototype.complete = function () {
                    var t = this.hasAnyBroken ? 'fail' : 'done'
                    if (
                      ((this.isComplete = !0),
                      this.emitEvent(t, [this]),
                      this.emitEvent('always', [this]),
                      this.jqDeferred)
                    ) {
                      var e = this.hasAnyBroken ? 'reject' : 'resolve'
                      this.jqDeferred[e](this)
                    }
                  }),
                  (l.prototype = Object.create(e.prototype)),
                  (l.prototype.check = function () {
                    this.getIsImageComplete()
                      ? this.confirm(
                          0 !== this.img.naturalWidth,
                          'naturalWidth',
                        )
                      : ((this.proxyImage = new Image()),
                        this.proxyImage.addEventListener('load', this),
                        this.proxyImage.addEventListener('error', this),
                        this.img.addEventListener('load', this),
                        this.img.addEventListener('error', this),
                        (this.proxyImage.src = this.img.src))
                  }),
                  (l.prototype.getIsImageComplete = function () {
                    return this.img.complete && this.img.naturalWidth
                  }),
                  (l.prototype.confirm = function (t, e) {
                    ;(this.isLoaded = t),
                      this.emitEvent('progress', [this, this.img, e])
                  }),
                  (l.prototype.handleEvent = function (t) {
                    var e = 'on' + t.type
                    this[e] && this[e](t)
                  }),
                  (l.prototype.onload = function () {
                    this.confirm(!0, 'onload'), this.unbindEvents()
                  }),
                  (l.prototype.onerror = function () {
                    this.confirm(!1, 'onerror'), this.unbindEvents()
                  }),
                  (l.prototype.unbindEvents = function () {
                    this.proxyImage.removeEventListener('load', this),
                      this.proxyImage.removeEventListener('error', this),
                      this.img.removeEventListener('load', this),
                      this.img.removeEventListener('error', this)
                  }),
                  (c.prototype = Object.create(l.prototype)),
                  (c.prototype.check = function () {
                    this.img.addEventListener('load', this),
                      this.img.addEventListener('error', this),
                      (this.img.src = this.url),
                      this.getIsImageComplete() &&
                        (this.confirm(
                          0 !== this.img.naturalWidth,
                          'naturalWidth',
                        ),
                        this.unbindEvents())
                  }),
                  (c.prototype.unbindEvents = function () {
                    this.img.removeEventListener('load', this),
                      this.img.removeEventListener('error', this)
                  }),
                  (c.prototype.confirm = function (t, e) {
                    ;(this.isLoaded = t),
                      this.emitEvent('progress', [this, this.element, e])
                  }),
                  (o.makeJQueryPlugin = function (e) {
                    ;(e = e || t.jQuery) &&
                      ((n = e).fn.imagesLoaded = function (t, e) {
                        return new o(this, t, e).jqDeferred.promise(n(this))
                      })
                  }),
                  o.makeJQueryPlugin(),
                  o
                )
              })(s, t)
            }.apply(e, i)),
            void 0 === r || (t.exports = r)
        })('undefined' != typeof window ? window : this)
      },
      796: function (t, e, n) {
        t.exports = n(643)
      },
      264: function (t) {
        'use strict'
        var e = !(
            'undefined' == typeof window ||
            !window.document ||
            !window.document.createElement
          ),
          n = {
            canUseDOM: e,
            canUseWorkers: 'undefined' != typeof Worker,
            canUseEventListeners:
              e && !(!window.addEventListener && !window.attachEvent),
            canUseViewport: e && !!window.screen,
            isInWorker: !e,
          }
        t.exports = n
      },
      518: function (t) {
        var e,
          n,
          i,
          r,
          s,
          o,
          a,
          l,
          c,
          u,
          h,
          d,
          p,
          f,
          m,
          g = !1
        function v() {
          if (!g) {
            g = !0
            var t = navigator.userAgent,
              v = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(
                t,
              ),
              _ = /(Mac OS X)|(Windows)|(Linux)/.exec(t)
            if (
              ((d = /\b(iPhone|iP[ao]d)/.exec(t)),
              (p = /\b(iP[ao]d)/.exec(t)),
              (u = /Android/i.exec(t)),
              (f = /FBAN\/\w+;/i.exec(t)),
              (m = /Mobile/i.exec(t)),
              (h = !!/Win64/.exec(t)),
              v)
            ) {
              ;(e = v[1] ? parseFloat(v[1]) : v[5] ? parseFloat(v[5]) : NaN) &&
                document &&
                document.documentMode &&
                (e = document.documentMode)
              var y = /(?:Trident\/(\d+.\d+))/.exec(t)
              ;(o = y ? parseFloat(y[1]) + 4 : e),
                (n = v[2] ? parseFloat(v[2]) : NaN),
                (i = v[3] ? parseFloat(v[3]) : NaN),
                (r = v[4] ? parseFloat(v[4]) : NaN)
                  ? ((v = /(?:Chrome\/(\d+\.\d+))/.exec(t)),
                    (s = v && v[1] ? parseFloat(v[1]) : NaN))
                  : (s = NaN)
            } else e = n = i = s = r = NaN
            if (_) {
              if (_[1]) {
                var x = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(t)
                a = !x || parseFloat(x[1].replace('_', '.'))
              } else a = !1
              ;(l = !!_[2]), (c = !!_[3])
            } else a = l = c = !1
          }
        }
        var _ = {
          ie: function () {
            return v() || e
          },
          ieCompatibilityMode: function () {
            return v() || o > e
          },
          ie64: function () {
            return _.ie() && h
          },
          firefox: function () {
            return v() || n
          },
          opera: function () {
            return v() || i
          },
          webkit: function () {
            return v() || r
          },
          safari: function () {
            return _.webkit()
          },
          chrome: function () {
            return v() || s
          },
          windows: function () {
            return v() || l
          },
          osx: function () {
            return v() || a
          },
          linux: function () {
            return v() || c
          },
          iphone: function () {
            return v() || d
          },
          mobile: function () {
            return v() || d || p || u || m
          },
          nativeApp: function () {
            return v() || f
          },
          android: function () {
            return v() || u
          },
          ipad: function () {
            return v() || p
          },
        }
        t.exports = _
      },
      534: function (t, e, n) {
        'use strict'
        var i,
          r = n(264)
        r.canUseDOM &&
          (i =
            document.implementation &&
            document.implementation.hasFeature &&
            !0 !== document.implementation.hasFeature('', '')),
          (t.exports = function (t, e) {
            if (!r.canUseDOM || (e && !('addEventListener' in document)))
              return !1
            var n = 'on' + t,
              s = n in document
            if (!s) {
              var o = document.createElement('div')
              o.setAttribute(n, 'return;'), (s = 'function' == typeof o[n])
            }
            return (
              !s &&
                i &&
                'wheel' === t &&
                (s = document.implementation.hasFeature('Events.wheel', '3.0')),
              s
            )
          })
      },
      643: function (t, e, n) {
        'use strict'
        var i = n(518),
          r = n(534)
        function s(t) {
          var e = 0,
            n = 0,
            i = 0,
            r = 0
          return (
            'detail' in t && (n = t.detail),
            'wheelDelta' in t && (n = -t.wheelDelta / 120),
            'wheelDeltaY' in t && (n = -t.wheelDeltaY / 120),
            'wheelDeltaX' in t && (e = -t.wheelDeltaX / 120),
            'axis' in t && t.axis === t.HORIZONTAL_AXIS && ((e = n), (n = 0)),
            (i = 10 * e),
            (r = 10 * n),
            'deltaY' in t && (r = t.deltaY),
            'deltaX' in t && (i = t.deltaX),
            (i || r) &&
              t.deltaMode &&
              (1 == t.deltaMode
                ? ((i *= 40), (r *= 40))
                : ((i *= 800), (r *= 800))),
            i && !e && (e = i < 1 ? -1 : 1),
            r && !n && (n = r < 1 ? -1 : 1),
            { spinX: e, spinY: n, pixelX: i, pixelY: r }
          )
        }
        ;(s.getEventType = function () {
          return i.firefox()
            ? 'DOMMouseScroll'
            : r('wheel')
            ? 'wheel'
            : 'mousewheel'
        }),
          (t.exports = s)
      },
      856: function (t, e, n) {
        var i, r
        void 0 ===
          (r =
            'function' ==
            typeof (i = function (t) {
              'use strict'
              var e = 0
              ;(window.requestAnimationFrame =
                window.requestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.msRequestAnimationFrame),
                (window.cancelAnimationFrame =
                  window.cancelAnimationFrame ||
                  window.mozCancelAnimationFrame),
                window.requestAnimationFrame ||
                  (window.requestAnimationFrame = function (t, n) {
                    var i = new Date().getTime(),
                      r = Math.max(0, 16 - (i - e)),
                      s = window.setTimeout(function () {
                        t(i + r)
                      }, r)
                    return (e = i + r), s
                  }),
                window.cancelAnimationFrame ||
                  (window.cancelAnimationFrame = function (t) {
                    clearTimeout(t)
                  })
              var n = {
                linear: function (t) {
                  return t
                },
                easeInQuad: function (t) {
                  return t * t
                },
                easeOutQuad: function (t) {
                  return t * (2 - t)
                },
                easeInOutQuad: function (t) {
                  return t < 0.5 ? 2 * t * t : (4 - 2 * t) * t - 1
                },
                easeInCubic: function (t) {
                  return t * t * t
                },
                easeOutCubic: function (t) {
                  return --t * t * t + 1
                },
                easeInOutCubic: function (t) {
                  return t < 0.5
                    ? 4 * t * t * t
                    : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1
                },
                easeInQuart: function (t) {
                  return t * t * t * t
                },
                easeOutQuart: function (t) {
                  return 1 - --t * t * t * t
                },
                easeInOutQuart: function (t) {
                  return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t
                },
                easeInQuint: function (t) {
                  return t * t * t * t * t
                },
                easeOutQuint: function (t) {
                  return 1 + --t * t * t * t * t
                },
                easeInOutQuint: function (t) {
                  return t < 0.5
                    ? 16 * t * t * t * t * t
                    : 1 + 16 * --t * t * t * t * t
                },
              }
              var i = [],
                r = []
              function s(t) {
                return this instanceof s
                  ? ('string' == typeof t && (t = { selector: t }),
                    t.selector
                      ? ((this.opts = t),
                        (this.selector = t.selector),
                        (this.duration = t.duration || 500),
                        (this.easing =
                          'function' == typeof t.easing
                            ? t.easing
                            : n[t.easing] || n.easeInOutCubic),
                        (this.id = !1),
                        (this.elements = this.getElements()),
                        (this.callback = t.callback),
                        this.setInitialStyles(),
                        (i = i.concat(this.elements)),
                        void r.push(this))
                      : this.error('A selector needs to be specified'))
                  : new s(t)
              }
              function o(t, e, n) {
                ;(this.el = t),
                  (this.duration = e),
                  (this.easing = n),
                  (this.animationStart = null),
                  (this.animationStarted = !1)
              }
              function a(t, e, n) {
                o.call(this, t, e, n), (this.length = t.getTotalLength())
              }
              function l(t, e, n) {
                o.call(this, t, e, n),
                  (this.length = (function (t) {
                    var e = t.getAttribute('x1'),
                      n = t.getAttribute('x2'),
                      i = t.getAttribute('y1'),
                      r = t.getAttribute('y2')
                    return Math.sqrt(Math.pow(e - n, 2) + Math.pow(i - r, 2))
                  })(t))
              }
              function c(t, e, n) {
                o.call(this, t, e, n),
                  (this.length = (function (t) {
                    var e,
                      n,
                      i,
                      r,
                      s,
                      o = 0,
                      a = t.points.numberOfItems
                    for (s = 1; s < a; s++)
                      (e = t.points.getItem(s - 1).x),
                        (n = t.points.getItem(s).x),
                        (i = t.points.getItem(s - 1).y),
                        (r = t.points.getItem(s).y),
                        (o += Math.sqrt(
                          Math.pow(e - n, 2) + Math.pow(i - r, 2),
                        ))
                    return o
                  })(t))
              }
              return (
                document.addEventListener(
                  'visibilitychange',
                  function () {
                    if (document.hidden) {
                      for (var t = 0, e = r.length; t < e; t++) r[t].cancel()
                      for (var n = 0, s = i.length; n < s; n++) i[n].complete()
                    }
                  },
                  !1,
                ),
                (s.prototype = {
                  constructor: s,
                  error: function (t) {
                    console.error('Walkway error: ' + t)
                  },
                  getElements: function () {
                    var t = this,
                      e = (function (t) {
                        return ['path', 'line', 'polyline']
                          .reduce(function (e, n) {
                            return e + t + ' ' + n + ', '
                          }, '')
                          .slice(0, -2)
                      })(this.selector),
                      n = document.querySelectorAll(e)
                    return (n = Array.prototype.slice.call(n)).map(function (
                      e,
                    ) {
                      return 'path' === e.tagName
                        ? new a(e, t.duration, t.easing)
                        : 'line' === e.tagName
                        ? new l(e, t.duration, t.easing)
                        : 'polyline' === e.tagName
                        ? new c(e, t.duration, t.easing)
                        : void 0
                    })
                  },
                  setInitialStyles: function () {
                    this.elements.forEach(function (t) {
                      ;(t.el.style.strokeDasharray = t.length + ' ' + t.length),
                        (t.el.style.strokeDashoffset = t.length)
                    })
                  },
                  draw: function (t) {
                    var e = this.elements.length,
                      n =
                        this.elements.filter(function (t) {
                          return t.done
                        }).length === e,
                      i = null
                    if (((this.callback = t || this.callback), n))
                      return (
                        this.callback &&
                          'function' == typeof this.callback &&
                          this.callback(),
                        void this.cancel()
                      )
                    for (; e--; )
                      (i = this.elements[e]).update() && (i.done = !0)
                    this.id = window.requestAnimationFrame(
                      this.draw.bind(this, t),
                    )
                  },
                  cancel: function () {
                    window.cancelAnimationFrame(this.id)
                  },
                  redraw: function () {
                    this.cancel(),
                      this.elements.forEach(function (t) {
                        t.reset()
                      }),
                      this.draw()
                  },
                }),
                (o.prototype = {
                  constructor: o,
                  update: function () {
                    this.animationStarted ||
                      ((this.animationStart = Date.now()),
                      (this.animationStarted = !0))
                    var t = this.easing(
                      (Date.now() - this.animationStart) / this.duration,
                    )
                    return this.fill(t), t >= 1
                  },
                  fill: function (t) {
                    var e = Math.ceil(this.length * (1 - t))
                    this.el.style.strokeDashoffset = e < 0 ? 0 : Math.abs(e)
                  },
                  complete: function () {
                    this.fill(1)
                  },
                  reset: function () {
                    ;(this.done = !1),
                      (this.animationStart = 0),
                      (this.animationStarted = !1),
                      this.fill(0)
                  },
                }),
                (a.prototype = l.prototype = c.prototype = Object.create(
                  o.prototype,
                )),
                s
              )
            })
              ? i.call(e, n, e, t)
              : i) || (t.exports = r)
      },
      411: function (t) {
        t.exports =
          'varying vec2 vUv;\nvarying vec3 vPosition;\nuniform float time;\nuniform vec3 baseFirstP;\nuniform vec3 baseSecondP;\nuniform vec3 baseAccent;\nuniform float divider;\nuniform float speed;\nuniform float basePatterOffset;\nuniform float secondPatternOffset;\nuniform float xMult;\nuniform float rotation;\nuniform float noiseScale;\nuniform float noiseDistA;\nuniform float noiseDistB;\nuniform float opacity;\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat lines(vec2 uv, float offset) {\n\n    return smoothstep(\n        0.,0.5 + offset * 0.5,\n        //0.5,1.0 + offset * 0.5,\n        //abs(0.5*(sin(uv.x*xMult)+offset*2.))\n        abs(0.35*(sin(uv.x*xMult)+offset*2.))\n    );\n}\n\nmat2 rotate2D(float angle) {\n    return mat2(\n        cos(angle),-sin(angle),\n        sin(angle),cos(angle)\n    );\n}\n\nvoid main() {\n\n    vec3 newPos = vPosition/divider;\n\n\n\n    float n = noise(newPos + time*speed);\n\n    vec3 baseFirst = vec3(baseFirstP.x/255.,baseFirstP.y/255.,baseFirstP.z/255.);\n    vec3 accent = vec3(baseAccent.x/255.,baseAccent.y/255.,baseAccent.z/255.);\n    vec3 baseSecond = vec3(baseSecondP.x/255.,baseSecondP.y/255.,baseSecondP.z/255.);\n    vec3 baseThird = vec3(232./255.,201./255.,73./255.);\n\n    vec2 ppp = newPos.xy;\n\n    float scale = noiseScale;\n    float distA = noiseDistA;\n    float distB = noiseDistB;\n\n    ppp += 0.1 * cos( ( 1.5 * scale ) * ppp.yx + 1.1 * time*speed + vec2(0.1,1.1) );\n    ppp += 0.1 * cos( ( 2.3 * scale ) * ppp.xy + 1.3 * time*speed + vec2(3.2,3.4) );\n    ppp += 0.1 * cos( ( 2.2 * scale ) * ppp.yx + 1.7 * time*speed + vec2(1.8,5.2) );\n    ppp += distA * cos( ( distB * scale ) * ppp.yx + 1.4 * time*speed + vec2(6.3,3.9) );\n\n\n    vec2 baseUV = rotate2D(rotation+ppp.x) * vec2(newPos.x,newPos.y);\n\n    float basePattern = lines(baseUV*0.3,basePatterOffset);\n    float secondPattern = lines(baseUV*0.3,secondPatternOffset);\n\n    vec3 baseColor = mix(baseSecond,baseFirst,basePattern);\n    vec3 secondBaseColor = mix(baseColor,accent,secondPattern);\n\n\n    vec4 res = vec4(vec3(secondBaseColor),1.) * opacity;\n\n\n    gl_FragColor = res;\n\n\n}'
      },
      73: function (t) {
        t.exports =
          'varying vec2 vUv;\nvarying vec3 vPosition;\n\n\nvoid main() {\n    vUv = uv;\n    vPosition = position;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n}'
      },
      144: function (t) {
        t.exports =
          'varying vec2 vUv;\nuniform sampler2D uImage;\nuniform vec2 uImageSizes;\nuniform vec2 uPlaneSizes;\nuniform vec2 uViewportSizes;\nuniform float uStrength;\nuniform float time;\nuniform float hoverState;\n\nvec3 rgbShift(sampler2D textureImage, vec2 uv, vec2 offset) {\n    float r = texture2D(textureImage,uv + offset * 0.6).r;\n    float g = texture2D(textureImage,uv + offset * 0.9).g;\n    float b = texture2D(textureImage,uv + offset * 0.1).b;\n\n\n    return vec3(r,g,b);\n}\n\n\nvoid main() {\n\n    vec2 ratio = vec2(\n    min((uPlaneSizes.x / uPlaneSizes.y) / (uImageSizes.x / uImageSizes.y), 1.0),\n    min((uPlaneSizes.y / uPlaneSizes.x) / (uImageSizes.y / uImageSizes.x), 1.0)\n    );\n\n    vec2 uv = vec2(\n    vUv.x * ratio.x + (1.0 - ratio.x) * 0.5,\n    vUv.y * ratio.y + (1.0 - ratio.y) * 0.5\n    );\n\n\n    vec3 color = rgbShift(uImage,uv-vec2(0.05*hoverState,0.05*hoverState),vec2(0.05*hoverState,0.05*hoverState));\n    float a = texture2D(uImage,uv).a;\n\n    vec4 t1 = vec4(color,a);\n\n    gl_FragColor = texture2D(uImage,uv) * hoverState;\n\n    /*\n\n    gl_FragColor.rgb = texture2D(uImage, uv).rgb;\n    gl_FragColor.a = 1.0;\n    */\n\n\n\n}'
      },
      965: function (t) {
        t.exports =
          'varying vec2 vUv;\nuniform vec2 uViewportSizes;\nuniform float uStrength;\n#define PI 3.1415926535897932384626433832795\n\nvoid main() {\n\n    vec4 newPosition = modelViewMatrix * vec4(position, 1.0);\n\n    newPosition.z += sin(newPosition.y / uViewportSizes.y * PI + PI / 2.0) * - uStrength;\n\n    vUv = uv;\n\n    gl_Position = projectionMatrix * newPosition;\n\n\n}'
      },
    },
    e = {}
  function n(i) {
    var r = e[i]
    if (void 0 !== r) return r.exports
    var s = (e[i] = { exports: {} })
    return t[i].call(s.exports, s, s.exports, n), s.exports
  }
  ;(n.n = function (t) {
    var e =
      t && t.__esModule
        ? function () {
            return t.default
          }
        : function () {
            return t
          }
    return n.d(e, { a: e }), e
  }),
    (n.d = function (t, e) {
      for (var i in e)
        n.o(e, i) &&
          !n.o(t, i) &&
          Object.defineProperty(t, i, { enumerable: !0, get: e[i] })
    }),
    (n.o = function (t, e) {
      return Object.prototype.hasOwnProperty.call(t, e)
    }),
    (function () {
      'use strict'
      function t(t) {
        if (void 0 === t)
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called",
          )
        return t
      }
      function e(t, e) {
        ;(t.prototype = Object.create(e.prototype)),
          (t.prototype.constructor = t),
          (t.__proto__ = e)
      }
      var i,
        r,
        s,
        o,
        a,
        l,
        c,
        u,
        h,
        d = {
          autoSleep: 120,
          force3D: 'auto',
          nullTargetWarn: 1,
          units: { lineHeight: '' },
        },
        p = { duration: 0.5, overwrite: !1, delay: 0 },
        f = 1e8,
        m = 1e-8,
        g = 2 * Math.PI,
        v = g / 4,
        _ = 0,
        y = Math.sqrt,
        x = Math.cos,
        b = Math.sin,
        w = function (t) {
          return 'string' == typeof t
        },
        M = function (t) {
          return 'function' == typeof t
        },
        S = function (t) {
          return 'number' == typeof t
        },
        T = function (t) {
          return void 0 === t
        },
        E = function (t) {
          return 'object' == typeof t
        },
        D = function (t) {
          return !1 !== t
        },
        A = function () {
          return 'undefined' != typeof window
        },
        C = function (t) {
          return M(t) || w(t)
        },
        L =
          ('function' == typeof ArrayBuffer && ArrayBuffer.isView) ||
          function () {},
        R = Array.isArray,
        P = /(?:-?\.?\d|\.)+/gi,
        F = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
        I = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
        O = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
        N = /[+-]=-?[.\d]+/,
        k = /[^,'"\[\]\s]+/gi,
        B = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
        z = {},
        U = {},
        H = function (t) {
          return (U = pt(t, z)) && nn
        },
        G = function (t, e) {
          return console.warn(
            'Invalid property',
            t,
            'set to',
            e,
            'Missing plugin? gsap.registerPlugin()',
          )
        },
        V = function (t, e) {
          return !e && console.warn(t)
        },
        W = function (t, e) {
          return (t && (z[t] = e) && U && (U[t] = e)) || z
        },
        j = function () {
          return 0
        },
        q = {},
        X = [],
        Y = {},
        J = {},
        Z = {},
        K = 30,
        Q = [],
        $ = '',
        tt = function (t) {
          var e,
            n,
            i = t[0]
          if ((E(i) || M(i) || (t = [t]), !(e = (i._gsap || {}).harness))) {
            for (n = Q.length; n-- && !Q[n].targetTest(i); );
            e = Q[n]
          }
          for (n = t.length; n--; )
            (t[n] && (t[n]._gsap || (t[n]._gsap = new Te(t[n], e)))) ||
              t.splice(n, 1)
          return t
        },
        et = function (t) {
          return t._gsap || tt(Wt(t))[0]._gsap
        },
        nt = function (t, e, n) {
          return (n = t[e]) && M(n)
            ? t[e]()
            : (T(n) && t.getAttribute && t.getAttribute(e)) || n
        },
        it = function (t, e) {
          return (t = t.split(',')).forEach(e) || t
        },
        rt = function (t) {
          return Math.round(1e5 * t) / 1e5 || 0
        },
        st = function (t) {
          return Math.round(1e7 * t) / 1e7 || 0
        },
        ot = function (t, e) {
          var n = e.charAt(0),
            i = parseFloat(e.substr(2))
          return (
            (t = parseFloat(t)),
            '+' === n ? t + i : '-' === n ? t - i : '*' === n ? t * i : t / i
          )
        },
        at = function (t, e) {
          for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n; );
          return i < n
        },
        lt = function () {
          var t,
            e,
            n = X.length,
            i = X.slice(0)
          for (Y = {}, X.length = 0, t = 0; t < n; t++)
            (e = i[t]) &&
              e._lazy &&
              (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0)
        },
        ct = function (t, e, n, i) {
          X.length && lt(), t.render(e, n, i), X.length && lt()
        },
        ut = function (t) {
          var e = parseFloat(t)
          return (e || 0 === e) && (t + '').match(k).length < 2
            ? e
            : w(t)
            ? t.trim()
            : t
        },
        ht = function (t) {
          return t
        },
        dt = function (t, e) {
          for (var n in e) n in t || (t[n] = e[n])
          return t
        },
        pt = function (t, e) {
          for (var n in e) t[n] = e[n]
          return t
        },
        ft = function t(e, n) {
          for (var i in n)
            '__proto__' !== i &&
              'constructor' !== i &&
              'prototype' !== i &&
              (e[i] = E(n[i]) ? t(e[i] || (e[i] = {}), n[i]) : n[i])
          return e
        },
        mt = function (t, e) {
          var n,
            i = {}
          for (n in t) n in e || (i[n] = t[n])
          return i
        },
        gt = function (t) {
          var e,
            n = t.parent || r,
            i = t.keyframes
              ? ((e = R(t.keyframes)),
                function (t, n) {
                  for (var i in n)
                    i in t ||
                      ('duration' === i && e) ||
                      'ease' === i ||
                      (t[i] = n[i])
                })
              : dt
          if (D(t.inherit))
            for (; n; ) i(t, n.vars.defaults), (n = n.parent || n._dp)
          return t
        },
        vt = function (t, e, n, i, r) {
          void 0 === n && (n = '_first'), void 0 === i && (i = '_last')
          var s,
            o = t[i]
          if (r) for (s = e[r]; o && o[r] > s; ) o = o._prev
          return (
            o
              ? ((e._next = o._next), (o._next = e))
              : ((e._next = t[n]), (t[n] = e)),
            e._next ? (e._next._prev = e) : (t[i] = e),
            (e._prev = o),
            (e.parent = e._dp = t),
            e
          )
        },
        _t = function (t, e, n, i) {
          void 0 === n && (n = '_first'), void 0 === i && (i = '_last')
          var r = e._prev,
            s = e._next
          r ? (r._next = s) : t[n] === e && (t[n] = s),
            s ? (s._prev = r) : t[i] === e && (t[i] = r),
            (e._next = e._prev = e.parent = null)
        },
        yt = function (t, e) {
          t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove(t),
            (t._act = 0)
        },
        xt = function (t, e) {
          if (t && (!e || e._end > t._dur || e._start < 0))
            for (var n = t; n; ) (n._dirty = 1), (n = n.parent)
          return t
        },
        bt = function (t) {
          for (var e = t.parent; e && e.parent; )
            (e._dirty = 1), e.totalDuration(), (e = e.parent)
          return t
        },
        wt = function t(e) {
          return !e || (e._ts && t(e.parent))
        },
        Mt = function (t) {
          return t._repeat
            ? St(t._tTime, (t = t.duration() + t._rDelay)) * t
            : 0
        },
        St = function (t, e) {
          var n = Math.floor((t /= e))
          return t && n === t ? n - 1 : n
        },
        Tt = function (t, e) {
          return (
            (t - e._start) * e._ts +
            (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
          )
        },
        Et = function (t) {
          return (t._end = st(
            t._start + (t._tDur / Math.abs(t._ts || t._rts || m) || 0),
          ))
        },
        Dt = function (t, e) {
          var n = t._dp
          return (
            n &&
              n.smoothChildTiming &&
              t._ts &&
              ((t._start = st(
                n._time -
                  (t._ts > 0
                    ? e / t._ts
                    : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts),
              )),
              Et(t),
              n._dirty || xt(n, t)),
            t
          )
        },
        At = function (t, e) {
          var n
          if (
            ((e._time || (e._initted && !e._dur)) &&
              ((n = Tt(t.rawTime(), e)),
              (!e._dur || Ut(0, e.totalDuration(), n) - e._tTime > m) &&
                e.render(n, !0)),
            xt(t, e)._dp && t._initted && t._time >= t._dur && t._ts)
          ) {
            if (t._dur < t.duration())
              for (n = t; n._dp; )
                n.rawTime() >= 0 && n.totalTime(n._tTime), (n = n._dp)
            t._zTime = -1e-8
          }
        },
        Ct = function (t, e, n, i) {
          return (
            e.parent && yt(e),
            (e._start = st(
              (S(n) ? n : n || t !== r ? kt(t, n, e) : t._time) + e._delay,
            )),
            (e._end = st(
              e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0),
            )),
            vt(t, e, '_first', '_last', t._sort ? '_start' : 0),
            Ft(e) || (t._recent = e),
            i || At(t, e),
            t
          )
        },
        Lt = function (t, e) {
          return (
            (z.ScrollTrigger || G('scrollTrigger', e)) &&
            z.ScrollTrigger.create(e, t)
          )
        },
        Rt = function (t, e, n, i) {
          return (
            Fe(t, e),
            t._initted
              ? !n &&
                t._pt &&
                ((t._dur && !1 !== t.vars.lazy) || (!t._dur && t.vars.lazy)) &&
                c !== de.frame
                ? (X.push(t), (t._lazy = [e, i]), 1)
                : void 0
              : 1
          )
        },
        Pt = function t(e) {
          var n = e.parent
          return (
            n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || t(n))
          )
        },
        Ft = function (t) {
          var e = t.data
          return 'isFromStart' === e || 'isStart' === e
        },
        It = function (t, e, n, i) {
          var r = t._repeat,
            s = st(e) || 0,
            o = t._tTime / t._tDur
          return (
            o && !i && (t._time *= s / t._dur),
            (t._dur = s),
            (t._tDur = r
              ? r < 0
                ? 1e10
                : st(s * (r + 1) + t._rDelay * r)
              : s),
            o > 0 && !i ? Dt(t, (t._tTime = t._tDur * o)) : t.parent && Et(t),
            n || xt(t.parent, t),
            t
          )
        },
        Ot = function (t) {
          return t instanceof De ? xt(t) : It(t, t._dur)
        },
        Nt = { _start: 0, endTime: j, totalDuration: j },
        kt = function t(e, n, i) {
          var r,
            s,
            o,
            a = e.labels,
            l = e._recent || Nt,
            c = e.duration() >= f ? l.endTime(!1) : e._dur
          return w(n) && (isNaN(n) || n in a)
            ? ((s = n.charAt(0)),
              (o = '%' === n.substr(-1)),
              (r = n.indexOf('=')),
              '<' === s || '>' === s
                ? (r >= 0 && (n = n.replace(/=/, '')),
                  ('<' === s ? l._start : l.endTime(l._repeat >= 0)) +
                    (parseFloat(n.substr(1)) || 0) *
                      (o ? (r < 0 ? l : i).totalDuration() / 100 : 1))
                : r < 0
                ? (n in a || (a[n] = c), a[n])
                : ((s = parseFloat(n.charAt(r - 1) + n.substr(r + 1))),
                  o && i && (s = (s / 100) * (R(i) ? i[0] : i).totalDuration()),
                  r > 1 ? t(e, n.substr(0, r - 1), i) + s : c + s))
            : null == n
            ? c
            : +n
        },
        Bt = function (t, e, n) {
          var i,
            r,
            s = S(e[1]),
            o = (s ? 2 : 1) + (t < 2 ? 0 : 1),
            a = e[o]
          if ((s && (a.duration = e[1]), (a.parent = n), t)) {
            for (i = a, r = n; r && !('immediateRender' in i); )
              (i = r.vars.defaults || {}), (r = D(r.vars.inherit) && r.parent)
            ;(a.immediateRender = D(i.immediateRender)),
              t < 2 ? (a.runBackwards = 1) : (a.startAt = e[o - 1])
          }
          return new Be(e[0], a, e[o + 1])
        },
        zt = function (t, e) {
          return t || 0 === t ? e(t) : e
        },
        Ut = function (t, e, n) {
          return n < t ? t : n > e ? e : n
        },
        Ht = function (t, e) {
          return w(t) && (e = B.exec(t)) ? e[1] : ''
        },
        Gt = [].slice,
        Vt = function (t, e) {
          return (
            t &&
            E(t) &&
            'length' in t &&
            ((!e && !t.length) || (t.length - 1 in t && E(t[0]))) &&
            !t.nodeType &&
            t !== s
          )
        },
        Wt = function (t, e, n) {
          return !w(t) || n || (!o && pe())
            ? R(t)
              ? (function (t, e, n) {
                  return (
                    void 0 === n && (n = []),
                    t.forEach(function (t) {
                      var i
                      return (w(t) && !e) || Vt(t, 1)
                        ? (i = n).push.apply(i, Wt(t))
                        : n.push(t)
                    }) || n
                  )
                })(t, n)
              : Vt(t)
              ? Gt.call(t, 0)
              : t
              ? [t]
              : []
            : Gt.call((e || a).querySelectorAll(t), 0)
        },
        jt = function (t) {
          return t.sort(function () {
            return 0.5 - Math.random()
          })
        },
        qt = function (t) {
          if (M(t)) return t
          var e = E(t) ? t : { each: t },
            n = xe(e.ease),
            i = e.from || 0,
            r = parseFloat(e.base) || 0,
            s = {},
            o = i > 0 && i < 1,
            a = isNaN(i) || o,
            l = e.axis,
            c = i,
            u = i
          return (
            w(i)
              ? (c = u = { center: 0.5, edges: 0.5, end: 1 }[i] || 0)
              : !o && a && ((c = i[0]), (u = i[1])),
            function (t, o, h) {
              var d,
                p,
                m,
                g,
                v,
                _,
                x,
                b,
                w,
                M = (h || e).length,
                S = s[M]
              if (!S) {
                if (!(w = 'auto' === e.grid ? 0 : (e.grid || [1, f])[1])) {
                  for (
                    x = -f;
                    x < (x = h[w++].getBoundingClientRect().left) && w < M;

                  );
                  w--
                }
                for (
                  S = s[M] = [],
                    d = a ? Math.min(w, M) * c - 0.5 : i % w,
                    p = w === f ? 0 : a ? (M * u) / w - 0.5 : (i / w) | 0,
                    x = 0,
                    b = f,
                    _ = 0;
                  _ < M;
                  _++
                )
                  (m = (_ % w) - d),
                    (g = p - ((_ / w) | 0)),
                    (S[_] = v = l
                      ? Math.abs('y' === l ? g : m)
                      : y(m * m + g * g)),
                    v > x && (x = v),
                    v < b && (b = v)
                'random' === i && jt(S),
                  (S.max = x - b),
                  (S.min = b),
                  (S.v = M =
                    (parseFloat(e.amount) ||
                      parseFloat(e.each) *
                        (w > M
                          ? M - 1
                          : l
                          ? 'y' === l
                            ? M / w
                            : w
                          : Math.max(w, M / w)) ||
                      0) * ('edges' === i ? -1 : 1)),
                  (S.b = M < 0 ? r - M : r),
                  (S.u = Ht(e.amount || e.each) || 0),
                  (n = n && M < 0 ? _e(n) : n)
              }
              return (
                (M = (S[t] - S.min) / S.max || 0),
                st(S.b + (n ? n(M) : M) * S.v) + S.u
              )
            }
          )
        },
        Xt = function (t) {
          var e = Math.pow(10, ((t + '').split('.')[1] || '').length)
          return function (n) {
            var i = Math.round(parseFloat(n) / t) * t * e
            return (i - (i % 1)) / e + (S(n) ? 0 : Ht(n))
          }
        },
        Yt = function (t, e) {
          var n,
            i,
            r = R(t)
          return (
            !r &&
              E(t) &&
              ((n = r = t.radius || f),
              t.values
                ? ((t = Wt(t.values)), (i = !S(t[0])) && (n *= n))
                : (t = Xt(t.increment))),
            zt(
              e,
              r
                ? M(t)
                  ? function (e) {
                      return (i = t(e)), Math.abs(i - e) <= n ? i : e
                    }
                  : function (e) {
                      for (
                        var r,
                          s,
                          o = parseFloat(i ? e.x : e),
                          a = parseFloat(i ? e.y : 0),
                          l = f,
                          c = 0,
                          u = t.length;
                        u--;

                      )
                        (r = i
                          ? (r = t[u].x - o) * r + (s = t[u].y - a) * s
                          : Math.abs(t[u] - o)) < l && ((l = r), (c = u))
                      return (
                        (c = !n || l <= n ? t[c] : e),
                        i || c === e || S(e) ? c : c + Ht(e)
                      )
                    }
                : Xt(t),
            )
          )
        },
        Jt = function (t, e, n, i) {
          return zt(R(t) ? !e : !0 === n ? !!(n = 0) : !i, function () {
            return R(t)
              ? t[~~(Math.random() * t.length)]
              : (n = n || 1e-5) &&
                  (i = n < 1 ? Math.pow(10, (n + '').length - 2) : 1) &&
                  Math.floor(
                    Math.round(
                      (t - n / 2 + Math.random() * (e - t + 0.99 * n)) / n,
                    ) *
                      n *
                      i,
                  ) / i
          })
        },
        Zt = function (t, e, n) {
          return zt(n, function (n) {
            return t[~~e(n)]
          })
        },
        Kt = function (t) {
          for (var e, n, i, r, s = 0, o = ''; ~(e = t.indexOf('random(', s)); )
            (i = t.indexOf(')', e)),
              (r = '[' === t.charAt(e + 7)),
              (n = t.substr(e + 7, i - e - 7).match(r ? k : P)),
              (o +=
                t.substr(s, e - s) +
                Jt(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5)),
              (s = i + 1)
          return o + t.substr(s, t.length - s)
        },
        Qt = function (t, e, n, i, r) {
          var s = e - t,
            o = i - n
          return zt(r, function (e) {
            return n + (((e - t) / s) * o || 0)
          })
        },
        $t = function (t, e, n) {
          var i,
            r,
            s,
            o = t.labels,
            a = f
          for (i in o)
            (r = o[i] - e) < 0 == !!n &&
              r &&
              a > (r = Math.abs(r)) &&
              ((s = i), (a = r))
          return s
        },
        te = function (t, e, n) {
          var i,
            r,
            s = t.vars,
            o = s[e]
          if (o)
            return (
              (i = s[e + 'Params']),
              (r = s.callbackScope || t),
              n && X.length && lt(),
              i ? o.apply(r, i) : o.call(r)
            )
        },
        ee = function (t) {
          return (
            yt(t),
            t.scrollTrigger && t.scrollTrigger.kill(!1),
            t.progress() < 1 && te(t, 'onInterrupt'),
            t
          )
        },
        ne = function (t) {
          var e = (t = (!t.name && t.default) || t).name,
            n = M(t),
            i =
              e && !n && t.init
                ? function () {
                    this._props = []
                  }
                : t,
            r = {
              init: j,
              render: Xe,
              add: Re,
              kill: Je,
              modifier: Ye,
              rawVars: 0,
            },
            s = {
              targetTest: 0,
              get: 0,
              getSetter: Ve,
              aliases: {},
              register: 0,
            }
          if ((pe(), t !== i)) {
            if (J[e]) return
            dt(i, dt(mt(t, r), s)),
              pt(i.prototype, pt(r, mt(t, s))),
              (J[(i.prop = e)] = i),
              t.targetTest && (Q.push(i), (q[e] = 1)),
              (e =
                ('css' === e
                  ? 'CSS'
                  : e.charAt(0).toUpperCase() + e.substr(1)) + 'Plugin')
          }
          W(e, i), t.register && t.register(nn, i, Qe)
        },
        ie = 255,
        re = {
          aqua: [0, ie, ie],
          lime: [0, ie, 0],
          silver: [192, 192, 192],
          black: [0, 0, 0],
          maroon: [128, 0, 0],
          teal: [0, 128, 128],
          blue: [0, 0, ie],
          navy: [0, 0, 128],
          white: [ie, ie, ie],
          olive: [128, 128, 0],
          yellow: [ie, ie, 0],
          orange: [ie, 165, 0],
          gray: [128, 128, 128],
          purple: [128, 0, 128],
          green: [0, 128, 0],
          red: [ie, 0, 0],
          pink: [ie, 192, 203],
          cyan: [0, ie, ie],
          transparent: [ie, ie, ie, 0],
        },
        se = function (t, e, n) {
          return (
            ((6 * (t += t < 0 ? 1 : t > 1 ? -1 : 0) < 1
              ? e + (n - e) * t * 6
              : t < 0.5
              ? n
              : 3 * t < 2
              ? e + (n - e) * (2 / 3 - t) * 6
              : e) *
              ie +
              0.5) |
            0
          )
        },
        oe = function (t, e, n) {
          var i,
            r,
            s,
            o,
            a,
            l,
            c,
            u,
            h,
            d,
            p = t ? (S(t) ? [t >> 16, (t >> 8) & ie, t & ie] : 0) : re.black
          if (!p) {
            if (
              (',' === t.substr(-1) && (t = t.substr(0, t.length - 1)), re[t])
            )
              p = re[t]
            else if ('#' === t.charAt(0)) {
              if (
                (t.length < 6 &&
                  ((i = t.charAt(1)),
                  (r = t.charAt(2)),
                  (s = t.charAt(3)),
                  (t =
                    '#' +
                    i +
                    i +
                    r +
                    r +
                    s +
                    s +
                    (5 === t.length ? t.charAt(4) + t.charAt(4) : ''))),
                9 === t.length)
              )
                return [
                  (p = parseInt(t.substr(1, 6), 16)) >> 16,
                  (p >> 8) & ie,
                  p & ie,
                  parseInt(t.substr(7), 16) / 255,
                ]
              p = [(t = parseInt(t.substr(1), 16)) >> 16, (t >> 8) & ie, t & ie]
            } else if ('hsl' === t.substr(0, 3))
              if (((p = d = t.match(P)), e)) {
                if (~t.indexOf('='))
                  return (p = t.match(F)), n && p.length < 4 && (p[3] = 1), p
              } else
                (o = (+p[0] % 360) / 360),
                  (a = +p[1] / 100),
                  (i =
                    2 * (l = +p[2] / 100) -
                    (r = l <= 0.5 ? l * (a + 1) : l + a - l * a)),
                  p.length > 3 && (p[3] *= 1),
                  (p[0] = se(o + 1 / 3, i, r)),
                  (p[1] = se(o, i, r)),
                  (p[2] = se(o - 1 / 3, i, r))
            else p = t.match(P) || re.transparent
            p = p.map(Number)
          }
          return (
            e &&
              !d &&
              ((i = p[0] / ie),
              (r = p[1] / ie),
              (s = p[2] / ie),
              (l = ((c = Math.max(i, r, s)) + (u = Math.min(i, r, s))) / 2),
              c === u
                ? (o = a = 0)
                : ((h = c - u),
                  (a = l > 0.5 ? h / (2 - c - u) : h / (c + u)),
                  (o =
                    c === i
                      ? (r - s) / h + (r < s ? 6 : 0)
                      : c === r
                      ? (s - i) / h + 2
                      : (i - r) / h + 4),
                  (o *= 60)),
              (p[0] = ~~(o + 0.5)),
              (p[1] = ~~(100 * a + 0.5)),
              (p[2] = ~~(100 * l + 0.5))),
            n && p.length < 4 && (p[3] = 1),
            p
          )
        },
        ae = function (t) {
          var e = [],
            n = [],
            i = -1
          return (
            t.split(ce).forEach(function (t) {
              var r = t.match(I) || []
              e.push.apply(e, r), n.push((i += r.length + 1))
            }),
            (e.c = n),
            e
          )
        },
        le = function (t, e, n) {
          var i,
            r,
            s,
            o,
            a = '',
            l = (t + a).match(ce),
            c = e ? 'hsla(' : 'rgba(',
            u = 0
          if (!l) return t
          if (
            ((l = l.map(function (t) {
              return (
                (t = oe(t, e, 1)) &&
                c +
                  (e
                    ? t[0] + ',' + t[1] + '%,' + t[2] + '%,' + t[3]
                    : t.join(',')) +
                  ')'
              )
            })),
            n && ((s = ae(t)), (i = n.c).join(a) !== s.c.join(a)))
          )
            for (o = (r = t.replace(ce, '1').split(I)).length - 1; u < o; u++)
              a +=
                r[u] +
                (~i.indexOf(u)
                  ? l.shift() || c + '0,0,0,0)'
                  : (s.length ? s : l.length ? l : n).shift())
          if (!r)
            for (o = (r = t.split(ce)).length - 1; u < o; u++) a += r[u] + l[u]
          return a + r[o]
        },
        ce = (function () {
          var t,
            e =
              '(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b'
          for (t in re) e += '|' + t + '\\b'
          return new RegExp(e + ')', 'gi')
        })(),
        ue = /hsl[a]?\(/,
        he = function (t) {
          var e,
            n = t.join(' ')
          if (((ce.lastIndex = 0), ce.test(n)))
            return (
              (e = ue.test(n)),
              (t[1] = le(t[1], e)),
              (t[0] = le(t[0], e, ae(t[1]))),
              !0
            )
        },
        de = (function () {
          var t,
            e,
            n,
            i,
            r,
            c,
            u = Date.now,
            d = 500,
            p = 33,
            f = u(),
            m = f,
            g = 1e3 / 240,
            v = g,
            _ = [],
            y = function n(s) {
              var o,
                a,
                l,
                h,
                y = u() - m,
                x = !0 === s
              if (
                (y > d && (f += y - p),
                ((o = (l = (m += y) - f) - v) > 0 || x) &&
                  ((h = ++i.frame),
                  (r = l - 1e3 * i.time),
                  (i.time = l /= 1e3),
                  (v += o + (o >= g ? 4 : g - o)),
                  (a = 1)),
                x || (t = e(n)),
                a)
              )
                for (c = 0; c < _.length; c++) _[c](l, r, h, s)
            }
          return (
            (i = {
              time: 0,
              frame: 0,
              tick: function () {
                y(!0)
              },
              deltaRatio: function (t) {
                return r / (1e3 / (t || 60))
              },
              wake: function () {
                l &&
                  (!o &&
                    A() &&
                    ((s = o = window),
                    (a = s.document || {}),
                    (z.gsap = nn),
                    (s.gsapVersions || (s.gsapVersions = [])).push(nn.version),
                    H(U || s.GreenSockGlobals || (!s.gsap && s) || {}),
                    (n = s.requestAnimationFrame)),
                  t && i.sleep(),
                  (e =
                    n ||
                    function (t) {
                      return setTimeout(t, (v - 1e3 * i.time + 1) | 0)
                    }),
                  (h = 1),
                  y(2))
              },
              sleep: function () {
                ;(n ? s.cancelAnimationFrame : clearTimeout)(t),
                  (h = 0),
                  (e = j)
              },
              lagSmoothing: function (t, e) {
                ;(d = t || 1e8), (p = Math.min(e, d, 0))
              },
              fps: function (t) {
                ;(g = 1e3 / (t || 240)), (v = 1e3 * i.time + g)
              },
              add: function (t, e, n) {
                var r = e
                  ? function (e, n, s, o) {
                      t(e, n, s, o), i.remove(r)
                    }
                  : t
                return i.remove(t), _[n ? 'unshift' : 'push'](r), pe(), r
              },
              remove: function (t, e) {
                ~(e = _.indexOf(t)) && _.splice(e, 1) && c >= e && c--
              },
              _listeners: _,
            }),
            i
          )
        })(),
        pe = function () {
          return !h && de.wake()
        },
        fe = {},
        me = /^[\d.\-M][\d.\-,\s]/,
        ge = /["']/g,
        ve = function (t) {
          for (
            var e,
              n,
              i,
              r = {},
              s = t.substr(1, t.length - 3).split(':'),
              o = s[0],
              a = 1,
              l = s.length;
            a < l;
            a++
          )
            (n = s[a]),
              (e = a !== l - 1 ? n.lastIndexOf(',') : n.length),
              (i = n.substr(0, e)),
              (r[o] = isNaN(i) ? i.replace(ge, '').trim() : +i),
              (o = n.substr(e + 1).trim())
          return r
        },
        _e = function (t) {
          return function (e) {
            return 1 - t(1 - e)
          }
        },
        ye = function t(e, n) {
          for (var i, r = e._first; r; )
            r instanceof De
              ? t(r, n)
              : !r.vars.yoyoEase ||
                (r._yoyo && r._repeat) ||
                r._yoyo === n ||
                (r.timeline
                  ? t(r.timeline, n)
                  : ((i = r._ease),
                    (r._ease = r._yEase),
                    (r._yEase = i),
                    (r._yoyo = n))),
              (r = r._next)
        },
        xe = function (t, e) {
          return (
            (t &&
              (M(t)
                ? t
                : fe[t] ||
                  (function (t) {
                    var e,
                      n,
                      i,
                      r,
                      s = (t + '').split('('),
                      o = fe[s[0]]
                    return o && s.length > 1 && o.config
                      ? o.config.apply(
                          null,
                          ~t.indexOf('{')
                            ? [ve(s[1])]
                            : ((e = t),
                              (n = e.indexOf('(') + 1),
                              (i = e.indexOf(')')),
                              (r = e.indexOf('(', n)),
                              e.substring(
                                n,
                                ~r && r < i ? e.indexOf(')', i + 1) : i,
                              ))
                                .split(',')
                                .map(ut),
                        )
                      : fe._CE && me.test(t)
                      ? fe._CE('', t)
                      : o
                  })(t))) ||
            e
          )
        },
        be = function (t, e, n, i) {
          void 0 === n &&
            (n = function (t) {
              return 1 - e(1 - t)
            }),
            void 0 === i &&
              (i = function (t) {
                return t < 0.5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2
              })
          var r,
            s = { easeIn: e, easeOut: n, easeInOut: i }
          return (
            it(t, function (t) {
              for (var e in ((fe[t] = z[t] = s),
              (fe[(r = t.toLowerCase())] = n),
              s))
                fe[
                  r +
                    ('easeIn' === e
                      ? '.in'
                      : 'easeOut' === e
                      ? '.out'
                      : '.inOut')
                ] = fe[t + '.' + e] = s[e]
            }),
            s
          )
        },
        we = function (t) {
          return function (e) {
            return e < 0.5 ? (1 - t(1 - 2 * e)) / 2 : 0.5 + t(2 * (e - 0.5)) / 2
          }
        },
        Me = function t(e, n, i) {
          var r = n >= 1 ? n : 1,
            s = (i || (e ? 0.3 : 0.45)) / (n < 1 ? n : 1),
            o = (s / g) * (Math.asin(1 / r) || 0),
            a = function (t) {
              return 1 === t ? 1 : r * Math.pow(2, -10 * t) * b((t - o) * s) + 1
            },
            l =
              'out' === e
                ? a
                : 'in' === e
                ? function (t) {
                    return 1 - a(1 - t)
                  }
                : we(a)
          return (
            (s = g / s),
            (l.config = function (n, i) {
              return t(e, n, i)
            }),
            l
          )
        },
        Se = function t(e, n) {
          void 0 === n && (n = 1.70158)
          var i = function (t) {
              return t ? --t * t * ((n + 1) * t + n) + 1 : 0
            },
            r =
              'out' === e
                ? i
                : 'in' === e
                ? function (t) {
                    return 1 - i(1 - t)
                  }
                : we(i)
          return (
            (r.config = function (n) {
              return t(e, n)
            }),
            r
          )
        }
      it('Linear,Quad,Cubic,Quart,Quint,Strong', function (t, e) {
        var n = e < 5 ? e + 1 : e
        be(
          t + ',Power' + (n - 1),
          e
            ? function (t) {
                return Math.pow(t, n)
              }
            : function (t) {
                return t
              },
          function (t) {
            return 1 - Math.pow(1 - t, n)
          },
          function (t) {
            return t < 0.5
              ? Math.pow(2 * t, n) / 2
              : 1 - Math.pow(2 * (1 - t), n) / 2
          },
        )
      }),
        (fe.Linear.easeNone = fe.none = fe.Linear.easeIn),
        be('Elastic', Me('in'), Me('out'), Me()),
        (function (t, e) {
          var n = function (n) {
            return n < 0.36363636363636365
              ? t * n * n
              : n < 0.7272727272727273
              ? t * Math.pow(n - 1.5 / e, 2) + 0.75
              : n < 0.9090909090909092
              ? t * (n -= 2.25 / e) * n + 0.9375
              : t * Math.pow(n - 2.625 / e, 2) + 0.984375
          }
          be(
            'Bounce',
            function (t) {
              return 1 - n(1 - t)
            },
            n,
          )
        })(7.5625, 2.75),
        be('Expo', function (t) {
          return t ? Math.pow(2, 10 * (t - 1)) : 0
        }),
        be('Circ', function (t) {
          return -(y(1 - t * t) - 1)
        }),
        be('Sine', function (t) {
          return 1 === t ? 1 : 1 - x(t * v)
        }),
        be('Back', Se('in'), Se('out'), Se()),
        (fe.SteppedEase = fe.steps = z.SteppedEase = {
          config: function (t, e) {
            void 0 === t && (t = 1)
            var n = 1 / t,
              i = t + (e ? 0 : 1),
              r = e ? 1 : 0
            return function (t) {
              return (((i * Ut(0, 0.99999999, t)) | 0) + r) * n
            }
          },
        }),
        (p.ease = fe['quad.out']),
        it('onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt', function (t) {
          return ($ += t + ',' + t + 'Params,')
        })
      var Te = function (t, e) {
          ;(this.id = _++),
            (t._gsap = this),
            (this.target = t),
            (this.harness = e),
            (this.get = e ? e.get : nt),
            (this.set = e ? e.getSetter : Ve)
        },
        Ee = (function () {
          function t(t) {
            ;(this.vars = t),
              (this._delay = +t.delay || 0),
              (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) &&
                ((this._rDelay = t.repeatDelay || 0),
                (this._yoyo = !!t.yoyo || !!t.yoyoEase)),
              (this._ts = 1),
              It(this, +t.duration, 1, 1),
              (this.data = t.data),
              h || de.wake()
          }
          var e = t.prototype
          return (
            (e.delay = function (t) {
              return t || 0 === t
                ? (this.parent &&
                    this.parent.smoothChildTiming &&
                    this.startTime(this._start + t - this._delay),
                  (this._delay = t),
                  this)
                : this._delay
            }),
            (e.duration = function (t) {
              return arguments.length
                ? this.totalDuration(
                    this._repeat > 0
                      ? t + (t + this._rDelay) * this._repeat
                      : t,
                  )
                : this.totalDuration() && this._dur
            }),
            (e.totalDuration = function (t) {
              return arguments.length
                ? ((this._dirty = 0),
                  It(
                    this,
                    this._repeat < 0
                      ? t
                      : (t - this._repeat * this._rDelay) / (this._repeat + 1),
                  ))
                : this._tDur
            }),
            (e.totalTime = function (t, e) {
              if ((pe(), !arguments.length)) return this._tTime
              var n = this._dp
              if (n && n.smoothChildTiming && this._ts) {
                for (
                  Dt(this, t), !n._dp || n.parent || At(n, this);
                  n && n.parent;

                )
                  n.parent._time !==
                    n._start +
                      (n._ts >= 0
                        ? n._tTime / n._ts
                        : (n.totalDuration() - n._tTime) / -n._ts) &&
                    n.totalTime(n._tTime, !0),
                    (n = n.parent)
                !this.parent &&
                  this._dp.autoRemoveChildren &&
                  ((this._ts > 0 && t < this._tDur) ||
                    (this._ts < 0 && t > 0) ||
                    (!this._tDur && !t)) &&
                  Ct(this._dp, this, this._start - this._delay)
              }
              return (
                (this._tTime !== t ||
                  (!this._dur && !e) ||
                  (this._initted && Math.abs(this._zTime) === m) ||
                  (!t && !this._initted && (this.add || this._ptLookup))) &&
                  (this._ts || (this._pTime = t), ct(this, t, e)),
                this
              )
            }),
            (e.time = function (t, e) {
              return arguments.length
                ? this.totalTime(
                    Math.min(this.totalDuration(), t + Mt(this)) %
                      (this._dur + this._rDelay) || (t ? this._dur : 0),
                    e,
                  )
                : this._time
            }),
            (e.totalProgress = function (t, e) {
              return arguments.length
                ? this.totalTime(this.totalDuration() * t, e)
                : this.totalDuration()
                ? Math.min(1, this._tTime / this._tDur)
                : this.ratio
            }),
            (e.progress = function (t, e) {
              return arguments.length
                ? this.totalTime(
                    this.duration() *
                      (!this._yoyo || 1 & this.iteration() ? t : 1 - t) +
                      Mt(this),
                    e,
                  )
                : this.duration()
                ? Math.min(1, this._time / this._dur)
                : this.ratio
            }),
            (e.iteration = function (t, e) {
              var n = this.duration() + this._rDelay
              return arguments.length
                ? this.totalTime(this._time + (t - 1) * n, e)
                : this._repeat
                ? St(this._tTime, n) + 1
                : 1
            }),
            (e.timeScale = function (t) {
              if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts
              if (this._rts === t) return this
              var e =
                this.parent && this._ts
                  ? Tt(this.parent._time, this)
                  : this._tTime
              return (
                (this._rts = +t || 0),
                (this._ts = this._ps || -1e-8 === t ? 0 : this._rts),
                this.totalTime(Ut(-this._delay, this._tDur, e), !0),
                Et(this),
                bt(this)
              )
            }),
            (e.paused = function (t) {
              return arguments.length
                ? (this._ps !== t &&
                    ((this._ps = t),
                    t
                      ? ((this._pTime =
                          this._tTime ||
                          Math.max(-this._delay, this.rawTime())),
                        (this._ts = this._act = 0))
                      : (pe(),
                        (this._ts = this._rts),
                        this.totalTime(
                          this.parent && !this.parent.smoothChildTiming
                            ? this.rawTime()
                            : this._tTime || this._pTime,
                          1 === this.progress() &&
                            Math.abs(this._zTime) !== m &&
                            (this._tTime -= m),
                        ))),
                  this)
                : this._ps
            }),
            (e.startTime = function (t) {
              if (arguments.length) {
                this._start = t
                var e = this.parent || this._dp
                return (
                  e &&
                    (e._sort || !this.parent) &&
                    Ct(e, this, t - this._delay),
                  this
                )
              }
              return this._start
            }),
            (e.endTime = function (t) {
              return (
                this._start +
                (D(t) ? this.totalDuration() : this.duration()) /
                  Math.abs(this._ts || 1)
              )
            }),
            (e.rawTime = function (t) {
              var e = this.parent || this._dp
              return e
                ? t &&
                  (!this._ts ||
                    (this._repeat && this._time && this.totalProgress() < 1))
                  ? this._tTime % (this._dur + this._rDelay)
                  : this._ts
                  ? Tt(e.rawTime(t), this)
                  : this._tTime
                : this._tTime
            }),
            (e.globalTime = function (t) {
              for (var e = this, n = arguments.length ? t : e.rawTime(); e; )
                (n = e._start + n / (e._ts || 1)), (e = e._dp)
              return n
            }),
            (e.repeat = function (t) {
              return arguments.length
                ? ((this._repeat = t === 1 / 0 ? -2 : t), Ot(this))
                : -2 === this._repeat
                ? 1 / 0
                : this._repeat
            }),
            (e.repeatDelay = function (t) {
              if (arguments.length) {
                var e = this._time
                return (this._rDelay = t), Ot(this), e ? this.time(e) : this
              }
              return this._rDelay
            }),
            (e.yoyo = function (t) {
              return arguments.length ? ((this._yoyo = t), this) : this._yoyo
            }),
            (e.seek = function (t, e) {
              return this.totalTime(kt(this, t), D(e))
            }),
            (e.restart = function (t, e) {
              return this.play().totalTime(t ? -this._delay : 0, D(e))
            }),
            (e.play = function (t, e) {
              return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
            }),
            (e.reverse = function (t, e) {
              return (
                null != t && this.seek(t || this.totalDuration(), e),
                this.reversed(!0).paused(!1)
              )
            }),
            (e.pause = function (t, e) {
              return null != t && this.seek(t, e), this.paused(!0)
            }),
            (e.resume = function () {
              return this.paused(!1)
            }),
            (e.reversed = function (t) {
              return arguments.length
                ? (!!t !== this.reversed() &&
                    this.timeScale(-this._rts || (t ? -1e-8 : 0)),
                  this)
                : this._rts < 0
            }),
            (e.invalidate = function () {
              return (
                (this._initted = this._act = 0), (this._zTime = -1e-8), this
              )
            }),
            (e.isActive = function () {
              var t,
                e = this.parent || this._dp,
                n = this._start
              return !(
                e &&
                !(
                  this._ts &&
                  this._initted &&
                  e.isActive() &&
                  (t = e.rawTime(!0)) >= n &&
                  t < this.endTime(!0) - m
                )
              )
            }),
            (e.eventCallback = function (t, e, n) {
              var i = this.vars
              return arguments.length > 1
                ? (e
                    ? ((i[t] = e),
                      n && (i[t + 'Params'] = n),
                      'onUpdate' === t && (this._onUpdate = e))
                    : delete i[t],
                  this)
                : i[t]
            }),
            (e.then = function (t) {
              var e = this
              return new Promise(function (n) {
                var i = M(t) ? t : ht,
                  r = function () {
                    var t = e.then
                    ;(e.then = null),
                      M(i) && (i = i(e)) && (i.then || i === e) && (e.then = t),
                      n(i),
                      (e.then = t)
                  }
                ;(e._initted && 1 === e.totalProgress() && e._ts >= 0) ||
                (!e._tTime && e._ts < 0)
                  ? r()
                  : (e._prom = r)
              })
            }),
            (e.kill = function () {
              ee(this)
            }),
            t
          )
        })()
      dt(Ee.prototype, {
        _time: 0,
        _start: 0,
        _end: 0,
        _tTime: 0,
        _tDur: 0,
        _dirty: 0,
        _repeat: 0,
        _yoyo: !1,
        parent: null,
        _initted: !1,
        _rDelay: 0,
        _ts: 1,
        _dp: 0,
        ratio: 0,
        _zTime: -1e-8,
        _prom: 0,
        _ps: !1,
        _rts: 1,
      })
      var De = (function (n) {
        function i(e, i) {
          var s
          return (
            void 0 === e && (e = {}),
            ((s = n.call(this, e) || this).labels = {}),
            (s.smoothChildTiming = !!e.smoothChildTiming),
            (s.autoRemoveChildren = !!e.autoRemoveChildren),
            (s._sort = D(e.sortChildren)),
            r && Ct(e.parent || r, t(s), i),
            e.reversed && s.reverse(),
            e.paused && s.paused(!0),
            e.scrollTrigger && Lt(t(s), e.scrollTrigger),
            s
          )
        }
        e(i, n)
        var s = i.prototype
        return (
          (s.to = function (t, e, n) {
            return Bt(0, arguments, this), this
          }),
          (s.from = function (t, e, n) {
            return Bt(1, arguments, this), this
          }),
          (s.fromTo = function (t, e, n, i) {
            return Bt(2, arguments, this), this
          }),
          (s.set = function (t, e, n) {
            return (
              (e.duration = 0),
              (e.parent = this),
              gt(e).repeatDelay || (e.repeat = 0),
              (e.immediateRender = !!e.immediateRender),
              new Be(t, e, kt(this, n), 1),
              this
            )
          }),
          (s.call = function (t, e, n) {
            return Ct(this, Be.delayedCall(0, t, e), n)
          }),
          (s.staggerTo = function (t, e, n, i, r, s, o) {
            return (
              (n.duration = e),
              (n.stagger = n.stagger || i),
              (n.onComplete = s),
              (n.onCompleteParams = o),
              (n.parent = this),
              new Be(t, n, kt(this, r)),
              this
            )
          }),
          (s.staggerFrom = function (t, e, n, i, r, s, o) {
            return (
              (n.runBackwards = 1),
              (gt(n).immediateRender = D(n.immediateRender)),
              this.staggerTo(t, e, n, i, r, s, o)
            )
          }),
          (s.staggerFromTo = function (t, e, n, i, r, s, o, a) {
            return (
              (i.startAt = n),
              (gt(i).immediateRender = D(i.immediateRender)),
              this.staggerTo(t, e, i, r, s, o, a)
            )
          }),
          (s.render = function (t, e, n) {
            var i,
              s,
              o,
              a,
              l,
              c,
              u,
              h,
              d,
              p,
              f,
              g,
              v = this._time,
              _ = this._dirty ? this.totalDuration() : this._tDur,
              y = this._dur,
              x = t <= 0 ? 0 : st(t),
              b = this._zTime < 0 != t < 0 && (this._initted || !y)
            if (
              (this !== r && x > _ && t >= 0 && (x = _),
              x !== this._tTime || n || b)
            ) {
              if (
                (v !== this._time &&
                  y &&
                  ((x += this._time - v), (t += this._time - v)),
                (i = x),
                (d = this._start),
                (c = !(h = this._ts)),
                b && (y || (v = this._zTime), (t || !e) && (this._zTime = t)),
                this._repeat)
              ) {
                if (
                  ((f = this._yoyo),
                  (l = y + this._rDelay),
                  this._repeat < -1 && t < 0)
                )
                  return this.totalTime(100 * l + t, e, n)
                if (
                  ((i = st(x % l)),
                  x === _
                    ? ((a = this._repeat), (i = y))
                    : ((a = ~~(x / l)) && a === x / l && ((i = y), a--),
                      i > y && (i = y)),
                  (p = St(this._tTime, l)),
                  !v && this._tTime && p !== a && (p = a),
                  f && 1 & a && ((i = y - i), (g = 1)),
                  a !== p && !this._lock)
                ) {
                  var w = f && 1 & p,
                    M = w === (f && 1 & a)
                  if (
                    (a < p && (w = !w),
                    (v = w ? 0 : y),
                    (this._lock = 1),
                    (this.render(v || (g ? 0 : st(a * l)), e, !y)._lock = 0),
                    (this._tTime = x),
                    !e && this.parent && te(this, 'onRepeat'),
                    this.vars.repeatRefresh &&
                      !g &&
                      (this.invalidate()._lock = 1),
                    (v && v !== this._time) ||
                      c !== !this._ts ||
                      (this.vars.onRepeat && !this.parent && !this._act))
                  )
                    return this
                  if (
                    ((y = this._dur),
                    (_ = this._tDur),
                    M &&
                      ((this._lock = 2),
                      (v = w ? y : -1e-4),
                      this.render(v, !0),
                      this.vars.repeatRefresh && !g && this.invalidate()),
                    (this._lock = 0),
                    !this._ts && !c)
                  )
                    return this
                  ye(this, g)
                }
              }
              if (
                (this._hasPause &&
                  !this._forcing &&
                  this._lock < 2 &&
                  ((u = (function (t, e, n) {
                    var i
                    if (n > e)
                      for (i = t._first; i && i._start <= n; ) {
                        if ('isPause' === i.data && i._start > e) return i
                        i = i._next
                      }
                    else
                      for (i = t._last; i && i._start >= n; ) {
                        if ('isPause' === i.data && i._start < e) return i
                        i = i._prev
                      }
                  })(this, st(v), st(i))),
                  u && (x -= i - (i = u._start))),
                (this._tTime = x),
                (this._time = i),
                (this._act = !h),
                this._initted ||
                  ((this._onUpdate = this.vars.onUpdate),
                  (this._initted = 1),
                  (this._zTime = t),
                  (v = 0)),
                !v && i && !e && (te(this, 'onStart'), this._tTime !== x))
              )
                return this
              if (i >= v && t >= 0)
                for (s = this._first; s; ) {
                  if (
                    ((o = s._next),
                    (s._act || i >= s._start) && s._ts && u !== s)
                  ) {
                    if (s.parent !== this) return this.render(t, e, n)
                    if (
                      (s.render(
                        s._ts > 0
                          ? (i - s._start) * s._ts
                          : (s._dirty ? s.totalDuration() : s._tDur) +
                              (i - s._start) * s._ts,
                        e,
                        n,
                      ),
                      i !== this._time || (!this._ts && !c))
                    ) {
                      ;(u = 0), o && (x += this._zTime = -1e-8)
                      break
                    }
                  }
                  s = o
                }
              else {
                s = this._last
                for (var S = t < 0 ? t : i; s; ) {
                  if (
                    ((o = s._prev), (s._act || S <= s._end) && s._ts && u !== s)
                  ) {
                    if (s.parent !== this) return this.render(t, e, n)
                    if (
                      (s.render(
                        s._ts > 0
                          ? (S - s._start) * s._ts
                          : (s._dirty ? s.totalDuration() : s._tDur) +
                              (S - s._start) * s._ts,
                        e,
                        n,
                      ),
                      i !== this._time || (!this._ts && !c))
                    ) {
                      ;(u = 0), o && (x += this._zTime = S ? -1e-8 : m)
                      break
                    }
                  }
                  s = o
                }
              }
              if (
                u &&
                !e &&
                (this.pause(),
                (u.render(i >= v ? 0 : -1e-8)._zTime = i >= v ? 1 : -1),
                this._ts)
              )
                return (this._start = d), Et(this), this.render(t, e, n)
              this._onUpdate && !e && te(this, 'onUpdate', !0),
                ((x === _ && this._tTime >= this.totalDuration()) ||
                  (!x && v)) &&
                  ((d !== this._start && Math.abs(h) === Math.abs(this._ts)) ||
                    this._lock ||
                    ((t || !y) &&
                      ((x === _ && this._ts > 0) || (!x && this._ts < 0)) &&
                      yt(this, 1),
                    e ||
                      (t < 0 && !v) ||
                      (!x && !v && _) ||
                      (te(
                        this,
                        x === _ && t >= 0 ? 'onComplete' : 'onReverseComplete',
                        !0,
                      ),
                      this._prom &&
                        !(x < _ && this.timeScale() > 0) &&
                        this._prom())))
            }
            return this
          }),
          (s.add = function (t, e) {
            var n = this
            if ((S(e) || (e = kt(this, e, t)), !(t instanceof Ee))) {
              if (R(t))
                return (
                  t.forEach(function (t) {
                    return n.add(t, e)
                  }),
                  this
                )
              if (w(t)) return this.addLabel(t, e)
              if (!M(t)) return this
              t = Be.delayedCall(0, t)
            }
            return this !== t ? Ct(this, t, e) : this
          }),
          (s.getChildren = function (t, e, n, i) {
            void 0 === t && (t = !0),
              void 0 === e && (e = !0),
              void 0 === n && (n = !0),
              void 0 === i && (i = -f)
            for (var r = [], s = this._first; s; )
              s._start >= i &&
                (s instanceof Be
                  ? e && r.push(s)
                  : (n && r.push(s),
                    t && r.push.apply(r, s.getChildren(!0, e, n)))),
                (s = s._next)
            return r
          }),
          (s.getById = function (t) {
            for (var e = this.getChildren(1, 1, 1), n = e.length; n--; )
              if (e[n].vars.id === t) return e[n]
          }),
          (s.remove = function (t) {
            return w(t)
              ? this.removeLabel(t)
              : M(t)
              ? this.killTweensOf(t)
              : (_t(this, t),
                t === this._recent && (this._recent = this._last),
                xt(this))
          }),
          (s.totalTime = function (t, e) {
            return arguments.length
              ? ((this._forcing = 1),
                !this._dp &&
                  this._ts &&
                  (this._start = st(
                    de.time -
                      (this._ts > 0
                        ? t / this._ts
                        : (this.totalDuration() - t) / -this._ts),
                  )),
                n.prototype.totalTime.call(this, t, e),
                (this._forcing = 0),
                this)
              : this._tTime
          }),
          (s.addLabel = function (t, e) {
            return (this.labels[t] = kt(this, e)), this
          }),
          (s.removeLabel = function (t) {
            return delete this.labels[t], this
          }),
          (s.addPause = function (t, e, n) {
            var i = Be.delayedCall(0, e || j, n)
            return (
              (i.data = 'isPause'),
              (this._hasPause = 1),
              Ct(this, i, kt(this, t))
            )
          }),
          (s.removePause = function (t) {
            var e = this._first
            for (t = kt(this, t); e; )
              e._start === t && 'isPause' === e.data && yt(e), (e = e._next)
          }),
          (s.killTweensOf = function (t, e, n) {
            for (var i = this.getTweensOf(t, n), r = i.length; r--; )
              Ae !== i[r] && i[r].kill(t, e)
            return this
          }),
          (s.getTweensOf = function (t, e) {
            for (var n, i = [], r = Wt(t), s = this._first, o = S(e); s; )
              s instanceof Be
                ? at(s._targets, r) &&
                  (o
                    ? (!Ae || (s._initted && s._ts)) &&
                      s.globalTime(0) <= e &&
                      s.globalTime(s.totalDuration()) > e
                    : !e || s.isActive()) &&
                  i.push(s)
                : (n = s.getTweensOf(r, e)).length && i.push.apply(i, n),
                (s = s._next)
            return i
          }),
          (s.tweenTo = function (t, e) {
            e = e || {}
            var n,
              i = this,
              r = kt(i, t),
              s = e,
              o = s.startAt,
              a = s.onStart,
              l = s.onStartParams,
              c = s.immediateRender,
              u = Be.to(
                i,
                dt(
                  {
                    ease: e.ease || 'none',
                    lazy: !1,
                    immediateRender: !1,
                    time: r,
                    overwrite: 'auto',
                    duration:
                      e.duration ||
                      Math.abs(
                        (r - (o && 'time' in o ? o.time : i._time)) /
                          i.timeScale(),
                      ) ||
                      m,
                    onStart: function () {
                      if ((i.pause(), !n)) {
                        var t =
                          e.duration ||
                          Math.abs(
                            (r - (o && 'time' in o ? o.time : i._time)) /
                              i.timeScale(),
                          )
                        u._dur !== t && It(u, t, 0, 1).render(u._time, !0, !0),
                          (n = 1)
                      }
                      a && a.apply(u, l || [])
                    },
                  },
                  e,
                ),
              )
            return c ? u.render(0) : u
          }),
          (s.tweenFromTo = function (t, e, n) {
            return this.tweenTo(e, dt({ startAt: { time: kt(this, t) } }, n))
          }),
          (s.recent = function () {
            return this._recent
          }),
          (s.nextLabel = function (t) {
            return void 0 === t && (t = this._time), $t(this, kt(this, t))
          }),
          (s.previousLabel = function (t) {
            return void 0 === t && (t = this._time), $t(this, kt(this, t), 1)
          }),
          (s.currentLabel = function (t) {
            return arguments.length
              ? this.seek(t, !0)
              : this.previousLabel(this._time + m)
          }),
          (s.shiftChildren = function (t, e, n) {
            void 0 === n && (n = 0)
            for (var i, r = this._first, s = this.labels; r; )
              r._start >= n && ((r._start += t), (r._end += t)), (r = r._next)
            if (e) for (i in s) s[i] >= n && (s[i] += t)
            return xt(this)
          }),
          (s.invalidate = function () {
            var t = this._first
            for (this._lock = 0; t; ) t.invalidate(), (t = t._next)
            return n.prototype.invalidate.call(this)
          }),
          (s.clear = function (t) {
            void 0 === t && (t = !0)
            for (var e, n = this._first; n; )
              (e = n._next), this.remove(n), (n = e)
            return (
              this._dp && (this._time = this._tTime = this._pTime = 0),
              t && (this.labels = {}),
              xt(this)
            )
          }),
          (s.totalDuration = function (t) {
            var e,
              n,
              i,
              s = 0,
              o = this,
              a = o._last,
              l = f
            if (arguments.length)
              return o.timeScale(
                (o._repeat < 0 ? o.duration() : o.totalDuration()) /
                  (o.reversed() ? -t : t),
              )
            if (o._dirty) {
              for (i = o.parent; a; )
                (e = a._prev),
                  a._dirty && a.totalDuration(),
                  (n = a._start) > l && o._sort && a._ts && !o._lock
                    ? ((o._lock = 1), (Ct(o, a, n - a._delay, 1)._lock = 0))
                    : (l = n),
                  n < 0 &&
                    a._ts &&
                    ((s -= n),
                    ((!i && !o._dp) || (i && i.smoothChildTiming)) &&
                      ((o._start += n / o._ts),
                      (o._time -= n),
                      (o._tTime -= n)),
                    o.shiftChildren(-n, !1, -Infinity),
                    (l = 0)),
                  a._end > s && a._ts && (s = a._end),
                  (a = e)
              It(o, o === r && o._time > s ? o._time : s, 1, 1), (o._dirty = 0)
            }
            return o._tDur
          }),
          (i.updateRoot = function (t) {
            if ((r._ts && (ct(r, Tt(t, r)), (c = de.frame)), de.frame >= K)) {
              K += d.autoSleep || 120
              var e = r._first
              if ((!e || !e._ts) && d.autoSleep && de._listeners.length < 2) {
                for (; e && !e._ts; ) e = e._next
                e || de.sleep()
              }
            }
          }),
          i
        )
      })(Ee)
      dt(De.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 })
      var Ae,
        Ce,
        Le = function (t, e, n, i, r, s, o) {
          var a,
            l,
            c,
            u,
            h,
            d,
            p,
            f,
            m = new Qe(this._pt, t, e, 0, 1, qe, null, r),
            g = 0,
            v = 0
          for (
            m.b = n,
              m.e = i,
              n += '',
              (p = ~(i += '').indexOf('random(')) && (i = Kt(i)),
              s && (s((f = [n, i]), t, e), (n = f[0]), (i = f[1])),
              l = n.match(O) || [];
            (a = O.exec(i));

          )
            (u = a[0]),
              (h = i.substring(g, a.index)),
              c ? (c = (c + 1) % 5) : 'rgba(' === h.substr(-5) && (c = 1),
              u !== l[v++] &&
                ((d = parseFloat(l[v - 1]) || 0),
                (m._pt = {
                  _next: m._pt,
                  p: h || 1 === v ? h : ',',
                  s: d,
                  c: '=' === u.charAt(1) ? ot(d, u) - d : parseFloat(u) - d,
                  m: c && c < 4 ? Math.round : 0,
                }),
                (g = O.lastIndex))
          return (
            (m.c = g < i.length ? i.substring(g, i.length) : ''),
            (m.fp = o),
            (N.test(i) || p) && (m.e = 0),
            (this._pt = m),
            m
          )
        },
        Re = function (t, e, n, i, r, s, o, a, l) {
          M(i) && (i = i(r || 0, t, s))
          var c,
            u = t[e],
            h =
              'get' !== n
                ? n
                : M(u)
                ? l
                  ? t[
                      e.indexOf('set') || !M(t['get' + e.substr(3)])
                        ? e
                        : 'get' + e.substr(3)
                    ](l)
                  : t[e]()
                : u,
            p = M(u) ? (l ? He : Ue) : ze
          if (
            (w(i) &&
              (~i.indexOf('random(') && (i = Kt(i)),
              '=' === i.charAt(1) &&
                ((c = ot(h, i) + (Ht(h) || 0)) || 0 === c) &&
                (i = c)),
            h !== i || Ce)
          )
            return isNaN(h * i) || '' === i
              ? (!u && !(e in t) && G(e, i),
                Le.call(this, t, e, h, i, p, a || d.stringFilter, l))
              : ((c = new Qe(
                  this._pt,
                  t,
                  e,
                  +h || 0,
                  i - (h || 0),
                  'boolean' == typeof u ? je : We,
                  0,
                  p,
                )),
                l && (c.fp = l),
                o && c.modifier(o, this, t),
                (this._pt = c))
        },
        Pe = function (t, e, n, i, r, s) {
          var o, a, l, c
          if (
            J[t] &&
            !1 !==
              (o = new J[t]()).init(
                r,
                o.rawVars
                  ? e[t]
                  : (function (t, e, n, i, r) {
                      if (
                        (M(t) && (t = Oe(t, r, e, n, i)),
                        !E(t) || (t.style && t.nodeType) || R(t) || L(t))
                      )
                        return w(t) ? Oe(t, r, e, n, i) : t
                      var s,
                        o = {}
                      for (s in t) o[s] = Oe(t[s], r, e, n, i)
                      return o
                    })(e[t], i, r, s, n),
                n,
                i,
                s,
              ) &&
            ((n._pt = a = new Qe(
              n._pt,
              r,
              t,
              0,
              1,
              o.render,
              o,
              0,
              o.priority,
            )),
            n !== u)
          )
            for (
              l = n._ptLookup[n._targets.indexOf(r)], c = o._props.length;
              c--;

            )
              l[o._props[c]] = a
          return o
        },
        Fe = function t(e, n) {
          var s,
            o,
            a,
            l,
            c,
            u,
            h,
            d,
            g,
            v,
            _,
            y,
            x,
            b = e.vars,
            w = b.ease,
            M = b.startAt,
            S = b.immediateRender,
            T = b.lazy,
            E = b.onUpdate,
            A = b.onUpdateParams,
            C = b.callbackScope,
            L = b.runBackwards,
            R = b.yoyoEase,
            P = b.keyframes,
            F = b.autoRevert,
            I = e._dur,
            O = e._startAt,
            N = e._targets,
            k = e.parent,
            B = k && 'nested' === k.data ? k.parent._targets : N,
            z = 'auto' === e._overwrite && !i,
            U = e.timeline
          if (
            (U && (!P || !w) && (w = 'none'),
            (e._ease = xe(w, p.ease)),
            (e._yEase = R ? _e(xe(!0 === R ? w : R, p.ease)) : 0),
            R &&
              e._yoyo &&
              !e._repeat &&
              ((R = e._yEase), (e._yEase = e._ease), (e._ease = R)),
            (e._from = !U && !!b.runBackwards),
            !U || (P && !b.stagger))
          ) {
            if (
              ((y = (d = N[0] ? et(N[0]).harness : 0) && b[d.prop]),
              (s = mt(b, q)),
              O && (yt(O.render(-1, !0)), (O._lazy = 0)),
              M)
            )
              if (
                (yt(
                  (e._startAt = Be.set(
                    N,
                    dt(
                      {
                        data: 'isStart',
                        overwrite: !1,
                        parent: k,
                        immediateRender: !0,
                        lazy: D(T),
                        startAt: null,
                        delay: 0,
                        onUpdate: E,
                        onUpdateParams: A,
                        callbackScope: C,
                        stagger: 0,
                      },
                      M,
                    ),
                  )),
                ),
                n < 0 && !S && !F && e._startAt.render(-1, !0),
                S)
              ) {
                if ((n > 0 && !F && (e._startAt = 0), I && n <= 0))
                  return void (n && (e._zTime = n))
              } else !1 === F && (e._startAt = 0)
            else if (L && I)
              if (O) !F && (e._startAt = 0)
              else if (
                (n && (S = !1),
                (a = dt(
                  {
                    overwrite: !1,
                    data: 'isFromStart',
                    lazy: S && D(T),
                    immediateRender: S,
                    stagger: 0,
                    parent: k,
                  },
                  s,
                )),
                y && (a[d.prop] = y),
                yt((e._startAt = Be.set(N, a))),
                n < 0 && e._startAt.render(-1, !0),
                (e._zTime = n),
                S)
              ) {
                if (!n) return
              } else t(e._startAt, m)
            for (
              e._pt = e._ptCache = 0, T = (I && D(T)) || (T && !I), o = 0;
              o < N.length;
              o++
            ) {
              if (
                ((h = (c = N[o])._gsap || tt(N)[o]._gsap),
                (e._ptLookup[o] = v = {}),
                Y[h.id] && X.length && lt(),
                (_ = B === N ? o : B.indexOf(c)),
                d &&
                  !1 !== (g = new d()).init(c, y || s, e, _, B) &&
                  ((e._pt = l = new Qe(
                    e._pt,
                    c,
                    g.name,
                    0,
                    1,
                    g.render,
                    g,
                    0,
                    g.priority,
                  )),
                  g._props.forEach(function (t) {
                    v[t] = l
                  }),
                  g.priority && (u = 1)),
                !d || y)
              )
                for (a in s)
                  J[a] && (g = Pe(a, s, e, _, c, B))
                    ? g.priority && (u = 1)
                    : (v[a] = l = Re.call(
                        e,
                        c,
                        a,
                        'get',
                        s[a],
                        _,
                        B,
                        0,
                        b.stringFilter,
                      ))
              e._op && e._op[o] && e.kill(c, e._op[o]),
                z &&
                  e._pt &&
                  ((Ae = e),
                  r.killTweensOf(c, v, e.globalTime(n)),
                  (x = !e.parent),
                  (Ae = 0)),
                e._pt && T && (Y[h.id] = 1)
            }
            u && Ke(e), e._onInit && e._onInit(e)
          }
          ;(e._onUpdate = E),
            (e._initted = (!e._op || e._pt) && !x),
            P && n <= 0 && U.render(f, !0, !0)
        },
        Ie = function (t, e, n, i) {
          var r,
            s,
            o = e.ease || i || 'power1.inOut'
          if (R(e))
            (s = n[t] || (n[t] = [])),
              e.forEach(function (t, n) {
                return s.push({ t: (n / (e.length - 1)) * 100, v: t, e: o })
              })
          else
            for (r in e)
              (s = n[r] || (n[r] = [])),
                'ease' === r || s.push({ t: parseFloat(t), v: e[r], e: o })
        },
        Oe = function (t, e, n, i, r) {
          return M(t)
            ? t.call(e, n, i, r)
            : w(t) && ~t.indexOf('random(')
            ? Kt(t)
            : t
        },
        Ne = $ + 'repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert',
        ke = {}
      it(Ne + ',id,stagger,delay,duration,paused,scrollTrigger', function (t) {
        return (ke[t] = 1)
      })
      var Be = (function (n) {
        function s(e, s, o, a) {
          var l
          'number' == typeof s && ((o.duration = s), (s = o), (o = null))
          var c,
            u,
            h,
            p,
            f,
            m,
            g,
            v,
            _ = (l = n.call(this, a ? s : gt(s)) || this).vars,
            y = _.duration,
            x = _.delay,
            b = _.immediateRender,
            w = _.stagger,
            M = _.overwrite,
            T = _.keyframes,
            A = _.defaults,
            P = _.scrollTrigger,
            F = _.yoyoEase,
            I = s.parent || r,
            O = (R(e) || L(e) ? S(e[0]) : 'length' in s) ? [e] : Wt(e)
          if (
            ((l._targets = O.length
              ? tt(O)
              : V(
                  'GSAP target ' + e + ' not found. https://greensock.com',
                  !d.nullTargetWarn,
                ) || []),
            (l._ptLookup = []),
            (l._overwrite = M),
            T || w || C(y) || C(x))
          ) {
            if (
              ((s = l.vars),
              (c = l.timeline = new De({
                data: 'nested',
                defaults: A || {},
              })).kill(),
              (c.parent = c._dp = t(l)),
              (c._start = 0),
              w || C(y) || C(x))
            ) {
              if (((p = O.length), (g = w && qt(w)), E(w)))
                for (f in w) ~Ne.indexOf(f) && (v || (v = {}), (v[f] = w[f]))
              for (u = 0; u < p; u++)
                ((h = mt(s, ke)).stagger = 0),
                  F && (h.yoyoEase = F),
                  v && pt(h, v),
                  (m = O[u]),
                  (h.duration = +Oe(y, t(l), u, m, O)),
                  (h.delay = (+Oe(x, t(l), u, m, O) || 0) - l._delay),
                  !w &&
                    1 === p &&
                    h.delay &&
                    ((l._delay = x = h.delay), (l._start += x), (h.delay = 0)),
                  c.to(m, h, g ? g(u, m, O) : 0),
                  (c._ease = fe.none)
              c.duration() ? (y = x = 0) : (l.timeline = 0)
            } else if (T) {
              gt(dt(c.vars.defaults, { ease: 'none' })),
                (c._ease = xe(T.ease || s.ease || 'none'))
              var N,
                k,
                B,
                z = 0
              if (R(T))
                T.forEach(function (t) {
                  return c.to(O, t, '>')
                })
              else {
                for (f in ((h = {}), T))
                  'ease' === f || 'easeEach' === f || Ie(f, T[f], h, T.easeEach)
                for (f in h)
                  for (
                    N = h[f].sort(function (t, e) {
                      return t.t - e.t
                    }),
                      z = 0,
                      u = 0;
                    u < N.length;
                    u++
                  )
                    ((B = {
                      ease: (k = N[u]).e,
                      duration: ((k.t - (u ? N[u - 1].t : 0)) / 100) * y,
                    })[f] = k.v),
                      c.to(O, B, z),
                      (z += B.duration)
                c.duration() < y && c.to({}, { duration: y - c.duration() })
              }
            }
            y || l.duration((y = c.duration()))
          } else l.timeline = 0
          return (
            !0 !== M || i || ((Ae = t(l)), r.killTweensOf(O), (Ae = 0)),
            Ct(I, t(l), o),
            s.reversed && l.reverse(),
            s.paused && l.paused(!0),
            (b ||
              (!y &&
                !T &&
                l._start === st(I._time) &&
                D(b) &&
                wt(t(l)) &&
                'nested' !== I.data)) &&
              ((l._tTime = -1e-8), l.render(Math.max(0, -x))),
            P && Lt(t(l), P),
            l
          )
        }
        e(s, n)
        var o = s.prototype
        return (
          (o.render = function (t, e, n) {
            var i,
              r,
              s,
              o,
              a,
              l,
              c,
              u,
              h,
              d = this._time,
              p = this._tDur,
              f = this._dur,
              g = t > p - m && t >= 0 ? p : t < m ? 0 : t
            if (f) {
              if (
                g !== this._tTime ||
                !t ||
                n ||
                (!this._initted && this._tTime) ||
                (this._startAt && this._zTime < 0 != t < 0)
              ) {
                if (((i = g), (u = this.timeline), this._repeat)) {
                  if (((o = f + this._rDelay), this._repeat < -1 && t < 0))
                    return this.totalTime(100 * o + t, e, n)
                  if (
                    ((i = st(g % o)),
                    g === p
                      ? ((s = this._repeat), (i = f))
                      : ((s = ~~(g / o)) && s === g / o && ((i = f), s--),
                        i > f && (i = f)),
                    (l = this._yoyo && 1 & s) &&
                      ((h = this._yEase), (i = f - i)),
                    (a = St(this._tTime, o)),
                    i === d && !n && this._initted)
                  )
                    return (this._tTime = g), this
                  s !== a &&
                    (u && this._yEase && ye(u, l),
                    !this.vars.repeatRefresh ||
                      l ||
                      this._lock ||
                      ((this._lock = n = 1),
                      (this.render(st(o * s), !0).invalidate()._lock = 0)))
                }
                if (!this._initted) {
                  if (Rt(this, t < 0 ? t : i, n, e))
                    return (this._tTime = 0), this
                  if (d !== this._time) return this
                  if (f !== this._dur) return this.render(t, e, n)
                }
                if (
                  ((this._tTime = g),
                  (this._time = i),
                  !this._act && this._ts && ((this._act = 1), (this._lazy = 0)),
                  (this.ratio = c = (h || this._ease)(i / f)),
                  this._from && (this.ratio = c = 1 - c),
                  i && !d && !e && (te(this, 'onStart'), this._tTime !== g))
                )
                  return this
                for (r = this._pt; r; ) r.r(c, r.d), (r = r._next)
                ;(u &&
                  u.render(
                    t < 0
                      ? t
                      : !i && l
                      ? -1e-8
                      : u._dur * u._ease(i / this._dur),
                    e,
                    n,
                  )) ||
                  (this._startAt && (this._zTime = t)),
                  this._onUpdate &&
                    !e &&
                    (t < 0 && this._startAt && this._startAt.render(t, !0, n),
                    te(this, 'onUpdate')),
                  this._repeat &&
                    s !== a &&
                    this.vars.onRepeat &&
                    !e &&
                    this.parent &&
                    te(this, 'onRepeat'),
                  (g !== this._tDur && g) ||
                    this._tTime !== g ||
                    (t < 0 &&
                      this._startAt &&
                      !this._onUpdate &&
                      this._startAt.render(t, !0, !0),
                    (t || !f) &&
                      ((g === this._tDur && this._ts > 0) ||
                        (!g && this._ts < 0)) &&
                      yt(this, 1),
                    e ||
                      (t < 0 && !d) ||
                      (!g && !d) ||
                      (te(
                        this,
                        g === p ? 'onComplete' : 'onReverseComplete',
                        !0,
                      ),
                      this._prom &&
                        !(g < p && this.timeScale() > 0) &&
                        this._prom()))
              }
            } else
              !(function (t, e, n, i) {
                var r,
                  s,
                  o,
                  a = t.ratio,
                  l =
                    e < 0 ||
                    (!e &&
                      ((!t._start && Pt(t) && (t._initted || !Ft(t))) ||
                        ((t._ts < 0 || t._dp._ts < 0) && !Ft(t))))
                      ? 0
                      : 1,
                  c = t._rDelay,
                  u = 0
                if (
                  (c &&
                    t._repeat &&
                    ((u = Ut(0, t._tDur, e)),
                    (s = St(u, c)),
                    t._yoyo && 1 & s && (l = 1 - l),
                    s !== St(t._tTime, c) &&
                      ((a = 1 - l),
                      t.vars.repeatRefresh && t._initted && t.invalidate())),
                  l !== a || i || t._zTime === m || (!e && t._zTime))
                ) {
                  if (!t._initted && Rt(t, e, i, n)) return
                  for (
                    o = t._zTime,
                      t._zTime = e || (n ? m : 0),
                      n || (n = e && !o),
                      t.ratio = l,
                      t._from && (l = 1 - l),
                      t._time = 0,
                      t._tTime = u,
                      r = t._pt;
                    r;

                  )
                    r.r(l, r.d), (r = r._next)
                  t._startAt && e < 0 && t._startAt.render(e, !0, !0),
                    t._onUpdate && !n && te(t, 'onUpdate'),
                    u && t._repeat && !n && t.parent && te(t, 'onRepeat'),
                    (e >= t._tDur || e < 0) &&
                      t.ratio === l &&
                      (l && yt(t, 1),
                      n ||
                        (te(t, l ? 'onComplete' : 'onReverseComplete', !0),
                        t._prom && t._prom()))
                } else t._zTime || (t._zTime = e)
              })(this, t, e, n)
            return this
          }),
          (o.targets = function () {
            return this._targets
          }),
          (o.invalidate = function () {
            return (
              (this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0),
              (this._ptLookup = []),
              this.timeline && this.timeline.invalidate(),
              n.prototype.invalidate.call(this)
            )
          }),
          (o.resetTo = function (t, e, n, i) {
            h || de.wake(), this._ts || this.play()
            var r = Math.min(
              this._dur,
              (this._dp._time - this._start) * this._ts,
            )
            return (
              this._initted || Fe(this, r),
              (function (t, e, n, i, r, s, o) {
                var a,
                  l,
                  c,
                  u = ((t._pt && t._ptCache) || (t._ptCache = {}))[e]
                if (!u)
                  for (
                    u = t._ptCache[e] = [],
                      l = t._ptLookup,
                      c = t._targets.length;
                    c--;

                  ) {
                    if ((a = l[c][e]) && a.d && a.d._pt)
                      for (a = a.d._pt; a && a.p !== e; ) a = a._next
                    if (!a)
                      return (
                        (Ce = 1), (t.vars[e] = '+=0'), Fe(t, o), (Ce = 0), 1
                      )
                    u.push(a)
                  }
                for (c = u.length; c--; )
                  ((a = u[c]).s =
                    (!i && 0 !== i) || r ? a.s + (i || 0) + s * a.c : i),
                    (a.c = n - a.s),
                    a.e && (a.e = rt(n) + Ht(a.e)),
                    a.b && (a.b = a.s + Ht(a.b))
              })(this, t, e, n, i, this._ease(r / this._dur), r)
                ? this.resetTo(t, e, n, i)
                : (Dt(this, 0),
                  this.parent ||
                    vt(
                      this._dp,
                      this,
                      '_first',
                      '_last',
                      this._dp._sort ? '_start' : 0,
                    ),
                  this.render(0))
            )
          }),
          (o.kill = function (t, e) {
            if ((void 0 === e && (e = 'all'), !(t || (e && 'all' !== e))))
              return (this._lazy = this._pt = 0), this.parent ? ee(this) : this
            if (this.timeline) {
              var n = this.timeline.totalDuration()
              return (
                this.timeline.killTweensOf(t, e, Ae && !0 !== Ae.vars.overwrite)
                  ._first || ee(this),
                this.parent &&
                  n !== this.timeline.totalDuration() &&
                  It(this, (this._dur * this.timeline._tDur) / n, 0, 1),
                this
              )
            }
            var i,
              r,
              s,
              o,
              a,
              l,
              c,
              u = this._targets,
              h = t ? Wt(t) : u,
              d = this._ptLookup,
              p = this._pt
            if (
              (!e || 'all' === e) &&
              (function (t, e) {
                for (
                  var n = t.length, i = n === e.length;
                  i && n-- && t[n] === e[n];

                );
                return n < 0
              })(u, h)
            )
              return 'all' === e && (this._pt = 0), ee(this)
            for (
              i = this._op = this._op || [],
                'all' !== e &&
                  (w(e) &&
                    ((a = {}),
                    it(e, function (t) {
                      return (a[t] = 1)
                    }),
                    (e = a)),
                  (e = (function (t, e) {
                    var n,
                      i,
                      r,
                      s,
                      o = t[0] ? et(t[0]).harness : 0,
                      a = o && o.aliases
                    if (!a) return e
                    for (i in ((n = pt({}, e)), a))
                      if ((i in n))
                        for (r = (s = a[i].split(',')).length; r--; )
                          n[s[r]] = n[i]
                    return n
                  })(u, e))),
                c = u.length;
              c--;

            )
              if (~h.indexOf(u[c]))
                for (a in ((r = d[c]),
                'all' === e
                  ? ((i[c] = e), (o = r), (s = {}))
                  : ((s = i[c] = i[c] || {}), (o = e)),
                o))
                  (l = r && r[a]) &&
                    (('kill' in l.d && !0 !== l.d.kill(a)) ||
                      _t(this, l, '_pt'),
                    delete r[a]),
                    'all' !== s && (s[a] = 1)
            return this._initted && !this._pt && p && ee(this), this
          }),
          (s.to = function (t, e) {
            return new s(t, e, arguments[2])
          }),
          (s.from = function (t, e) {
            return Bt(1, arguments)
          }),
          (s.delayedCall = function (t, e, n, i) {
            return new s(e, 0, {
              immediateRender: !1,
              lazy: !1,
              overwrite: !1,
              delay: t,
              onComplete: e,
              onReverseComplete: e,
              onCompleteParams: n,
              onReverseCompleteParams: n,
              callbackScope: i,
            })
          }),
          (s.fromTo = function (t, e, n) {
            return Bt(2, arguments)
          }),
          (s.set = function (t, e) {
            return (
              (e.duration = 0), e.repeatDelay || (e.repeat = 0), new s(t, e)
            )
          }),
          (s.killTweensOf = function (t, e, n) {
            return r.killTweensOf(t, e, n)
          }),
          s
        )
      })(Ee)
      dt(Be.prototype, {
        _targets: [],
        _lazy: 0,
        _startAt: 0,
        _op: 0,
        _onInit: 0,
      }),
        it('staggerTo,staggerFrom,staggerFromTo', function (t) {
          Be[t] = function () {
            var e = new De(),
              n = Gt.call(arguments, 0)
            return (
              n.splice('staggerFromTo' === t ? 5 : 4, 0, 0), e[t].apply(e, n)
            )
          }
        })
      var ze = function (t, e, n) {
          return (t[e] = n)
        },
        Ue = function (t, e, n) {
          return t[e](n)
        },
        He = function (t, e, n, i) {
          return t[e](i.fp, n)
        },
        Ge = function (t, e, n) {
          return t.setAttribute(e, n)
        },
        Ve = function (t, e) {
          return M(t[e]) ? Ue : T(t[e]) && t.setAttribute ? Ge : ze
        },
        We = function (t, e) {
          return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e)
        },
        je = function (t, e) {
          return e.set(e.t, e.p, !!(e.s + e.c * t), e)
        },
        qe = function (t, e) {
          var n = e._pt,
            i = ''
          if (!t && e.b) i = e.b
          else if (1 === t && e.e) i = e.e
          else {
            for (; n; )
              (i =
                n.p +
                (n.m
                  ? n.m(n.s + n.c * t)
                  : Math.round(1e4 * (n.s + n.c * t)) / 1e4) +
                i),
                (n = n._next)
            i += e.c
          }
          e.set(e.t, e.p, i, e)
        },
        Xe = function (t, e) {
          for (var n = e._pt; n; ) n.r(t, n.d), (n = n._next)
        },
        Ye = function (t, e, n, i) {
          for (var r, s = this._pt; s; )
            (r = s._next), s.p === i && s.modifier(t, e, n), (s = r)
        },
        Je = function (t) {
          for (var e, n, i = this._pt; i; )
            (n = i._next),
              (i.p === t && !i.op) || i.op === t
                ? _t(this, i, '_pt')
                : i.dep || (e = 1),
              (i = n)
          return !e
        },
        Ze = function (t, e, n, i) {
          i.mSet(t, e, i.m.call(i.tween, n, i.mt), i)
        },
        Ke = function (t) {
          for (var e, n, i, r, s = t._pt; s; ) {
            for (e = s._next, n = i; n && n.pr > s.pr; ) n = n._next
            ;(s._prev = n ? n._prev : r) ? (s._prev._next = s) : (i = s),
              (s._next = n) ? (n._prev = s) : (r = s),
              (s = e)
          }
          t._pt = i
        },
        Qe = (function () {
          function t(t, e, n, i, r, s, o, a, l) {
            ;(this.t = e),
              (this.s = i),
              (this.c = r),
              (this.p = n),
              (this.r = s || We),
              (this.d = o || this),
              (this.set = a || ze),
              (this.pr = l || 0),
              (this._next = t),
              t && (t._prev = this)
          }
          return (
            (t.prototype.modifier = function (t, e, n) {
              ;(this.mSet = this.mSet || this.set),
                (this.set = Ze),
                (this.m = t),
                (this.mt = n),
                (this.tween = e)
            }),
            t
          )
        })()
      it(
        $ +
          'parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger',
        function (t) {
          return (q[t] = 1)
        },
      ),
        (z.TweenMax = z.TweenLite = Be),
        (z.TimelineLite = z.TimelineMax = De),
        (r = new De({
          sortChildren: !1,
          defaults: p,
          autoRemoveChildren: !0,
          id: 'root',
          smoothChildTiming: !0,
        })),
        (d.stringFilter = he)
      var $e = {
        registerPlugin: function () {
          for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
            e[n] = arguments[n]
          e.forEach(function (t) {
            return ne(t)
          })
        },
        timeline: function (t) {
          return new De(t)
        },
        getTweensOf: function (t, e) {
          return r.getTweensOf(t, e)
        },
        getProperty: function (t, e, n, i) {
          w(t) && (t = Wt(t)[0])
          var r = et(t || {}).get,
            s = n ? ht : ut
          return (
            'native' === n && (n = ''),
            t
              ? e
                ? s(((J[e] && J[e].get) || r)(t, e, n, i))
                : function (e, n, i) {
                    return s(((J[e] && J[e].get) || r)(t, e, n, i))
                  }
              : t
          )
        },
        quickSetter: function (t, e, n) {
          if ((t = Wt(t)).length > 1) {
            var i = t.map(function (t) {
                return nn.quickSetter(t, e, n)
              }),
              r = i.length
            return function (t) {
              for (var e = r; e--; ) i[e](t)
            }
          }
          t = t[0] || {}
          var s = J[e],
            o = et(t),
            a = (o.harness && (o.harness.aliases || {})[e]) || e,
            l = s
              ? function (e) {
                  var i = new s()
                  ;(u._pt = 0),
                    i.init(t, n ? e + n : e, u, 0, [t]),
                    i.render(1, i),
                    u._pt && Xe(1, u)
                }
              : o.set(t, a)
          return s
            ? l
            : function (e) {
                return l(t, a, n ? e + n : e, o, 1)
              }
        },
        quickTo: function (t, e, n) {
          var i,
            r = nn.to(
              t,
              pt((((i = {})[e] = '+=0.1'), (i.paused = !0), i), n || {}),
            ),
            s = function (t, n, i) {
              return r.resetTo(e, t, n, i)
            }
          return (s.tween = r), s
        },
        isTweening: function (t) {
          return r.getTweensOf(t, !0).length > 0
        },
        defaults: function (t) {
          return t && t.ease && (t.ease = xe(t.ease, p.ease)), ft(p, t || {})
        },
        config: function (t) {
          return ft(d, t || {})
        },
        registerEffect: function (t) {
          var e = t.name,
            n = t.effect,
            i = t.plugins,
            r = t.defaults,
            s = t.extendTimeline
          ;(i || '').split(',').forEach(function (t) {
            return (
              t && !J[t] && !z[t] && V(e + ' effect requires ' + t + ' plugin.')
            )
          }),
            (Z[e] = function (t, e, i) {
              return n(Wt(t), dt(e || {}, r), i)
            }),
            s &&
              (De.prototype[e] = function (t, n, i) {
                return this.add(Z[e](t, E(n) ? n : (i = n) && {}, this), i)
              })
        },
        registerEase: function (t, e) {
          fe[t] = xe(e)
        },
        parseEase: function (t, e) {
          return arguments.length ? xe(t, e) : fe
        },
        getById: function (t) {
          return r.getById(t)
        },
        exportRoot: function (t, e) {
          void 0 === t && (t = {})
          var n,
            i,
            s = new De(t)
          for (
            s.smoothChildTiming = D(t.smoothChildTiming),
              r.remove(s),
              s._dp = 0,
              s._time = s._tTime = r._time,
              n = r._first;
            n;

          )
            (i = n._next),
              (!e &&
                !n._dur &&
                n instanceof Be &&
                n.vars.onComplete === n._targets[0]) ||
                Ct(s, n, n._start - n._delay),
              (n = i)
          return Ct(r, s, 0), s
        },
        utils: {
          wrap: function t(e, n, i) {
            var r = n - e
            return R(e)
              ? Zt(e, t(0, e.length), n)
              : zt(i, function (t) {
                  return ((r + ((t - e) % r)) % r) + e
                })
          },
          wrapYoyo: function t(e, n, i) {
            var r = n - e,
              s = 2 * r
            return R(e)
              ? Zt(e, t(0, e.length - 1), n)
              : zt(i, function (t) {
                  return (
                    e + ((t = (s + ((t - e) % s)) % s || 0) > r ? s - t : t)
                  )
                })
          },
          distribute: qt,
          random: Jt,
          snap: Yt,
          normalize: function (t, e, n) {
            return Qt(t, e, 0, 1, n)
          },
          getUnit: Ht,
          clamp: function (t, e, n) {
            return zt(n, function (n) {
              return Ut(t, e, n)
            })
          },
          splitColor: oe,
          toArray: Wt,
          selector: function (t) {
            return (
              (t = Wt(t)[0] || V('Invalid scope') || {}),
              function (e) {
                var n = t.current || t.nativeElement || t
                return Wt(
                  e,
                  n.querySelectorAll
                    ? n
                    : n === t
                    ? V('Invalid scope') || a.createElement('div')
                    : t,
                )
              }
            )
          },
          mapRange: Qt,
          pipe: function () {
            for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
              e[n] = arguments[n]
            return function (t) {
              return e.reduce(function (t, e) {
                return e(t)
              }, t)
            }
          },
          unitize: function (t, e) {
            return function (n) {
              return t(parseFloat(n)) + (e || Ht(n))
            }
          },
          interpolate: function t(e, n, i, r) {
            var s = isNaN(e + n)
              ? 0
              : function (t) {
                  return (1 - t) * e + t * n
                }
            if (!s) {
              var o,
                a,
                l,
                c,
                u,
                h = w(e),
                d = {}
              if ((!0 === i && (r = 1) && (i = null), h))
                (e = { p: e }), (n = { p: n })
              else if (R(e) && !R(n)) {
                for (l = [], c = e.length, u = c - 2, a = 1; a < c; a++)
                  l.push(t(e[a - 1], e[a]))
                c--,
                  (s = function (t) {
                    t *= c
                    var e = Math.min(u, ~~t)
                    return l[e](t - e)
                  }),
                  (i = n)
              } else r || (e = pt(R(e) ? [] : {}, e))
              if (!l) {
                for (o in n) Re.call(d, e, o, 'get', n[o])
                s = function (t) {
                  return Xe(t, d) || (h ? e.p : e)
                }
              }
            }
            return zt(i, s)
          },
          shuffle: jt,
        },
        install: H,
        effects: Z,
        ticker: de,
        updateRoot: De.updateRoot,
        plugins: J,
        globalTimeline: r,
        core: {
          PropTween: Qe,
          globals: W,
          Tween: Be,
          Timeline: De,
          Animation: Ee,
          getCache: et,
          _removeLinkedListItem: _t,
          suppressOverwrites: function (t) {
            return (i = t)
          },
        },
      }
      it('to,from,fromTo,delayedCall,set,killTweensOf', function (t) {
        return ($e[t] = Be[t])
      }),
        de.add(De.updateRoot),
        (u = $e.to({}, { duration: 0 }))
      var tn = function (t, e) {
          for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e; )
            n = n._next
          return n
        },
        en = function (t, e) {
          return {
            name: t,
            rawVars: 1,
            init: function (t, n, i) {
              i._onInit = function (t) {
                var i, r
                if (
                  (w(n) &&
                    ((i = {}),
                    it(n, function (t) {
                      return (i[t] = 1)
                    }),
                    (n = i)),
                  e)
                ) {
                  for (r in ((i = {}), n)) i[r] = e(n[r])
                  n = i
                }
                !(function (t, e) {
                  var n,
                    i,
                    r,
                    s = t._targets
                  for (n in e)
                    for (i = s.length; i--; )
                      (r = t._ptLookup[i][n]) &&
                        (r = r.d) &&
                        (r._pt && (r = tn(r, n)),
                        r && r.modifier && r.modifier(e[n], t, s[i], n))
                })(t, n)
              }
            },
          }
        },
        nn =
          $e.registerPlugin(
            {
              name: 'attr',
              init: function (t, e, n, i, r) {
                var s, o
                for (s in e)
                  (o = this.add(
                    t,
                    'setAttribute',
                    (t.getAttribute(s) || 0) + '',
                    e[s],
                    i,
                    r,
                    0,
                    0,
                    s,
                  )) && (o.op = s),
                    this._props.push(s)
              },
            },
            {
              name: 'endArray',
              init: function (t, e) {
                for (var n = e.length; n--; ) this.add(t, n, t[n] || 0, e[n])
              },
            },
            en('roundProps', Xt),
            en('modifiers'),
            en('snap', Yt),
          ) || $e
      ;(Be.version = De.version = nn.version = '3.10.2'),
        (l = 1),
        A() && pe(),
        fe.Power0,
        fe.Power1,
        fe.Power2,
        fe.Power3,
        fe.Power4,
        fe.Linear,
        fe.Quad,
        fe.Cubic,
        fe.Quart,
        fe.Quint,
        fe.Strong,
        fe.Elastic,
        fe.Back,
        fe.SteppedEase,
        fe.Bounce,
        fe.Sine,
        fe.Expo,
        fe.Circ
      var rn,
        sn,
        on,
        an,
        ln,
        cn,
        un,
        hn = {},
        dn = 180 / Math.PI,
        pn = Math.PI / 180,
        fn = Math.atan2,
        mn = /([A-Z])/g,
        gn = /(left|right|width|margin|padding|x)/i,
        vn = /[\s,\(]\S/,
        _n = {
          autoAlpha: 'opacity,visibility',
          scale: 'scaleX,scaleY',
          alpha: 'opacity',
        },
        yn = function (t, e) {
          return e.set(
            e.t,
            e.p,
            Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u,
            e,
          )
        },
        xn = function (t, e) {
          return e.set(
            e.t,
            e.p,
            1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u,
            e,
          )
        },
        bn = function (t, e) {
          return e.set(
            e.t,
            e.p,
            t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b,
            e,
          )
        },
        wn = function (t, e) {
          var n = e.s + e.c * t
          e.set(e.t, e.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + e.u, e)
        },
        Mn = function (t, e) {
          return e.set(e.t, e.p, t ? e.e : e.b, e)
        },
        Sn = function (t, e) {
          return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e)
        },
        Tn = function (t, e, n) {
          return (t.style[e] = n)
        },
        En = function (t, e, n) {
          return t.style.setProperty(e, n)
        },
        Dn = function (t, e, n) {
          return (t._gsap[e] = n)
        },
        An = function (t, e, n) {
          return (t._gsap.scaleX = t._gsap.scaleY = n)
        },
        Cn = function (t, e, n, i, r) {
          var s = t._gsap
          ;(s.scaleX = s.scaleY = n), s.renderTransform(r, s)
        },
        Ln = function (t, e, n, i, r) {
          var s = t._gsap
          ;(s[e] = n), s.renderTransform(r, s)
        },
        Rn = 'transform',
        Pn = Rn + 'Origin',
        Fn = function (t, e) {
          var n = sn.createElementNS
            ? sn.createElementNS(
                (e || 'http://www.w3.org/1999/xhtml').replace(/^https/, 'http'),
                t,
              )
            : sn.createElement(t)
          return n.style ? n : sn.createElement(t)
        },
        In = function t(e, n, i) {
          var r = getComputedStyle(e)
          return (
            r[n] ||
            r.getPropertyValue(n.replace(mn, '-$1').toLowerCase()) ||
            r.getPropertyValue(n) ||
            (!i && t(e, Nn(n) || n, 1)) ||
            ''
          )
        },
        On = 'O,Moz,ms,Ms,Webkit'.split(','),
        Nn = function (t, e, n) {
          var i = (e || ln).style,
            r = 5
          if (t in i && !n) return t
          for (
            t = t.charAt(0).toUpperCase() + t.substr(1);
            r-- && !(On[r] + t in i);

          );
          return r < 0 ? null : (3 === r ? 'ms' : r >= 0 ? On[r] : '') + t
        },
        kn = function () {
          'undefined' != typeof window &&
            window.document &&
            ((rn = window),
            (sn = rn.document),
            (on = sn.documentElement),
            (ln = Fn('div') || { style: {} }),
            Fn('div'),
            (Rn = Nn(Rn)),
            (Pn = Rn + 'Origin'),
            (ln.style.cssText =
              'border-width:0;line-height:0;position:absolute;padding:0'),
            (un = !!Nn('perspective')),
            (an = 1))
        },
        Bn = function t(e) {
          var n,
            i = Fn(
              'svg',
              (this.ownerSVGElement &&
                this.ownerSVGElement.getAttribute('xmlns')) ||
                'http://www.w3.org/2000/svg',
            ),
            r = this.parentNode,
            s = this.nextSibling,
            o = this.style.cssText
          if (
            (on.appendChild(i),
            i.appendChild(this),
            (this.style.display = 'block'),
            e)
          )
            try {
              ;(n = this.getBBox()),
                (this._gsapBBox = this.getBBox),
                (this.getBBox = t)
            } catch (t) {}
          else this._gsapBBox && (n = this._gsapBBox())
          return (
            r && (s ? r.insertBefore(this, s) : r.appendChild(this)),
            on.removeChild(i),
            (this.style.cssText = o),
            n
          )
        },
        zn = function (t, e) {
          for (var n = e.length; n--; )
            if (t.hasAttribute(e[n])) return t.getAttribute(e[n])
        },
        Un = function (t) {
          var e
          try {
            e = t.getBBox()
          } catch (n) {
            e = Bn.call(t, !0)
          }
          return (
            (e && (e.width || e.height)) ||
              t.getBBox === Bn ||
              (e = Bn.call(t, !0)),
            !e || e.width || e.x || e.y
              ? e
              : {
                  x: +zn(t, ['x', 'cx', 'x1']) || 0,
                  y: +zn(t, ['y', 'cy', 'y1']) || 0,
                  width: 0,
                  height: 0,
                }
          )
        },
        Hn = function (t) {
          return !(!t.getCTM || (t.parentNode && !t.ownerSVGElement) || !Un(t))
        },
        Gn = function (t, e) {
          if (e) {
            var n = t.style
            e in hn && e !== Pn && (e = Rn),
              n.removeProperty
                ? (('ms' !== e.substr(0, 2) && 'webkit' !== e.substr(0, 6)) ||
                    (e = '-' + e),
                  n.removeProperty(e.replace(mn, '-$1').toLowerCase()))
                : n.removeAttribute(e)
          }
        },
        Vn = function (t, e, n, i, r, s) {
          var o = new Qe(t._pt, e, n, 0, 1, s ? Sn : Mn)
          return (t._pt = o), (o.b = i), (o.e = r), t._props.push(n), o
        },
        Wn = { deg: 1, rad: 1, turn: 1 },
        jn = function t(e, n, i, r) {
          var s,
            o,
            a,
            l,
            c = parseFloat(i) || 0,
            u = (i + '').trim().substr((c + '').length) || 'px',
            h = ln.style,
            d = gn.test(n),
            p = 'svg' === e.tagName.toLowerCase(),
            f = (p ? 'client' : 'offset') + (d ? 'Width' : 'Height'),
            m = 100,
            g = 'px' === r,
            v = '%' === r
          return r === u || !c || Wn[r] || Wn[u]
            ? c
            : ('px' !== u && !g && (c = t(e, n, i, 'px')),
              (l = e.getCTM && Hn(e)),
              (!v && '%' !== u) || (!hn[n] && !~n.indexOf('adius'))
                ? ((h[d ? 'width' : 'height'] = m + (g ? u : r)),
                  (o =
                    ~n.indexOf('adius') || ('em' === r && e.appendChild && !p)
                      ? e
                      : e.parentNode),
                  l && (o = (e.ownerSVGElement || {}).parentNode),
                  (o && o !== sn && o.appendChild) || (o = sn.body),
                  (a = o._gsap) && v && a.width && d && a.time === de.time
                    ? rt((c / a.width) * m)
                    : ((v || '%' === u) && (h.position = In(e, 'position')),
                      o === e && (h.position = 'static'),
                      o.appendChild(ln),
                      (s = ln[f]),
                      o.removeChild(ln),
                      (h.position = 'absolute'),
                      d &&
                        v &&
                        (((a = et(o)).time = de.time), (a.width = o[f])),
                      rt(g ? (s * c) / m : s && c ? (m / s) * c : 0)))
                : ((s = l ? e.getBBox()[d ? 'width' : 'height'] : e[f]),
                  rt(v ? (c / s) * m : (c / 100) * s)))
        },
        qn = function (t, e, n, i) {
          var r
          return (
            an || kn(),
            e in _n &&
              'transform' !== e &&
              ~(e = _n[e]).indexOf(',') &&
              (e = e.split(',')[0]),
            hn[e] && 'transform' !== e
              ? ((r = ii(t, i)),
                (r =
                  'transformOrigin' !== e
                    ? r[e]
                    : r.svg
                    ? r.origin
                    : ri(In(t, Pn)) + ' ' + r.zOrigin + 'px'))
              : (!(r = t.style[e]) ||
                  'auto' === r ||
                  i ||
                  ~(r + '').indexOf('calc(')) &&
                (r =
                  (Zn[e] && Zn[e](t, e, n)) ||
                  In(t, e) ||
                  nt(t, e) ||
                  ('opacity' === e ? 1 : 0)),
            n && !~(r + '').trim().indexOf(' ') ? jn(t, e, r, n) + n : r
          )
        },
        Xn = function (t, e, n, i) {
          if (!n || 'none' === n) {
            var r = Nn(e, t, 1),
              s = r && In(t, r, 1)
            s && s !== n
              ? ((e = r), (n = s))
              : 'borderColor' === e && (n = In(t, 'borderTopColor'))
          }
          var o,
            a,
            l,
            c,
            u,
            h,
            p,
            f,
            m,
            g,
            v,
            _ = new Qe(this._pt, t.style, e, 0, 1, qe),
            y = 0,
            x = 0
          if (
            ((_.b = n),
            (_.e = i),
            (n += ''),
            'auto' == (i += '') &&
              ((t.style[e] = i), (i = In(t, e) || i), (t.style[e] = n)),
            he((o = [n, i])),
            (i = o[1]),
            (l = (n = o[0]).match(I) || []),
            (i.match(I) || []).length)
          ) {
            for (; (a = I.exec(i)); )
              (p = a[0]),
                (m = i.substring(y, a.index)),
                u
                  ? (u = (u + 1) % 5)
                  : ('rgba(' !== m.substr(-5) && 'hsla(' !== m.substr(-5)) ||
                    (u = 1),
                p !== (h = l[x++] || '') &&
                  ((c = parseFloat(h) || 0),
                  (v = h.substr((c + '').length)),
                  '=' === p.charAt(1) && (p = ot(c, p) + v),
                  (f = parseFloat(p)),
                  (g = p.substr((f + '').length)),
                  (y = I.lastIndex - g.length),
                  g ||
                    ((g = g || d.units[e] || v),
                    y === i.length && ((i += g), (_.e += g))),
                  v !== g && (c = jn(t, e, h, g) || 0),
                  (_._pt = {
                    _next: _._pt,
                    p: m || 1 === x ? m : ',',
                    s: c,
                    c: f - c,
                    m: (u && u < 4) || 'zIndex' === e ? Math.round : 0,
                  }))
            _.c = y < i.length ? i.substring(y, i.length) : ''
          } else _.r = 'display' === e && 'none' === i ? Sn : Mn
          return N.test(i) && (_.e = 0), (this._pt = _), _
        },
        Yn = {
          top: '0%',
          bottom: '100%',
          left: '0%',
          right: '100%',
          center: '50%',
        },
        Jn = function (t, e) {
          if (e.tween && e.tween._time === e.tween._dur) {
            var n,
              i,
              r,
              s = e.t,
              o = s.style,
              a = e.u,
              l = s._gsap
            if ('all' === a || !0 === a) (o.cssText = ''), (i = 1)
            else
              for (r = (a = a.split(',')).length; --r > -1; )
                (n = a[r]),
                  hn[n] && ((i = 1), (n = 'transformOrigin' === n ? Pn : Rn)),
                  Gn(s, n)
            i &&
              (Gn(s, Rn),
              l &&
                (l.svg && s.removeAttribute('transform'),
                ii(s, 1),
                (l.uncache = 1)))
          }
        },
        Zn = {
          clearProps: function (t, e, n, i, r) {
            if ('isFromStart' !== r.data) {
              var s = (t._pt = new Qe(t._pt, e, n, 0, 0, Jn))
              return (s.u = i), (s.pr = -10), (s.tween = r), t._props.push(n), 1
            }
          },
        },
        Kn = [1, 0, 0, 1, 0, 0],
        Qn = {},
        $n = function (t) {
          return 'matrix(1, 0, 0, 1, 0, 0)' === t || 'none' === t || !t
        },
        ti = function (t) {
          var e = In(t, Rn)
          return $n(e) ? Kn : e.substr(7).match(F).map(rt)
        },
        ei = function (t, e) {
          var n,
            i,
            r,
            s,
            o = t._gsap || et(t),
            a = t.style,
            l = ti(t)
          return o.svg && t.getAttribute('transform')
            ? '1,0,0,1,0,0' ===
              (l = [
                (r = t.transform.baseVal.consolidate().matrix).a,
                r.b,
                r.c,
                r.d,
                r.e,
                r.f,
              ]).join(',')
              ? Kn
              : l
            : (l !== Kn ||
                t.offsetParent ||
                t === on ||
                o.svg ||
                ((r = a.display),
                (a.display = 'block'),
                ((n = t.parentNode) && t.offsetParent) ||
                  ((s = 1), (i = t.nextSibling), on.appendChild(t)),
                (l = ti(t)),
                r ? (a.display = r) : Gn(t, 'display'),
                s &&
                  (i
                    ? n.insertBefore(t, i)
                    : n
                    ? n.appendChild(t)
                    : on.removeChild(t))),
              e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
        },
        ni = function (t, e, n, i, r, s) {
          var o,
            a,
            l,
            c = t._gsap,
            u = r || ei(t, !0),
            h = c.xOrigin || 0,
            d = c.yOrigin || 0,
            p = c.xOffset || 0,
            f = c.yOffset || 0,
            m = u[0],
            g = u[1],
            v = u[2],
            _ = u[3],
            y = u[4],
            x = u[5],
            b = e.split(' '),
            w = parseFloat(b[0]) || 0,
            M = parseFloat(b[1]) || 0
          n
            ? u !== Kn &&
              (a = m * _ - g * v) &&
              ((l = w * (-g / a) + M * (m / a) - (m * x - g * y) / a),
              (w = w * (_ / a) + M * (-v / a) + (v * x - _ * y) / a),
              (M = l))
            : ((w =
                (o = Un(t)).x + (~b[0].indexOf('%') ? (w / 100) * o.width : w)),
              (M =
                o.y +
                (~(b[1] || b[0]).indexOf('%') ? (M / 100) * o.height : M))),
            i || (!1 !== i && c.smooth)
              ? ((y = w - h),
                (x = M - d),
                (c.xOffset = p + (y * m + x * v) - y),
                (c.yOffset = f + (y * g + x * _) - x))
              : (c.xOffset = c.yOffset = 0),
            (c.xOrigin = w),
            (c.yOrigin = M),
            (c.smooth = !!i),
            (c.origin = e),
            (c.originIsAbsolute = !!n),
            (t.style[Pn] = '0px 0px'),
            s &&
              (Vn(s, c, 'xOrigin', h, w),
              Vn(s, c, 'yOrigin', d, M),
              Vn(s, c, 'xOffset', p, c.xOffset),
              Vn(s, c, 'yOffset', f, c.yOffset)),
            t.setAttribute('data-svg-origin', w + ' ' + M)
        },
        ii = function (t, e) {
          var n = t._gsap || new Te(t)
          if ('x' in n && !e && !n.uncache) return n
          var i,
            r,
            s,
            o,
            a,
            l,
            c,
            u,
            h,
            p,
            f,
            m,
            g,
            v,
            _,
            y,
            x,
            b,
            w,
            M,
            S,
            T,
            E,
            D,
            A,
            C,
            L,
            R,
            P,
            F,
            I,
            O,
            N = t.style,
            k = n.scaleX < 0,
            B = 'px',
            z = 'deg',
            U = In(t, Pn) || '0'
          return (
            (i = r = s = l = c = u = h = p = f = 0),
            (o = a = 1),
            (n.svg = !(!t.getCTM || !Hn(t))),
            (v = ei(t, n.svg)),
            n.svg &&
              ((D =
                (!n.uncache || '0px 0px' === U) &&
                !e &&
                t.getAttribute('data-svg-origin')),
              ni(t, D || U, !!D || n.originIsAbsolute, !1 !== n.smooth, v)),
            (m = n.xOrigin || 0),
            (g = n.yOrigin || 0),
            v !== Kn &&
              ((b = v[0]),
              (w = v[1]),
              (M = v[2]),
              (S = v[3]),
              (i = T = v[4]),
              (r = E = v[5]),
              6 === v.length
                ? ((o = Math.sqrt(b * b + w * w)),
                  (a = Math.sqrt(S * S + M * M)),
                  (l = b || w ? fn(w, b) * dn : 0),
                  (h = M || S ? fn(M, S) * dn + l : 0) &&
                    (a *= Math.abs(Math.cos(h * pn))),
                  n.svg &&
                    ((i -= m - (m * b + g * M)), (r -= g - (m * w + g * S))))
                : ((O = v[6]),
                  (F = v[7]),
                  (L = v[8]),
                  (R = v[9]),
                  (P = v[10]),
                  (I = v[11]),
                  (i = v[12]),
                  (r = v[13]),
                  (s = v[14]),
                  (c = (_ = fn(O, P)) * dn),
                  _ &&
                    ((D = T * (y = Math.cos(-_)) + L * (x = Math.sin(-_))),
                    (A = E * y + R * x),
                    (C = O * y + P * x),
                    (L = T * -x + L * y),
                    (R = E * -x + R * y),
                    (P = O * -x + P * y),
                    (I = F * -x + I * y),
                    (T = D),
                    (E = A),
                    (O = C)),
                  (u = (_ = fn(-M, P)) * dn),
                  _ &&
                    ((y = Math.cos(-_)),
                    (I = S * (x = Math.sin(-_)) + I * y),
                    (b = D = b * y - L * x),
                    (w = A = w * y - R * x),
                    (M = C = M * y - P * x)),
                  (l = (_ = fn(w, b)) * dn),
                  _ &&
                    ((D = b * (y = Math.cos(_)) + w * (x = Math.sin(_))),
                    (A = T * y + E * x),
                    (w = w * y - b * x),
                    (E = E * y - T * x),
                    (b = D),
                    (T = A)),
                  c &&
                    Math.abs(c) + Math.abs(l) > 359.9 &&
                    ((c = l = 0), (u = 180 - u)),
                  (o = rt(Math.sqrt(b * b + w * w + M * M))),
                  (a = rt(Math.sqrt(E * E + O * O))),
                  (_ = fn(T, E)),
                  (h = Math.abs(_) > 2e-4 ? _ * dn : 0),
                  (f = I ? 1 / (I < 0 ? -I : I) : 0)),
              n.svg &&
                ((D = t.getAttribute('transform')),
                (n.forceCSS =
                  t.setAttribute('transform', '') || !$n(In(t, Rn))),
                D && t.setAttribute('transform', D))),
            Math.abs(h) > 90 &&
              Math.abs(h) < 270 &&
              (k
                ? ((o *= -1),
                  (h += l <= 0 ? 180 : -180),
                  (l += l <= 0 ? 180 : -180))
                : ((a *= -1), (h += h <= 0 ? 180 : -180))),
            (e = e || n.uncache),
            (n.x =
              i -
              ((n.xPercent =
                i &&
                ((!e && n.xPercent) ||
                  (Math.round(t.offsetWidth / 2) === Math.round(-i) ? -50 : 0)))
                ? (t.offsetWidth * n.xPercent) / 100
                : 0) +
              B),
            (n.y =
              r -
              ((n.yPercent =
                r &&
                ((!e && n.yPercent) ||
                  (Math.round(t.offsetHeight / 2) === Math.round(-r)
                    ? -50
                    : 0)))
                ? (t.offsetHeight * n.yPercent) / 100
                : 0) +
              B),
            (n.z = s + B),
            (n.scaleX = rt(o)),
            (n.scaleY = rt(a)),
            (n.rotation = rt(l) + z),
            (n.rotationX = rt(c) + z),
            (n.rotationY = rt(u) + z),
            (n.skewX = h + z),
            (n.skewY = p + z),
            (n.transformPerspective = f + B),
            (n.zOrigin = parseFloat(U.split(' ')[2]) || 0) && (N[Pn] = ri(U)),
            (n.xOffset = n.yOffset = 0),
            (n.force3D = d.force3D),
            (n.renderTransform = n.svg ? hi : un ? ui : oi),
            (n.uncache = 0),
            n
          )
        },
        ri = function (t) {
          return (t = t.split(' '))[0] + ' ' + t[1]
        },
        si = function (t, e, n) {
          var i = Ht(e)
          return rt(parseFloat(e) + parseFloat(jn(t, 'x', n + 'px', i))) + i
        },
        oi = function (t, e) {
          ;(e.z = '0px'),
            (e.rotationY = e.rotationX = '0deg'),
            (e.force3D = 0),
            ui(t, e)
        },
        ai = '0deg',
        li = '0px',
        ci = ') ',
        ui = function (t, e) {
          var n = e || this,
            i = n.xPercent,
            r = n.yPercent,
            s = n.x,
            o = n.y,
            a = n.z,
            l = n.rotation,
            c = n.rotationY,
            u = n.rotationX,
            h = n.skewX,
            d = n.skewY,
            p = n.scaleX,
            f = n.scaleY,
            m = n.transformPerspective,
            g = n.force3D,
            v = n.target,
            _ = n.zOrigin,
            y = '',
            x = ('auto' === g && t && 1 !== t) || !0 === g
          if (_ && (u !== ai || c !== ai)) {
            var b,
              w = parseFloat(c) * pn,
              M = Math.sin(w),
              S = Math.cos(w)
            ;(w = parseFloat(u) * pn),
              (b = Math.cos(w)),
              (s = si(v, s, M * b * -_)),
              (o = si(v, o, -Math.sin(w) * -_)),
              (a = si(v, a, S * b * -_ + _))
          }
          m !== li && (y += 'perspective(' + m + ci),
            (i || r) && (y += 'translate(' + i + '%, ' + r + '%) '),
            (x || s !== li || o !== li || a !== li) &&
              (y +=
                a !== li || x
                  ? 'translate3d(' + s + ', ' + o + ', ' + a + ') '
                  : 'translate(' + s + ', ' + o + ci),
            l !== ai && (y += 'rotate(' + l + ci),
            c !== ai && (y += 'rotateY(' + c + ci),
            u !== ai && (y += 'rotateX(' + u + ci),
            (h === ai && d === ai) || (y += 'skew(' + h + ', ' + d + ci),
            (1 === p && 1 === f) || (y += 'scale(' + p + ', ' + f + ci),
            (v.style[Rn] = y || 'translate(0, 0)')
        },
        hi = function (t, e) {
          var n,
            i,
            r,
            s,
            o,
            a = e || this,
            l = a.xPercent,
            c = a.yPercent,
            u = a.x,
            h = a.y,
            d = a.rotation,
            p = a.skewX,
            f = a.skewY,
            m = a.scaleX,
            g = a.scaleY,
            v = a.target,
            _ = a.xOrigin,
            y = a.yOrigin,
            x = a.xOffset,
            b = a.yOffset,
            w = a.forceCSS,
            M = parseFloat(u),
            S = parseFloat(h)
          ;(d = parseFloat(d)),
            (p = parseFloat(p)),
            (f = parseFloat(f)) && ((p += f = parseFloat(f)), (d += f)),
            d || p
              ? ((d *= pn),
                (p *= pn),
                (n = Math.cos(d) * m),
                (i = Math.sin(d) * m),
                (r = Math.sin(d - p) * -g),
                (s = Math.cos(d - p) * g),
                p &&
                  ((f *= pn),
                  (o = Math.tan(p - f)),
                  (r *= o = Math.sqrt(1 + o * o)),
                  (s *= o),
                  f &&
                    ((o = Math.tan(f)),
                    (n *= o = Math.sqrt(1 + o * o)),
                    (i *= o))),
                (n = rt(n)),
                (i = rt(i)),
                (r = rt(r)),
                (s = rt(s)))
              : ((n = m), (s = g), (i = r = 0)),
            ((M && !~(u + '').indexOf('px')) ||
              (S && !~(h + '').indexOf('px'))) &&
              ((M = jn(v, 'x', u, 'px')), (S = jn(v, 'y', h, 'px'))),
            (_ || y || x || b) &&
              ((M = rt(M + _ - (_ * n + y * r) + x)),
              (S = rt(S + y - (_ * i + y * s) + b))),
            (l || c) &&
              ((o = v.getBBox()),
              (M = rt(M + (l / 100) * o.width)),
              (S = rt(S + (c / 100) * o.height))),
            (o =
              'matrix(' +
              n +
              ',' +
              i +
              ',' +
              r +
              ',' +
              s +
              ',' +
              M +
              ',' +
              S +
              ')'),
            v.setAttribute('transform', o),
            w && (v.style[Rn] = o)
        },
        di = function (t, e, n, i, r) {
          var s,
            o,
            a = 360,
            l = w(r),
            c = parseFloat(r) * (l && ~r.indexOf('rad') ? dn : 1) - i,
            u = i + c + 'deg'
          return (
            l &&
              ('short' === (s = r.split('_')[1]) &&
                (c %= a) != c % 180 &&
                (c += c < 0 ? a : -360),
              'cw' === s && c < 0
                ? (c = ((c + 36e9) % a) - ~~(c / a) * a)
                : 'ccw' === s &&
                  c > 0 &&
                  (c = ((c - 36e9) % a) - ~~(c / a) * a)),
            (t._pt = o = new Qe(t._pt, e, n, i, c, xn)),
            (o.e = u),
            (o.u = 'deg'),
            t._props.push(n),
            o
          )
        },
        pi = function (t, e) {
          for (var n in e) t[n] = e[n]
          return t
        },
        fi = function (t, e, n) {
          var i,
            r,
            s,
            o,
            a,
            l,
            c,
            u = pi({}, n._gsap),
            h = n.style
          for (r in (u.svg
            ? ((s = n.getAttribute('transform')),
              n.setAttribute('transform', ''),
              (h[Rn] = e),
              (i = ii(n, 1)),
              Gn(n, Rn),
              n.setAttribute('transform', s))
            : ((s = getComputedStyle(n)[Rn]),
              (h[Rn] = e),
              (i = ii(n, 1)),
              (h[Rn] = s)),
          hn))
            (s = u[r]) !== (o = i[r]) &&
              'perspective,force3D,transformOrigin,svgOrigin'.indexOf(r) < 0 &&
              ((a = Ht(s) !== (c = Ht(o)) ? jn(n, r, s, c) : parseFloat(s)),
              (l = parseFloat(o)),
              (t._pt = new Qe(t._pt, i, r, a, l - a, yn)),
              (t._pt.u = c || 0),
              t._props.push(r))
          pi(i, u)
        }
      it('padding,margin,Width,Radius', function (t, e) {
        var n = 'Top',
          i = 'Right',
          r = 'Bottom',
          s = 'Left',
          o = (e < 3 ? [n, i, r, s] : [n + s, n + i, r + i, r + s]).map(
            function (n) {
              return e < 2 ? t + n : 'border' + n + t
            },
          )
        Zn[e > 1 ? 'border' + t : t] = function (t, e, n, i, r) {
          var s, a
          if (arguments.length < 4)
            return (
              (s = o.map(function (e) {
                return qn(t, e, n)
              })),
              5 === (a = s.join(' ')).split(s[0]).length ? s[0] : a
            )
          ;(s = (i + '').split(' ')),
            (a = {}),
            o.forEach(function (t, e) {
              return (a[t] = s[e] = s[e] || s[((e - 1) / 2) | 0])
            }),
            t.init(e, a, r)
        }
      })
      var mi,
        gi,
        vi = {
          name: 'css',
          register: kn,
          targetTest: function (t) {
            return t.style && t.nodeType
          },
          init: function (t, e, n, i, r) {
            var s,
              o,
              a,
              l,
              c,
              u,
              h,
              p,
              f,
              m,
              g,
              v,
              _,
              y,
              x,
              b,
              M,
              S,
              T,
              E = this._props,
              D = t.style,
              A = n.vars.startAt
            for (h in (an || kn(), e))
              if (
                'autoRound' !== h &&
                ((o = e[h]), !J[h] || !Pe(h, e, n, i, t, r))
              )
                if (
                  ((c = typeof o),
                  (u = Zn[h]),
                  'function' === c && (c = typeof (o = o.call(n, i, t, r))),
                  'string' === c && ~o.indexOf('random(') && (o = Kt(o)),
                  u)
                )
                  u(this, t, h, o, n) && (x = 1)
                else if ('--' === h.substr(0, 2))
                  (s = (getComputedStyle(t).getPropertyValue(h) + '').trim()),
                    (o += ''),
                    (ce.lastIndex = 0),
                    ce.test(s) || ((p = Ht(s)), (f = Ht(o))),
                    f ? p !== f && (s = jn(t, h, s, f) + f) : p && (o += p),
                    this.add(D, 'setProperty', s, o, i, r, 0, 0, h),
                    E.push(h)
                else if ('undefined' !== c) {
                  if (
                    (A && h in A
                      ? ((s =
                          'function' == typeof A[h]
                            ? A[h].call(n, i, t, r)
                            : A[h]),
                        w(s) && ~s.indexOf('random(') && (s = Kt(s)),
                        Ht(s + '') || (s += d.units[h] || Ht(qn(t, h)) || ''),
                        '=' === (s + '').charAt(1) && (s = qn(t, h)))
                      : (s = qn(t, h)),
                    (l = parseFloat(s)),
                    (m =
                      'string' === c &&
                      '=' === o.charAt(1) &&
                      o.substr(0, 2)) && (o = o.substr(2)),
                    (a = parseFloat(o)),
                    h in _n &&
                      ('autoAlpha' === h &&
                        (1 === l &&
                          'hidden' === qn(t, 'visibility') &&
                          a &&
                          (l = 0),
                        Vn(
                          this,
                          D,
                          'visibility',
                          l ? 'inherit' : 'hidden',
                          a ? 'inherit' : 'hidden',
                          !a,
                        )),
                      'scale' !== h &&
                        'transform' !== h &&
                        ~(h = _n[h]).indexOf(',') &&
                        (h = h.split(',')[0])),
                    (g = h in hn))
                  )
                    if (
                      (v ||
                        (((_ = t._gsap).renderTransform && !e.parseTransform) ||
                          ii(t, e.parseTransform),
                        (y = !1 !== e.smoothOrigin && _.smooth),
                        ((v = this._pt = new Qe(
                          this._pt,
                          D,
                          Rn,
                          0,
                          1,
                          _.renderTransform,
                          _,
                          0,
                          -1,
                        )).dep = 1)),
                      'scale' === h)
                    )
                      (this._pt = new Qe(
                        this._pt,
                        _,
                        'scaleY',
                        _.scaleY,
                        (m ? ot(_.scaleY, m + a) : a) - _.scaleY || 0,
                      )),
                        E.push('scaleY', h),
                        (h += 'X')
                    else {
                      if ('transformOrigin' === h) {
                        ;(M = void 0),
                          (S = void 0),
                          (T = void 0),
                          (S = (M = (b = o).split(' '))[0]),
                          (T = M[1] || '50%'),
                          ('top' !== S &&
                            'bottom' !== S &&
                            'left' !== T &&
                            'right' !== T) ||
                            ((b = S), (S = T), (T = b)),
                          (M[0] = Yn[S] || S),
                          (M[1] = Yn[T] || T),
                          (o = M.join(' ')),
                          _.svg
                            ? ni(t, o, 0, y, 0, this)
                            : ((f = parseFloat(o.split(' ')[2]) || 0) !==
                                _.zOrigin &&
                                Vn(this, _, 'zOrigin', _.zOrigin, f),
                              Vn(this, D, h, ri(s), ri(o)))
                        continue
                      }
                      if ('svgOrigin' === h) {
                        ni(t, o, 1, y, 0, this)
                        continue
                      }
                      if (h in Qn) {
                        di(this, _, h, l, m ? ot(l, m + o) : o)
                        continue
                      }
                      if ('smoothOrigin' === h) {
                        Vn(this, _, 'smooth', _.smooth, o)
                        continue
                      }
                      if ('force3D' === h) {
                        _[h] = o
                        continue
                      }
                      if ('transform' === h) {
                        fi(this, o, t)
                        continue
                      }
                    }
                  else h in D || (h = Nn(h) || h)
                  if (
                    g ||
                    ((a || 0 === a) && (l || 0 === l) && !vn.test(o) && h in D)
                  )
                    a || (a = 0),
                      (p = (s + '').substr((l + '').length)) !==
                        (f = Ht(o) || (h in d.units ? d.units[h] : p)) &&
                        (l = jn(t, h, s, f)),
                      (this._pt = new Qe(
                        this._pt,
                        g ? _ : D,
                        h,
                        l,
                        (m ? ot(l, m + a) : a) - l,
                        g ||
                        ('px' !== f && 'zIndex' !== h) ||
                        !1 === e.autoRound
                          ? yn
                          : wn,
                      )),
                      (this._pt.u = f || 0),
                      p !== f &&
                        '%' !== f &&
                        ((this._pt.b = s), (this._pt.r = bn))
                  else if (h in D) Xn.call(this, t, h, s, m ? m + o : o)
                  else {
                    if (!(h in t)) {
                      G(h, o)
                      continue
                    }
                    this.add(t, h, s || t[h], m ? m + o : o, i, r)
                  }
                  E.push(h)
                }
            x && Ke(this)
          },
          get: qn,
          aliases: _n,
          getSetter: function (t, e, n) {
            var i = _n[e]
            return (
              i && i.indexOf(',') < 0 && (e = i),
              e in hn && e !== Pn && (t._gsap.x || qn(t, 'x'))
                ? n && cn === n
                  ? 'scale' === e
                    ? An
                    : Dn
                  : (cn = n || {}) && ('scale' === e ? Cn : Ln)
                : t.style && !T(t.style[e])
                ? Tn
                : ~e.indexOf('-')
                ? En
                : Ve(t, e)
            )
          },
          core: { _removeProperty: Gn, _getMatrix: ei },
        }
      ;(nn.utils.checkPrefix = Nn),
        (gi = it(
          'x,y,z,scale,scaleX,scaleY,xPercent,yPercent' +
            ',' +
            (mi = 'rotation,rotationX,rotationY,skewX,skewY') +
            ',transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective',
          function (t) {
            hn[t] = 1
          },
        )),
        it(mi, function (t) {
          ;(d.units[t] = 'deg'), (Qn[t] = 1)
        }),
        (_n[gi[13]] = 'x,y,z,scale,scaleX,scaleY,xPercent,yPercent,' + mi),
        it('0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY', function (t) {
          var e = t.split(':')
          _n[e[1]] = gi[e[0]]
        }),
        it('x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective', function (t) {
          d.units[t] = 'px'
        }),
        nn.registerPlugin(vi)
      var _i = nn.registerPlugin(vi) || nn
      function yi(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n]
          ;(i.enumerable = i.enumerable || !1),
            (i.configurable = !0),
            'value' in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i)
        }
      }
      _i.core.Tween
      var xi,
        bi,
        wi,
        Mi,
        Si,
        Ti,
        Ei,
        Di,
        Ai,
        Ci,
        Li,
        Ri = function () {
          return (
            xi ||
            ('undefined' != typeof window &&
              (xi = window.gsap) &&
              xi.registerPlugin &&
              xi)
          )
        },
        Pi = 1,
        Fi = [],
        Ii = [],
        Oi = [],
        Ni = Date.now,
        ki = function (t, e) {
          return e
        },
        Bi = function (t, e) {
          return ~Oi.indexOf(t) && Oi[Oi.indexOf(t) + 1][e]
        },
        zi = function (t) {
          return !!~Ci.indexOf(t)
        },
        Ui = function (t, e, n, i) {
          return t.addEventListener(e, n, { passive: !i })
        },
        Hi = function (t, e, n) {
          return t.removeEventListener(e, n)
        },
        Gi = function () {
          return (Li && Li.isPressed) || Ii.cache++
        },
        Vi = function (t) {
          return function (e) {
            return (
              e || 0 === e
                ? (Pi && (wi.history.scrollRestoration = 'manual'),
                  t(e),
                  (t.v = e),
                  (t.c = Ii.cache),
                  Li && Li.isPressed && ki('ss', e))
                : (Ii.cache !== t.c || ki('ref')) &&
                  ((t.c = Ii.cache), (t.v = t())),
              t.v
            )
          }
        },
        Wi = {
          s: 'scrollLeft',
          p: 'left',
          p2: 'Left',
          os: 'right',
          os2: 'Right',
          d: 'width',
          d2: 'Width',
          a: 'x',
          sc: Vi(function (t) {
            return arguments.length
              ? wi.scrollTo(t, ji.sc())
              : wi.pageXOffset ||
                  Mi.scrollLeft ||
                  Si.scrollLeft ||
                  Ti.scrollLeft ||
                  0
          }),
        },
        ji = {
          s: 'scrollTop',
          p: 'top',
          p2: 'Top',
          os: 'bottom',
          os2: 'Bottom',
          d: 'height',
          d2: 'Height',
          a: 'y',
          op: Wi,
          sc: Vi(function (t) {
            return arguments.length
              ? wi.scrollTo(Wi.sc(), t)
              : wi.pageYOffset ||
                  Mi.scrollTop ||
                  Si.scrollTop ||
                  Ti.scrollTop ||
                  0
          }),
        },
        qi = function (t) {
          return (
            xi.utils.toArray(t)[0] ||
            ('string' == typeof t && !1 !== xi.config().nullTargetWarn
              ? console.warn('Element not found:', t)
              : null)
          )
        },
        Xi = function (t, e) {
          var n = e.s,
            i = e.sc,
            r = Ii.indexOf(t),
            s = i === ji.sc ? 1 : 2
          return (
            !~r && (r = Ii.push(t) - 1),
            Ii[r + s] ||
              (Ii[r + s] =
                Bi(t, n) ||
                (zi(t)
                  ? i
                  : function (e) {
                      return arguments.length ? (t[n] = e) : t[n]
                    }))
          )
        },
        Yi = function (t, e, n) {
          var i = t,
            r = t,
            s = Ni(),
            o = s,
            a = e || 50,
            l = Math.max(500, 3 * a),
            c = function (t, e) {
              var l = Ni()
              e || l - s > a
                ? ((r = i), (i = t), (o = s), (s = l))
                : n
                ? (i += t)
                : (i = r + ((t - r) / (l - o)) * (s - o))
            }
          return {
            update: c,
            reset: function () {
              ;(r = i = n ? 0 : i), (o = s = 0)
            },
            getVelocity: function (t) {
              var e = o,
                a = r,
                u = Ni()
              return (
                (t || 0 === t) && t !== i && c(t),
                s === o || u - o > l
                  ? 0
                  : ((i + (n ? a : -a)) / ((n ? u : s) - e)) * 1e3
              )
            },
          }
        },
        Ji = function (t, e) {
          return (
            e && t.preventDefault(), t.changedTouches ? t.changedTouches[0] : t
          )
        },
        Zi = function (t) {
          var e = Math.max.apply(Math, t),
            n = Math.min.apply(Math, t)
          return Math.abs(e) >= Math.abs(n) ? e : n
        },
        Ki = function (t) {
          return (
            (xi = t || Ri()) &&
              !bi &&
              'undefined' != typeof document &&
              document.body &&
              ((wi = window),
              (Mi = document),
              (Si = Mi.documentElement),
              (Ti = Mi.body),
              (Ci = [wi, Mi, Si, Ti]),
              xi.utils.clamp,
              (Di = 'onpointerenter' in Ti ? 'pointer' : 'mouse'),
              (Ei = Qi.isTouch =
                wi.matchMedia &&
                wi.matchMedia('(hover: none), (pointer: coarse)').matches
                  ? 1
                  : 'ontouchstart' in wi ||
                    navigator.maxTouchPoints > 0 ||
                    navigator.msMaxTouchPoints > 0
                  ? 2
                  : 0),
              setTimeout(function () {
                return (Pi = 0)
              }, 500),
              (bi = 1)),
            bi
          )
        }
      ;(Wi.op = ji), (Ii.cache = 0)
      var Qi = (function () {
        function t(t) {
          this.init(t)
        }
        var e, n
        return (
          (t.prototype.init = function (t) {
            var e, n, i, r
            bi ||
              Ki(xi) ||
              console.warn('Please gsap.registerPlugin(Observer)'),
              Ai ||
                ((Ai = xi.core.globals().ScrollTrigger) &&
                  Ai.core &&
                  ((e = Ai.core),
                  (n = e.bridge || {}),
                  (i = e._scrollers),
                  (r = e._proxies),
                  i.push.apply(i, Ii),
                  r.push.apply(r, Oi),
                  (Ii = i),
                  (Oi = r),
                  (ki = function (t, e) {
                    return n[t](e)
                  })))
            var s = t.tolerance,
              o = t.dragMinimum,
              a = t.type,
              l = t.target,
              c = t.lineHeight,
              u = t.debounce,
              h = t.preventDefault,
              d = t.onStop,
              p = t.onStopDelay,
              f = t.ignore,
              m = t.wheelSpeed,
              g = t.event,
              v = t.onDragStart,
              _ = t.onDragEnd,
              y = t.onDrag,
              x = t.onPress,
              b = t.onRelease,
              w = t.onRight,
              M = t.onLeft,
              S = t.onUp,
              T = t.onDown,
              E = t.onChangeX,
              D = t.onChangeY,
              A = t.onChange,
              C = t.onToggleX,
              L = t.onToggleY,
              R = t.onHover,
              P = t.onHoverEnd,
              F = t.onMove,
              I = t.ignoreCheck,
              O = t.isNormalizer,
              N = t.onGestureStart,
              k = t.onGestureEnd,
              B = t.onWheel,
              z = t.onEnable,
              U = t.onDisable,
              H = t.onClick,
              G = t.scrollSpeed
            ;(this.target = l = qi(l) || Si),
              (this.vars = t),
              f && (f = xi.utils.toArray(f)),
              (s = s || 0),
              (o = o || 0),
              (m = m || 1),
              (G = G || 1),
              (a = a || 'wheel,touch,pointer'),
              (u = !1 !== u),
              c || (c = parseFloat(wi.getComputedStyle(Ti).lineHeight) || 22)
            var V,
              W,
              j,
              q,
              X,
              Y = this,
              J = 0,
              Z = 0,
              K = Xi(l, Wi),
              Q = Xi(l, ji),
              $ = K(),
              tt = Q(),
              et = ('ontouchstart' in Si
                ? 'touchstart,touchmove,touchcancel,touchend'
                : a.indexOf('pointer') >= 0 && !('onpointerdown' in Si)
                ? 'mousedown,mousemove,mouseup,mouseup'
                : 'pointerdown,pointermove,pointercancel,pointerup'
              ).split(','),
              nt =
                ~a.indexOf('touch') &&
                !~a.indexOf('pointer') &&
                'pointerdown' === et[0],
              it = zi(l),
              rt = l.ownerDocument || Mi,
              st = [0, 0, 0],
              ot = [0, 0, 0],
              at = function (t, e) {
                return (
                  ((Y.event = t) && f && ~f.indexOf(t.target)) ||
                  (e && nt && 'touch' !== t.pointerType) ||
                  (I && I(t))
                )
              },
              lt = function () {
                var t = (Y.deltaX = Zi(st)),
                  e = (Y.deltaY = Zi(ot)),
                  n = Math.abs(t) >= s,
                  i = Math.abs(e) >= s
                A && (n || i) && A(Y, t, e, st, ot),
                  n &&
                    (w && Y.deltaX > 0 && w(Y),
                    M && Y.deltaX < 0 && M(Y),
                    E && E(Y),
                    C && Y.deltaX < 0 != J < 0 && C(Y),
                    (J = Y.deltaX),
                    (st[0] = st[1] = st[2] = 0)),
                  i &&
                    (T && Y.deltaY > 0 && T(Y),
                    S && Y.deltaY < 0 && S(Y),
                    D && D(Y),
                    L && Y.deltaY < 0 != Z < 0 && L(Y),
                    (Z = Y.deltaY),
                    (ot[0] = ot[1] = ot[2] = 0)),
                  q && (F(Y), (q = !1)),
                  j && (y(Y), (j = !1)),
                  X && (B(Y), (X = !1)),
                  (V = 0)
              },
              ct = function (t, e, n) {
                ;(st[n] += t),
                  (ot[n] += e),
                  Y._vx.update(t, 2 === n),
                  Y._vy.update(e, 2 === n),
                  u ? V || (V = requestAnimationFrame(lt)) : lt()
              },
              ut = function (t) {
                if (!at(t, 1)) {
                  var e = (t = Ji(t, h)).clientX,
                    n = t.clientY,
                    i = e - Y.x,
                    r = n - Y.y,
                    s = Y.isDragging
                  ;(Y.x = e),
                    (Y.y = n),
                    (s ||
                      Math.abs(Y.startX - e) >= o ||
                      Math.abs(Y.startY - n) >= o) &&
                      (y && (j = !0),
                      s || (Y.isDragging = !0),
                      ct(i, r, 2),
                      s || (v && v(Y)))
                }
              },
              ht = (Y.onPress = function (t) {
                at(t, 1) ||
                  (W.pause(),
                  (Y.isPressed = !0),
                  (t = Ji(t, h)),
                  (J = Z = 0),
                  (Y.startX = Y.x = t.clientX),
                  (Y.startY = Y.y = t.clientY),
                  Y._vx.reset(),
                  Y._vy.reset(),
                  Ui(O ? l : rt, et[1], ut, h),
                  (Y.deltaX = Y.deltaY = 0),
                  x && x(Y))
              }),
              dt = function (t) {
                if (!at(t, 1)) {
                  Hi(O ? l : rt, et[1], ut)
                  var e = Y.isDragging
                  e || (Y._vx.reset(), Y._vy.reset()),
                    (Y.isDragging = Y.isGesturing = Y.isPressed = !1),
                    d && !O && W.restart(!0),
                    _ && e && _(Y),
                    b && b(Y, e)
                }
              },
              pt = function (t) {
                return (
                  t.touches &&
                  t.touches.length > 1 &&
                  (Y.isGesturing = !0) &&
                  N(t, Y.isDragging)
                )
              },
              ft = function () {
                return (Y.isGesturing = !1) || k(Y)
              },
              mt = function (t) {
                if (!at(t)) {
                  var e = K(),
                    n = Q()
                  ct((e - $) * G, (n - tt) * G, 1),
                    ($ = e),
                    (tt = n),
                    d && W.restart(!0)
                }
              },
              gt = function (t) {
                if (!at(t)) {
                  ;(t = Ji(t, h)), B && (X = !0)
                  var e =
                    (1 === t.deltaMode
                      ? c
                      : 2 === t.deltaMode
                      ? wi.innerHeight
                      : 1) * m
                  ct(t.deltaX * e, t.deltaY * e, 0), d && !O && W.restart(!0)
                }
              },
              vt = function (t) {
                if (!at(t)) {
                  var e = t.clientX,
                    n = t.clientY,
                    i = e - Y.x,
                    r = n - Y.y
                  ;(Y.x = e), (Y.y = n), F && (q = !0), (i || r) && ct(i, r, 2)
                }
              },
              _t = function (t) {
                ;(Y.event = t), R(Y)
              },
              yt = function (t) {
                ;(Y.event = t), P(Y)
              },
              xt = function (t) {
                return at(t) || (Ji(t, h) && H(Y))
              }
            ;(W = Y._dc = xi
              .delayedCall(p || 0.25, function () {
                Y._vx.reset(), Y._vy.reset(), W.pause(), d && d(Y)
              })
              .pause()),
              (Y.deltaX = Y.deltaY = 0),
              (Y._vx = Yi(0, 50, !0)),
              (Y._vy = Yi(0, 50, !0)),
              (Y.scrollX = K),
              (Y.scrollY = Q),
              (Y.isDragging = Y.isGesturing = Y.isPressed = !1),
              (Y.enable = function (t) {
                return (
                  Y.isEnabled ||
                    (Ui(it ? rt : l, 'scroll', Gi),
                    a.indexOf('scroll') >= 0 &&
                      Ui(it ? rt : l, 'scroll', mt, h),
                    a.indexOf('wheel') >= 0 && Ui(l, 'wheel', gt, h),
                    ((a.indexOf('touch') >= 0 && Ei) ||
                      a.indexOf('pointer') >= 0) &&
                      (Ui(l, et[0], ht, h),
                      Ui(rt, et[2], dt),
                      Ui(rt, et[3], dt),
                      H && Ui(l, 'click', xt),
                      N && Ui(rt, 'gesturestart', pt),
                      k && Ui(rt, 'gestureend', ft),
                      R && Ui(l, Di + 'enter', _t),
                      P && Ui(l, Di + 'leave', yt),
                      F && Ui(l, Di + 'move', vt)),
                    (Y.isEnabled = !0),
                    t && t.type && ht(t),
                    z && z(Y)),
                  Y
                )
              }),
              (Y.disable = function () {
                Y.isEnabled &&
                  (Fi.filter(function (t) {
                    return t !== Y && zi(t.target)
                  }).length || Hi(it ? rt : l, 'scroll', Gi),
                  Hi(it ? rt : l, 'scroll', mt),
                  Hi(l, 'wheel', gt),
                  Hi(l, et[0], ht),
                  Hi(rt, et[2], dt),
                  Hi(rt, et[3], dt),
                  Hi(l, 'click', xt),
                  Hi(rt, 'gesturestart', pt),
                  Hi(rt, 'gestureend', ft),
                  Hi(l, Di + 'enter', _t),
                  Hi(l, Di + 'leave', yt),
                  Hi(l, Di + 'move', vt),
                  (Y.isEnabled = !1),
                  U && U(Y))
              }),
              (Y.kill = function () {
                Y.disable()
                var t = Fi.indexOf(Y)
                t >= 0 && Fi.splice(t, 1), Li === Y && (Li = 0)
              }),
              Fi.push(Y),
              O && (Li = Y),
              Y.enable(g)
          }),
          (e = t),
          (n = [
            {
              key: 'velocityX',
              get: function () {
                return this._vx.getVelocity()
              },
            },
            {
              key: 'velocityY',
              get: function () {
                return this._vy.getVelocity()
              },
            },
          ]) && yi(e.prototype, n),
          t
        )
      })()
      ;(Qi.version = '3.10.2'),
        (Qi.create = function (t) {
          return new Qi(t)
        }),
        (Qi.register = Ki),
        (Qi.getAll = function () {
          return Fi.slice()
        }),
        (Qi.getById = function (t) {
          return Fi.filter(function (e) {
            return e.vars.id === t
          })[0]
        }),
        Ri() && xi.registerPlugin(Qi)
      var $i,
        tr,
        er,
        nr,
        ir,
        rr,
        sr,
        or,
        ar,
        lr,
        cr,
        ur,
        hr,
        dr,
        pr,
        fr,
        mr,
        gr,
        vr,
        _r,
        yr,
        xr,
        br,
        wr,
        Mr,
        Sr,
        Tr,
        Er,
        Dr,
        Ar,
        Cr,
        Lr,
        Rr = 1,
        Pr = Date.now,
        Fr = Pr(),
        Ir = 0,
        Or = 0,
        Nr = function () {
          return (dr = 1)
        },
        kr = function () {
          return (dr = 0)
        },
        Br = function (t) {
          return t
        },
        zr = function (t) {
          return Math.round(1e5 * t) / 1e5 || 0
        },
        Ur = function () {
          return 'undefined' != typeof window
        },
        Hr = function () {
          return $i || (Ur() && ($i = window.gsap) && $i.registerPlugin && $i)
        },
        Gr = function (t) {
          return !!~sr.indexOf(t)
        },
        Vr = function (t) {
          return (
            Bi(t, 'getBoundingClientRect') ||
            (Gr(t)
              ? function () {
                  return (
                    (Ks.width = er.innerWidth), (Ks.height = er.innerHeight), Ks
                  )
                }
              : function () {
                  return hs(t)
                })
          )
        },
        Wr = function (t, e) {
          var n = e.s,
            i = e.d2,
            r = e.d,
            s = e.a
          return (n = 'scroll' + i) && (s = Bi(t, n))
            ? s() - Vr(t)()[r]
            : Gr(t)
            ? (ir[n] || rr[n]) -
              (er['inner' + i] || ir['client' + i] || rr['client' + i])
            : t[n] - t['offset' + i]
        },
        jr = function (t, e) {
          for (var n = 0; n < vr.length; n += 3)
            (!e || ~e.indexOf(vr[n + 1])) && t(vr[n], vr[n + 1], vr[n + 2])
        },
        qr = function (t) {
          return 'string' == typeof t
        },
        Xr = function (t) {
          return 'function' == typeof t
        },
        Yr = function (t) {
          return 'number' == typeof t
        },
        Jr = function (t) {
          return 'object' == typeof t
        },
        Zr = function (t) {
          return Xr(t) && t()
        },
        Kr = function (t, e) {
          return function () {
            var n = Zr(t),
              i = Zr(e)
            return function () {
              Zr(n), Zr(i)
            }
          }
        },
        Qr = function (t, e, n) {
          return t && t.progress(e ? 0 : 1) && n && t.pause()
        },
        $r = function (t, e) {
          if (t.enabled) {
            var n = e(t)
            n && n.totalTime && (t.callbackAnimation = n)
          }
        },
        ts = Math.abs,
        es = 'right',
        ns = 'bottom',
        is = 'width',
        rs = 'height',
        ss = 'padding',
        os = 'margin',
        as = 'Width',
        ls = 'px',
        cs = function (t) {
          return er.getComputedStyle(t)
        },
        us = function (t, e) {
          for (var n in e) n in t || (t[n] = e[n])
          return t
        },
        hs = function (t, e) {
          var n =
              e &&
              'matrix(1, 0, 0, 1, 0, 0)' !== cs(t)[pr] &&
              $i
                .to(t, {
                  x: 0,
                  y: 0,
                  xPercent: 0,
                  yPercent: 0,
                  rotation: 0,
                  rotationX: 0,
                  rotationY: 0,
                  scale: 1,
                  skewX: 0,
                  skewY: 0,
                })
                .progress(1),
            i = t.getBoundingClientRect()
          return n && n.progress(0).kill(), i
        },
        ds = function (t, e) {
          var n = e.d2
          return t['offset' + n] || t['client' + n] || 0
        },
        ps = function (t) {
          var e,
            n = [],
            i = t.labels,
            r = t.duration()
          for (e in i) n.push(i[e] / r)
          return n
        },
        fs = function (t) {
          var e = $i.utils.snap(t),
            n =
              Array.isArray(t) &&
              t.slice(0).sort(function (t, e) {
                return t - e
              })
          return n
            ? function (t, i, r) {
                var s
                if ((void 0 === r && (r = 0.001), !i)) return e(t)
                if (i > 0) {
                  for (t -= r, s = 0; s < n.length; s++)
                    if (n[s] >= t) return n[s]
                  return n[s - 1]
                }
                for (s = n.length, t += r; s--; ) if (n[s] <= t) return n[s]
                return n[0]
              }
            : function (n, i, r) {
                void 0 === r && (r = 0.001)
                var s = e(n)
                return !i || Math.abs(s - n) < r || s - n < 0 == i < 0
                  ? s
                  : e(i < 0 ? n - t : n + t)
              }
        },
        ms = function (t, e, n, i) {
          return n.split(',').forEach(function (n) {
            return t(e, n, i)
          })
        },
        gs = function (t, e, n, i) {
          return t.addEventListener(e, n, { passive: !i })
        },
        vs = function (t, e, n) {
          return t.removeEventListener(e, n)
        },
        _s = function (t, e, n) {
          return n && n.wheelHandler && t(e, 'wheel', n)
        },
        ys = {
          startColor: 'green',
          endColor: 'red',
          indent: 0,
          fontSize: '16px',
          fontWeight: 'normal',
        },
        xs = { toggleActions: 'play', anticipatePin: 0 },
        bs = { top: 0, left: 0, center: 0.5, bottom: 1, right: 1 },
        ws = function (t, e) {
          if (qr(t)) {
            var n = t.indexOf('='),
              i = ~n ? +(t.charAt(n - 1) + 1) * parseFloat(t.substr(n + 1)) : 0
            ~n &&
              (t.indexOf('%') > n && (i *= e / 100), (t = t.substr(0, n - 1))),
              (t =
                i +
                (t in bs
                  ? bs[t] * e
                  : ~t.indexOf('%')
                  ? (parseFloat(t) * e) / 100
                  : parseFloat(t) || 0))
          }
          return t
        },
        Ms = function (t, e, n, i, r, s, o, a) {
          var l = r.startColor,
            c = r.endColor,
            u = r.fontSize,
            h = r.indent,
            d = r.fontWeight,
            p = nr.createElement('div'),
            f = Gr(n) || 'fixed' === Bi(n, 'pinType'),
            m = -1 !== t.indexOf('scroller'),
            g = f ? rr : n,
            v = -1 !== t.indexOf('start'),
            _ = v ? l : c,
            y =
              'border-color:' +
              _ +
              ';font-size:' +
              u +
              ';color:' +
              _ +
              ';font-weight:' +
              d +
              ';pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;'
          return (
            (y += 'position:' + ((m || a) && f ? 'fixed;' : 'absolute;')),
            (m || a || !f) &&
              (y += (i === ji ? es : ns) + ':' + (s + parseFloat(h)) + 'px;'),
            o &&
              (y +=
                'box-sizing:border-box;text-align:left;width:' +
                o.offsetWidth +
                'px;'),
            (p._isStart = v),
            p.setAttribute(
              'class',
              'gsap-marker-' + t + (e ? ' marker-' + e : ''),
            ),
            (p.style.cssText = y),
            (p.innerText = e || 0 === e ? t + '-' + e : t),
            g.children[0] ? g.insertBefore(p, g.children[0]) : g.appendChild(p),
            (p._offset = p['offset' + i.op.d2]),
            Ss(p, 0, i, v),
            p
          )
        },
        Ss = function (t, e, n, i) {
          var r = { display: 'block' },
            s = n[i ? 'os2' : 'p2'],
            o = n[i ? 'p2' : 'os2']
          ;(t._isFlipped = i),
            (r[n.a + 'Percent'] = i ? -100 : 0),
            (r[n.a] = i ? '1px' : 0),
            (r['border' + s + as] = 1),
            (r['border' + o + as] = 0),
            (r[n.p] = e + 'px'),
            $i.set(t, r)
        },
        Ts = [],
        Es = {},
        Ds = function () {
          return Pr() - Ir > 34 && Ws()
        },
        As = function () {
          ;(br && br.isPressed) ||
            (Ii.cache++,
            Er || (Er = requestAnimationFrame(Ws)),
            Ir || Os('scrollStart'),
            (Ir = Pr()))
        },
        Cs = function () {
          Ii.cache++,
            !hr &&
              !xr &&
              !nr.fullscreenElement &&
              (!wr ||
                Sr !== er.innerWidth ||
                Math.abs(er.innerHeight - Mr) > 0.25 * er.innerHeight) &&
              or.restart(!0)
        },
        Ls = {},
        Rs = [],
        Ps = [],
        Fs = function (t) {
          var e,
            n = $i.ticker.frame,
            i = [],
            r = 0
          if (Ar !== n || Rr) {
            for (Bs(); r < Ps.length; r += 4)
              (e = er.matchMedia(Ps[r]).matches) !== Ps[r + 3] &&
                ((Ps[r + 3] = e),
                e ? i.push(r) : Bs(1, Ps[r]) || (Xr(Ps[r + 2]) && Ps[r + 2]()))
            for (ks(), r = 0; r < i.length; r++)
              (e = i[r]), (Dr = Ps[e]), (Ps[e + 2] = Ps[e + 1](t))
            ;(Dr = 0), tr && Hs(0, 1), (Ar = n), Os('matchMedia')
          }
        },
        Is = function t() {
          return vs(no, 'scrollEnd', t) || Hs(!0)
        },
        Os = function (t) {
          return (
            (Ls[t] &&
              Ls[t].map(function (t) {
                return t()
              })) ||
            Rs
          )
        },
        Ns = [],
        ks = function (t) {
          for (var e = 0; e < Ns.length; e += 5)
            (t && Ns[e + 4] !== t) ||
              ((Ns[e].style.cssText = Ns[e + 1]),
              Ns[e].getBBox && Ns[e].setAttribute('transform', Ns[e + 2] || ''),
              (Ns[e + 3].uncache = 1))
        },
        Bs = function (t, e) {
          var n
          for (fr = 0; fr < Ts.length; fr++)
            (n = Ts[fr]), (e && n.media !== e) || (t ? n.kill(1) : n.revert())
          e && ks(e), e || Os('revert')
        },
        zs = function () {
          return (
            Ii.cache++ &&
            Ii.forEach(function (t) {
              return 'function' == typeof t && (t.rec = 0)
            })
          )
        },
        Us = 0,
        Hs = function (t, e) {
          if (!Ir || t) {
            Cr = !0
            var n = Os('refreshInit')
            _r && no.sort(),
              e || Bs(),
              Ts.slice(0).forEach(function (t) {
                return t.refresh()
              }),
              Ts.forEach(function (t) {
                return (
                  'max' === t.vars.end &&
                  t.setPositions(t.start, Wr(t.scroller, t._dir))
                )
              }),
              n.forEach(function (t) {
                return t && t.render && t.render(-1)
              }),
              zs(),
              or.pause(),
              Us++,
              (Cr = !1),
              Os('refresh')
          } else gs(no, 'scrollEnd', Is)
        },
        Gs = 0,
        Vs = 1,
        Ws = function () {
          if (!Cr) {
            Lr && Lr.update(0), (no.isUpdating = !0)
            var t = Ts.length,
              e = Pr(),
              n = e - Fr >= 50,
              i = t && Ts[0].scroll()
            if (
              ((Vs = Gs > i ? -1 : 1),
              (Gs = i),
              n &&
                (Ir && !dr && e - Ir > 200 && ((Ir = 0), Os('scrollEnd')),
                (cr = Fr),
                (Fr = e)),
              Vs < 0)
            ) {
              for (fr = t; fr-- > 0; ) Ts[fr] && Ts[fr].update(0, n)
              Vs = 1
            } else for (fr = 0; fr < t; fr++) Ts[fr] && Ts[fr].update(0, n)
            no.isUpdating = !1
          }
          Er = 0
        },
        js = [
          'left',
          'top',
          ns,
          es,
          'marginBottom',
          'marginRight',
          'marginTop',
          'marginLeft',
          'display',
          'flexShrink',
          'float',
          'zIndex',
          'gridColumnStart',
          'gridColumnEnd',
          'gridRowStart',
          'gridRowEnd',
          'gridArea',
          'justifySelf',
          'alignSelf',
          'placeSelf',
          'order',
        ],
        qs = js.concat([
          is,
          rs,
          'boxSizing',
          'maxWidth',
          'maxHeight',
          'position',
          os,
          ss,
          'paddingTop',
          'paddingRight',
          'paddingBottom',
          'paddingLeft',
        ]),
        Xs = function (t, e, n, i) {
          if (t.parentNode !== e) {
            for (var r, s = js.length, o = e.style, a = t.style; s--; )
              o[(r = js[s])] = n[r]
            ;(o.position = 'absolute' === n.position ? 'absolute' : 'relative'),
              'inline' === n.display && (o.display = 'inline-block'),
              (a.bottom = a.right = o.flexBasis = 'auto'),
              (o.overflow = 'visible'),
              (o.boxSizing = 'border-box'),
              (o.width = ds(t, Wi) + ls),
              (o.height = ds(t, ji) + ls),
              (o.padding = a.margin = a.top = a.left = '0'),
              Js(i),
              (a.width = a.maxWidth = n.width),
              (a.height = a.maxHeight = n.height),
              (a.padding = n.padding),
              t.parentNode.insertBefore(e, t),
              e.appendChild(t)
          }
        },
        Ys = /([A-Z])/g,
        Js = function (t) {
          if (t) {
            var e,
              n,
              i = t.t.style,
              r = t.length,
              s = 0
            for (
              (t.t._gsap || $i.core.getCache(t.t)).uncache = 1;
              s < r;
              s += 2
            )
              (n = t[s + 1]),
                (e = t[s]),
                n
                  ? (i[e] = n)
                  : i[e] && i.removeProperty(e.replace(Ys, '-$1').toLowerCase())
          }
        },
        Zs = function (t) {
          for (var e = qs.length, n = t.style, i = [], r = 0; r < e; r++)
            i.push(qs[r], n[qs[r]])
          return (i.t = t), i
        },
        Ks = { left: 0, top: 0 },
        Qs = function (t, e, n, i, r, s, o, a, l, c, u, h, d) {
          Xr(t) && (t = t(a)),
            qr(t) &&
              'max' === t.substr(0, 3) &&
              (t = h + ('=' === t.charAt(4) ? ws('0' + t.substr(3), n) : 0))
          var p,
            f,
            m,
            g = d ? d.time() : 0
          if ((d && d.seek(0), Yr(t))) o && Ss(o, n, i, !0)
          else {
            Xr(e) && (e = e(a))
            var v,
              _,
              y,
              x,
              b = t.split(' ')
            ;(m = qi(e) || rr),
              ((v = hs(m) || {}) && (v.left || v.top)) ||
                'none' !== cs(m).display ||
                ((x = m.style.display),
                (m.style.display = 'block'),
                (v = hs(m)),
                x ? (m.style.display = x) : m.style.removeProperty('display')),
              (_ = ws(b[0], v[i.d])),
              (y = ws(b[1] || '0', n)),
              (t = v[i.p] - l[i.p] - c + _ + r - y),
              o && Ss(o, y, i, n - y < 20 || (o._isStart && y > 20)),
              (n -= n - y)
          }
          if (s) {
            var w = t + n,
              M = s._isStart
            ;(p = 'scroll' + i.d2),
              Ss(
                s,
                w,
                i,
                (M && w > 20) ||
                  (!M &&
                    (u ? Math.max(rr[p], ir[p]) : s.parentNode[p]) <= w + 1),
              ),
              u &&
                ((l = hs(o)),
                u && (s.style[i.op.p] = l[i.op.p] - i.op.m - s._offset + ls))
          }
          return (
            d &&
              m &&
              ((p = hs(m)),
              d.seek(h),
              (f = hs(m)),
              (d._caScrollDist = p[i.p] - f[i.p]),
              (t = (t / d._caScrollDist) * h)),
            d && d.seek(g),
            d ? t : Math.round(t)
          )
        },
        $s = /(webkit|moz|length|cssText|inset)/i,
        to = function (t, e, n, i) {
          if (t.parentNode !== e) {
            var r,
              s,
              o = t.style
            if (e === rr) {
              for (r in ((t._stOrig = o.cssText), (s = cs(t))))
                +r ||
                  $s.test(r) ||
                  !s[r] ||
                  'string' != typeof o[r] ||
                  '0' === r ||
                  (o[r] = s[r])
              ;(o.top = n), (o.left = i)
            } else o.cssText = t._stOrig
            ;($i.core.getCache(t).uncache = 1), e.appendChild(t)
          }
        },
        eo = function (t, e) {
          var n,
            i,
            r = Xi(t, e),
            s = '_scroll' + e.p2,
            o = function e(o, a, l, c, u) {
              var h = e.tween,
                d = a.onComplete,
                p = {}
              return (
                (l = l || r()),
                (u = (c && u) || 0),
                (c = c || o - l),
                h && h.kill(),
                (n = Math.round(l)),
                (a[s] = o),
                (a.modifiers = p),
                (p[s] = function (t) {
                  return (
                    (t = zr(r())) !== n &&
                    t !== i &&
                    Math.abs(t - n) > 2 &&
                    Math.abs(t - i) > 2
                      ? (h.kill(), (e.tween = 0))
                      : (t = l + c * h.ratio + u * h.ratio * h.ratio),
                    (i = n),
                    (n = zr(t))
                  )
                }),
                (a.onComplete = function () {
                  ;(e.tween = 0), d && d.call(h)
                }),
                (h = e.tween = $i.to(t, a))
              )
            }
          return (
            (t[s] = r),
            (r.wheelHandler = function () {
              return o.tween && o.tween.kill() && (o.tween = 0)
            }),
            gs(t, 'wheel', r.wheelHandler),
            o
          )
        },
        no = (function () {
          function t(e, n) {
            tr ||
              t.register($i) ||
              console.warn('Please gsap.registerPlugin(ScrollTrigger)'),
              this.init(e, n)
          }
          return (
            (t.prototype.init = function (e, n) {
              if (
                ((this.progress = this.start = 0),
                this.vars && this.kill(!0, !0),
                Or)
              ) {
                var i,
                  r,
                  s,
                  o,
                  a,
                  l,
                  c,
                  u,
                  h,
                  d,
                  p,
                  f,
                  m,
                  g,
                  v,
                  _,
                  y,
                  x,
                  b,
                  w,
                  M,
                  S,
                  T,
                  E,
                  D,
                  A,
                  C,
                  L,
                  R,
                  P,
                  F,
                  I,
                  O,
                  N,
                  k,
                  B,
                  z,
                  U,
                  H,
                  G,
                  V,
                  W = (e = us(
                    qr(e) || Yr(e) || e.nodeType ? { trigger: e } : e,
                    xs,
                  )),
                  j = W.onUpdate,
                  q = W.toggleClass,
                  X = W.id,
                  Y = W.onToggle,
                  J = W.onRefresh,
                  Z = W.scrub,
                  K = W.trigger,
                  Q = W.pin,
                  $ = W.pinSpacing,
                  tt = W.invalidateOnRefresh,
                  et = W.anticipatePin,
                  nt = W.onScrubComplete,
                  it = W.onSnapComplete,
                  rt = W.once,
                  st = W.snap,
                  ot = W.pinReparent,
                  at = W.pinSpacer,
                  lt = W.containerAnimation,
                  ct = W.fastScrollEnd,
                  ut = W.preventOverlaps,
                  ht =
                    e.horizontal ||
                    (e.containerAnimation && !1 !== e.horizontal)
                      ? Wi
                      : ji,
                  dt = !Z && 0 !== Z,
                  pt = qi(e.scroller || er),
                  ft = $i.core.getCache(pt),
                  mt = Gr(pt),
                  gt =
                    'fixed' ===
                    ('pinType' in e
                      ? e.pinType
                      : Bi(pt, 'pinType') || (mt && 'fixed')),
                  vt = [e.onEnter, e.onLeave, e.onEnterBack, e.onLeaveBack],
                  _t = dt && e.toggleActions.split(' '),
                  yt = 'markers' in e ? e.markers : xs.markers,
                  xt = mt ? 0 : parseFloat(cs(pt)['border' + ht.p2 + as]) || 0,
                  bt = this,
                  wt =
                    e.onRefreshInit &&
                    function () {
                      return e.onRefreshInit(bt)
                    },
                  Mt = (function (t, e, n) {
                    var i = n.d,
                      r = n.d2,
                      s = n.a
                    return (s = Bi(t, 'getBoundingClientRect'))
                      ? function () {
                          return s()[i]
                        }
                      : function () {
                          return (e ? er['inner' + r] : t['client' + r]) || 0
                        }
                  })(pt, mt, ht),
                  St = (function (t, e) {
                    return !e || ~Oi.indexOf(t)
                      ? Vr(t)
                      : function () {
                          return Ks
                        }
                  })(pt, mt),
                  Tt = 0,
                  Et = Xi(pt, ht)
                if (
                  ((bt.media = Dr),
                  (bt._dir = ht),
                  (et *= 45),
                  (bt.scroller = pt),
                  (bt.scroll = lt ? lt.time.bind(lt) : Et),
                  (o = Et()),
                  (bt.vars = e),
                  (n = n || e.animation),
                  'refreshPriority' in e &&
                    ((_r = 1), -9999 === e.refreshPriority && (Lr = bt)),
                  (ft.tweenScroll = ft.tweenScroll || {
                    top: eo(pt, ji),
                    left: eo(pt, Wi),
                  }),
                  (bt.tweenTo = i = ft.tweenScroll[ht.p]),
                  (bt.scrubDuration = function (t) {
                    ;(F = Yr(t) && t)
                      ? P
                        ? P.duration(t)
                        : (P = $i.to(n, {
                            ease: 'expo',
                            totalProgress: '+=0.001',
                            duration: F,
                            paused: !0,
                            onComplete: function () {
                              return nt && nt(bt)
                            },
                          }))
                      : (P && P.progress(1).kill(), (P = 0))
                  }),
                  n &&
                    ((n.vars.lazy = !1),
                    n._initted ||
                      (!1 !== n.vars.immediateRender &&
                        !1 !== e.immediateRender &&
                        n.render(0, !0, !0)),
                    (bt.animation = n.pause()),
                    (n.scrollTrigger = bt),
                    bt.scrubDuration(Z),
                    (L = 0),
                    X || (X = n.vars.id)),
                  Ts.push(bt),
                  st &&
                    ((Jr(st) && !st.push) || (st = { snapTo: st }),
                    'scrollBehavior' in rr.style &&
                      $i.set(mt ? [rr, ir] : pt, { scrollBehavior: 'auto' }),
                    (s = Xr(st.snapTo)
                      ? st.snapTo
                      : 'labels' === st.snapTo
                      ? (function (t) {
                          return function (e) {
                            return $i.utils.snap(ps(t), e)
                          }
                        })(n)
                      : 'labelsDirectional' === st.snapTo
                      ? ((H = n),
                        function (t, e) {
                          return fs(ps(H))(t, e.direction)
                        })
                      : !1 !== st.directional
                      ? function (t, e) {
                          return fs(st.snapTo)(t, hr ? 0 : e.direction)
                        }
                      : $i.utils.snap(st.snapTo)),
                    (I = st.duration || { min: 0.1, max: 2 }),
                    (I = Jr(I) ? lr(I.min, I.max) : lr(I, I)),
                    (O = $i
                      .delayedCall(st.delay || F / 2 || 0.1, function () {
                        if (
                          Math.abs(bt.getVelocity()) < 10 &&
                          !dr &&
                          Tt !== Et()
                        ) {
                          var t = n && !dt ? n.totalProgress() : bt.progress,
                            e = ((t - R) / (Pr() - cr)) * 1e3 || 0,
                            r = $i.utils.clamp(
                              -bt.progress,
                              1 - bt.progress,
                              (ts(e / 2) * e) / 0.185,
                            ),
                            o = bt.progress + (!1 === st.inertia ? 0 : r),
                            a = lr(0, 1, s(o, bt)),
                            u = Et(),
                            h = Math.round(l + a * m),
                            d = st,
                            p = d.onStart,
                            f = d.onInterrupt,
                            g = d.onComplete,
                            v = i.tween
                          if (u <= c && u >= l && h !== u) {
                            if (v && !v._initted && v.data <= ts(h - u)) return
                            !1 === st.inertia && (r = a - bt.progress),
                              i(
                                h,
                                {
                                  duration: I(
                                    ts(
                                      (0.185 * Math.max(ts(o - t), ts(a - t))) /
                                        e /
                                        0.05 || 0,
                                    ),
                                  ),
                                  ease: st.ease || 'power3',
                                  data: ts(h - u),
                                  onInterrupt: function () {
                                    return O.restart(!0) && f && f(bt)
                                  },
                                  onComplete: function () {
                                    bt.update(),
                                      (Tt = Et()),
                                      (L = R =
                                        n && !dt
                                          ? n.totalProgress()
                                          : bt.progress),
                                      it && it(bt),
                                      g && g(bt)
                                  },
                                },
                                u,
                                r * m,
                                h - u - r * m,
                              ),
                              p && p(bt, i.tween)
                          }
                        } else bt.isActive && O.restart(!0)
                      })
                      .pause())),
                  X && (Es[X] = bt),
                  (U =
                    (K = bt.trigger = qi(K || Q)) &&
                    K._gsap &&
                    K._gsap.stRevert) && (U = U(bt)),
                  (Q = !0 === Q ? K : qi(Q)),
                  qr(q) && (q = { targets: K, className: q }),
                  Q &&
                    (!1 === $ ||
                      $ === os ||
                      ($ = !(!$ && 'flex' === cs(Q.parentNode).display) && ss),
                    (bt.pin = Q),
                    !1 !== e.force3D && $i.set(Q, { force3D: !0 }),
                    (r = $i.core.getCache(Q)).spacer
                      ? (g = r.pinState)
                      : (at &&
                          ((at = qi(at)) &&
                            !at.nodeType &&
                            (at = at.current || at.nativeElement),
                          (r.spacerIsNative = !!at),
                          at && (r.spacerState = Zs(at))),
                        (r.spacer = y = at || nr.createElement('div')),
                        y.classList.add('pin-spacer'),
                        X && y.classList.add('pin-spacer-' + X),
                        (r.pinState = g = Zs(Q))),
                    (bt.spacer = y = r.spacer),
                    (C = cs(Q)),
                    (T = C[$ + ht.os2]),
                    (b = $i.getProperty(Q)),
                    (w = $i.quickSetter(Q, ht.a, ls)),
                    Xs(Q, y, C),
                    (_ = Zs(Q))),
                  yt)
                ) {
                  ;(f = Jr(yt) ? us(yt, ys) : ys),
                    (d = Ms('scroller-start', X, pt, ht, f, 0)),
                    (p = Ms('scroller-end', X, pt, ht, f, 0, d)),
                    (x = d['offset' + ht.op.d2])
                  var Dt = qi(Bi(pt, 'content') || pt)
                  ;(u = this.markerStart = Ms('start', X, Dt, ht, f, x, 0, lt)),
                    (h = this.markerEnd = Ms('end', X, Dt, ht, f, x, 0, lt)),
                    lt && (z = $i.quickSetter([u, h], ht.a, ls)),
                    gt ||
                      (Oi.length && !0 === Bi(pt, 'fixedMarkers')) ||
                      ((V = cs((G = mt ? rr : pt)).position),
                      (G.style.position =
                        'absolute' === V || 'fixed' === V ? V : 'relative'),
                      $i.set([d, p], { force3D: !0 }),
                      (D = $i.quickSetter(d, ht.a, ls)),
                      (A = $i.quickSetter(p, ht.a, ls)))
                }
                if (lt) {
                  var At = lt.vars.onUpdate,
                    Ct = lt.vars.onUpdateParams
                  lt.eventCallback('onUpdate', function () {
                    bt.update(0, 0, 1), At && At.apply(Ct || [])
                  })
                }
                ;(bt.previous = function () {
                  return Ts[Ts.indexOf(bt) - 1]
                }),
                  (bt.next = function () {
                    return Ts[Ts.indexOf(bt) + 1]
                  }),
                  (bt.revert = function (t) {
                    var e = !1 !== t || !bt.enabled,
                      i = hr
                    e !== bt.isReverted &&
                      (e &&
                        (bt.scroll.rec || !hr || !Cr || (bt.scroll.rec = Et()),
                        (k = Math.max(Et(), bt.scroll.rec || 0)),
                        (N = bt.progress),
                        (B = n && n.progress())),
                      u &&
                        [u, h, d, p].forEach(function (t) {
                          return (t.style.display = e ? 'none' : 'block')
                        }),
                      e && (hr = 1),
                      bt.update(e),
                      (hr = i),
                      Q &&
                        (e
                          ? (function (t, e, n) {
                              Js(n)
                              var i = t._gsap
                              if (i.spacerIsNative) Js(i.spacerState)
                              else if (t.parentNode === e) {
                                var r = e.parentNode
                                r && (r.insertBefore(t, e), r.removeChild(e))
                              }
                            })(Q, y, g)
                          : (!ot || !bt.isActive) && Xs(Q, y, cs(Q), E)),
                      (bt.isReverted = e))
                  }),
                  (bt.refresh = function (i, r) {
                    if ((!hr && bt.enabled) || r)
                      if (Q && i && Ir) gs(t, 'scrollEnd', Is)
                      else {
                        !Cr && wt && wt(bt),
                          (hr = 1),
                          P && P.pause(),
                          tt && n && n.time(-0.01, !0).invalidate(),
                          bt.isReverted || bt.revert()
                        for (
                          var s,
                            f,
                            x,
                            w,
                            T,
                            D,
                            A,
                            C,
                            L,
                            R,
                            F = Mt(),
                            I = St(),
                            z = lt ? lt.duration() : Wr(pt, ht),
                            U = 0,
                            H = 0,
                            G = e.end,
                            V = e.endTrigger || K,
                            W =
                              e.start ||
                              (0 !== e.start && K ? (Q ? '0 0' : '0 100%') : 0),
                            j = (bt.pinnedContainer =
                              e.pinnedContainer && qi(e.pinnedContainer)),
                            q = (K && Math.max(0, Ts.indexOf(bt))) || 0,
                            X = q;
                          X--;

                        )
                          (D = Ts[X]).end || D.refresh(0, 1) || (hr = 1),
                            !(A = D.pin) ||
                              (A !== K && A !== Q) ||
                              D.isReverted ||
                              (R || (R = []), R.unshift(D), D.revert()),
                            D !== Ts[X] && (q--, X--)
                        for (
                          Xr(W) && (W = W(bt)),
                            l =
                              Qs(
                                W,
                                K,
                                F,
                                ht,
                                Et(),
                                u,
                                d,
                                bt,
                                I,
                                xt,
                                gt,
                                z,
                                lt,
                              ) || (Q ? -0.001 : 0),
                            Xr(G) && (G = G(bt)),
                            qr(G) &&
                              !G.indexOf('+=') &&
                              (~G.indexOf(' ')
                                ? (G = (qr(W) ? W.split(' ')[0] : '') + G)
                                : ((U = ws(G.substr(2), F)),
                                  (G = qr(W) ? W : l + U),
                                  (V = K))),
                            c =
                              Math.max(
                                l,
                                Qs(
                                  G || (V ? '100% 0' : z),
                                  V,
                                  F,
                                  ht,
                                  Et() + U,
                                  h,
                                  p,
                                  bt,
                                  I,
                                  xt,
                                  gt,
                                  z,
                                  lt,
                                ),
                              ) || -0.001,
                            m = c - l || ((l -= 0.01) && 0.001),
                            U = 0,
                            X = q;
                          X--;

                        )
                          (A = (D = Ts[X]).pin) &&
                            D.start - D._pinPush < l &&
                            !lt &&
                            D.end > 0 &&
                            ((s = D.end - D.start),
                            (A !== K && A !== j) ||
                              Yr(W) ||
                              (U += s * (1 - D.progress)),
                            A === Q && (H += s))
                        if (
                          ((l += U),
                          (c += U),
                          (bt._pinPush = H),
                          u &&
                            U &&
                            (((s = {})[ht.a] = '+=' + U),
                            j && (s[ht.p] = '-=' + Et()),
                            $i.set([u, h], s)),
                          Q)
                        )
                          (s = cs(Q)),
                            (w = ht === ji),
                            (x = Et()),
                            (M = parseFloat(b(ht.a)) + H),
                            !z &&
                              c > 1 &&
                              ((mt ? rr : pt).style['overflow-' + ht.a] =
                                'scroll'),
                            Xs(Q, y, s),
                            (_ = Zs(Q)),
                            (f = hs(Q, !0)),
                            (C = gt && Xi(pt, w ? Wi : ji)()),
                            $ &&
                              (((E = [$ + ht.os2, m + H + ls]).t = y),
                              (X = $ === ss ? ds(Q, ht) + m + H : 0) &&
                                E.push(ht.d, X + ls),
                              Js(E),
                              gt && Et(k)),
                            gt &&
                              (((T = {
                                top: f.top + (w ? x - l : C) + ls,
                                left: f.left + (w ? C : x - l) + ls,
                                boxSizing: 'border-box',
                                position: 'fixed',
                              }).width = T.maxWidth = Math.ceil(f.width) + ls),
                              (T.height = T.maxHeight =
                                Math.ceil(f.height) + ls),
                              (T.margin = T.marginTop = T.marginRight = T.marginBottom = T.marginLeft =
                                '0'),
                              (T.padding = s.padding),
                              (T.paddingTop = s.paddingTop),
                              (T.paddingRight = s.paddingRight),
                              (T.paddingBottom = s.paddingBottom),
                              (T.paddingLeft = s.paddingLeft),
                              (v = (function (t, e, n) {
                                for (
                                  var i, r = [], s = t.length, o = n ? 8 : 0;
                                  o < s;
                                  o += 2
                                )
                                  (i = t[o]),
                                    r.push(i, i in e ? e[i] : t[o + 1])
                                return (r.t = t.t), r
                              })(g, T, ot))),
                            n
                              ? ((L = n._initted),
                                yr(1),
                                n.render(n.duration(), !0, !0),
                                (S = b(ht.a) - M + m + H),
                                m !== S && v.splice(v.length - 2, 2),
                                n.render(0, !0, !0),
                                L || n.invalidate(),
                                yr(0))
                              : (S = m)
                        else if (K && Et() && !lt)
                          for (f = K.parentNode; f && f !== rr; )
                            f._pinOffset &&
                              ((l -= f._pinOffset), (c -= f._pinOffset)),
                              (f = f.parentNode)
                        R &&
                          R.forEach(function (t) {
                            return t.revert(!1)
                          }),
                          (bt.start = l),
                          (bt.end = c),
                          (o = a = Et()),
                          lt || (o < k && Et(k), (bt.scroll.rec = 0)),
                          bt.revert(!1),
                          O && bt.isActive && Et(l + m * N),
                          (hr = 0),
                          n &&
                            dt &&
                            (n._initted || B) &&
                            n.progress() !== B &&
                            n.progress(B, !0).render(n.time(), !0, !0),
                          (N !== bt.progress || lt) &&
                            (n && !dt && n.totalProgress(N, !0),
                            (bt.progress = N),
                            bt.update(0, 0, 1)),
                          Q &&
                            $ &&
                            (y._pinOffset = Math.round(bt.progress * S)),
                          J && J(bt)
                      }
                  }),
                  (bt.getVelocity = function () {
                    return ((Et() - a) / (Pr() - cr)) * 1e3 || 0
                  }),
                  (bt.endAnimation = function () {
                    Qr(bt.callbackAnimation),
                      n &&
                        (P
                          ? P.progress(1)
                          : n.paused()
                          ? dt || Qr(n, bt.direction < 0, 1)
                          : Qr(n, n.reversed()))
                  }),
                  (bt.labelToScroll = function (t) {
                    return (
                      (n &&
                        n.labels &&
                        (l || bt.refresh() || l) +
                          (n.labels[t] / n.duration()) * m) ||
                      0
                    )
                  }),
                  (bt.getTrailing = function (t) {
                    var e = Ts.indexOf(bt),
                      n =
                        bt.direction > 0
                          ? Ts.slice(0, e).reverse()
                          : Ts.slice(e + 1)
                    return (qr(t)
                      ? n.filter(function (e) {
                          return e.vars.preventOverlaps === t
                        })
                      : n
                    ).filter(function (t) {
                      return bt.direction > 0 ? t.end <= l : t.start >= c
                    })
                  }),
                  (bt.update = function (t, e, r) {
                    if (!lt || r || t) {
                      var s,
                        u,
                        h,
                        p,
                        f,
                        g,
                        x,
                        b = bt.scroll(),
                        E = t ? 0 : (b - l) / m,
                        C = E < 0 ? 0 : E > 1 ? 1 : E || 0,
                        F = bt.progress
                      if (
                        (e &&
                          ((a = o),
                          (o = lt ? Et() : b),
                          st &&
                            ((R = L), (L = n && !dt ? n.totalProgress() : C))),
                        et &&
                          !C &&
                          Q &&
                          !hr &&
                          !Rr &&
                          Ir &&
                          l < b + ((b - a) / (Pr() - cr)) * et &&
                          (C = 1e-4),
                        C !== F && bt.enabled)
                      ) {
                        if (
                          ((p =
                            (f =
                              (s = bt.isActive = !!C && C < 1) !=
                              (!!F && F < 1)) || !!C != !!F),
                          (bt.direction = C > F ? 1 : -1),
                          (bt.progress = C),
                          p &&
                            !hr &&
                            ((u = C && !F ? 0 : 1 === C ? 1 : 1 === F ? 2 : 3),
                            dt &&
                              ((h =
                                (!f && 'none' !== _t[u + 1] && _t[u + 1]) ||
                                _t[u]),
                              (x =
                                n &&
                                ('complete' === h ||
                                  'reset' === h ||
                                  h in n)))),
                          ut &&
                            (f || x) &&
                            (x || Z || !n) &&
                            (Xr(ut)
                              ? ut(bt)
                              : bt.getTrailing(ut).forEach(function (t) {
                                  return t.endAnimation()
                                })),
                          dt ||
                            (!P || hr || Rr
                              ? n && n.totalProgress(C, !!hr)
                              : ((lt || (Lr && Lr !== bt)) &&
                                  P.render(P._dp._time - P._start),
                                P.resetTo
                                  ? P.resetTo(
                                      'totalProgress',
                                      C,
                                      n._tTime / n._tDur,
                                    )
                                  : ((P.vars.totalProgress = C),
                                    P.invalidate().restart()))),
                          Q)
                        )
                          if ((t && $ && (y.style[$ + ht.os2] = T), gt)) {
                            if (p) {
                              if (
                                ((g =
                                  !t &&
                                  C > F &&
                                  c + 1 > b &&
                                  b + 1 >= Wr(pt, ht)),
                                ot)
                              )
                                if (t || (!s && !g)) to(Q, y)
                                else {
                                  var I = hs(Q, !0),
                                    N = b - l
                                  to(
                                    Q,
                                    rr,
                                    I.top + (ht === ji ? N : 0) + ls,
                                    I.left + (ht === ji ? 0 : N) + ls,
                                  )
                                }
                              Js(s || g ? v : _),
                                (S !== m && C < 1 && s) ||
                                  w(M + (1 !== C || g ? 0 : S))
                            }
                          } else w(zr(M + S * C))
                        st && !i.tween && !hr && !Rr && O.restart(!0),
                          q &&
                            (f || (rt && C && (C < 1 || !Tr))) &&
                            ar(q.targets).forEach(function (t) {
                              return t.classList[s || rt ? 'add' : 'remove'](
                                q.className,
                              )
                            }),
                          j && !dt && !t && j(bt),
                          p && !hr
                            ? (dt &&
                                (x &&
                                  ('complete' === h
                                    ? n.pause().totalProgress(1)
                                    : 'reset' === h
                                    ? n.restart(!0).pause()
                                    : 'restart' === h
                                    ? n.restart(!0)
                                    : n[h]()),
                                j && j(bt)),
                              (!f && Tr) ||
                                (Y && f && $r(bt, Y),
                                vt[u] && $r(bt, vt[u]),
                                rt && (1 === C ? bt.kill(!1, 1) : (vt[u] = 0)),
                                f ||
                                  (vt[(u = 1 === C ? 1 : 3)] && $r(bt, vt[u]))),
                              ct &&
                                !s &&
                                Math.abs(bt.getVelocity()) >
                                  (Yr(ct) ? ct : 2500) &&
                                (Qr(bt.callbackAnimation),
                                P ? P.progress(1) : Qr(n, !C, 1)))
                            : dt && j && !hr && j(bt)
                      }
                      if (A) {
                        var k = lt
                          ? (b / lt.duration()) * (lt._caScrollDist || 0)
                          : b
                        D(k + (d._isFlipped ? 1 : 0)), A(k)
                      }
                      z && z((-b / lt.duration()) * (lt._caScrollDist || 0))
                    }
                  }),
                  (bt.enable = function (e, n) {
                    bt.enabled ||
                      ((bt.enabled = !0),
                      gs(pt, 'resize', Cs),
                      gs(mt ? nr : pt, 'scroll', As),
                      wt && gs(t, 'refreshInit', wt),
                      !1 !== e && ((bt.progress = N = 0), (o = a = Tt = Et())),
                      !1 !== n && bt.refresh())
                  }),
                  (bt.getTween = function (t) {
                    return t && i ? i.tween : P
                  }),
                  (bt.setPositions = function (t, e) {
                    Q && ((M += t - l), (S += e - t - m)),
                      (bt.start = l = t),
                      (bt.end = c = e),
                      (m = e - t),
                      bt.update()
                  }),
                  (bt.disable = function (e, n) {
                    if (
                      bt.enabled &&
                      (!1 !== e && bt.revert(),
                      (bt.enabled = bt.isActive = !1),
                      n || (P && P.pause()),
                      (k = 0),
                      r && (r.uncache = 1),
                      wt && vs(t, 'refreshInit', wt),
                      O &&
                        (O.pause(), i.tween && i.tween.kill() && (i.tween = 0)),
                      !mt)
                    ) {
                      for (var s = Ts.length; s--; )
                        if (Ts[s].scroller === pt && Ts[s] !== bt) return
                      vs(pt, 'resize', Cs), vs(pt, 'scroll', As)
                    }
                  }),
                  (bt.kill = function (t, i) {
                    bt.disable(t, i), P && !i && P.kill(), X && delete Es[X]
                    var s = Ts.indexOf(bt)
                    s >= 0 && Ts.splice(s, 1),
                      s === fr && Vs > 0 && fr--,
                      (s = 0),
                      Ts.forEach(function (t) {
                        return t.scroller === bt.scroller && (s = 1)
                      }),
                      s || (bt.scroll.rec = 0),
                      n &&
                        ((n.scrollTrigger = null),
                        t && n.render(-1),
                        i || n.kill()),
                      u &&
                        [u, h, d, p].forEach(function (t) {
                          return t.parentNode && t.parentNode.removeChild(t)
                        }),
                      Q &&
                        (r && (r.uncache = 1),
                        (s = 0),
                        Ts.forEach(function (t) {
                          return t.pin === Q && s++
                        }),
                        s || (r.spacer = 0)),
                      e.onKill && e.onKill(bt)
                  }),
                  bt.enable(!1, !1),
                  U && U(bt),
                  n && n.add && !m
                    ? $i.delayedCall(0.01, function () {
                        return l || c || bt.refresh()
                      }) &&
                      (m = 0.01) &&
                      (l = c = 0)
                    : bt.refresh()
              } else this.update = this.refresh = this.kill = Br
            }),
            (t.register = function (e) {
              return (
                tr ||
                  (($i = e || Hr()),
                  Ur() && window.document && t.enable(),
                  (tr = Or)),
                tr
              )
            }),
            (t.defaults = function (t) {
              if (t) for (var e in t) xs[e] = t[e]
              return xs
            }),
            (t.disable = function (t, e) {
              ;(Or = 0),
                Ts.forEach(function (n) {
                  return n[e ? 'kill' : 'disable'](t)
                }),
                vs(er, 'wheel', As),
                vs(nr, 'scroll', As),
                clearInterval(ur),
                vs(nr, 'touchcancel', Br),
                vs(rr, 'touchstart', Br),
                ms(vs, nr, 'pointerdown,touchstart,mousedown', Nr),
                ms(vs, nr, 'pointerup,touchend,mouseup', kr),
                or.kill(),
                jr(vs)
              for (var n = 0; n < Ii.length; n += 3)
                _s(vs, Ii[n], Ii[n + 1]), _s(vs, Ii[n], Ii[n + 2])
            }),
            (t.enable = function () {
              if (
                ((er = window),
                (nr = document),
                (ir = nr.documentElement),
                (rr = nr.body),
                $i &&
                  ((ar = $i.utils.toArray),
                  (lr = $i.utils.clamp),
                  (yr = $i.core.suppressOverwrites || Br),
                  $i.core.globals('ScrollTrigger', t),
                  rr))
              ) {
                ;(Or = 1),
                  (t.isTouch =
                    er.matchMedia &&
                    er.matchMedia('(hover: none), (pointer: coarse)').matches
                      ? 1
                      : 'ontouchstart' in er ||
                        navigator.maxTouchPoints > 0 ||
                        navigator.msMaxTouchPoints > 0
                      ? 2
                      : 0),
                  (sr = [er, nr, ir, rr]),
                  (Mr = er.innerHeight),
                  (Sr = er.innerWidth),
                  Qi.register($i),
                  gs(nr, 'scroll', As)
                var e,
                  n,
                  i = rr.style,
                  r = i.borderTopStyle
                for (
                  i.borderTopStyle = 'solid',
                    e = hs(rr),
                    ji.m = Math.round(e.top + ji.sc()) || 0,
                    Wi.m = Math.round(e.left + Wi.sc()) || 0,
                    r
                      ? (i.borderTopStyle = r)
                      : i.removeProperty('border-top-style'),
                    ur = setInterval(Ds, 250),
                    $i.delayedCall(0.5, function () {
                      return (Rr = 0)
                    }),
                    gs(nr, 'touchcancel', Br),
                    gs(rr, 'touchstart', Br),
                    ms(gs, nr, 'pointerdown,touchstart,mousedown', Nr),
                    ms(gs, nr, 'pointerup,touchend,mouseup', kr),
                    pr = $i.utils.checkPrefix('transform'),
                    qs.push(pr),
                    tr = Pr(),
                    or = $i.delayedCall(0.2, Hs).pause(),
                    vr = [
                      nr,
                      'visibilitychange',
                      function () {
                        var t = er.innerWidth,
                          e = er.innerHeight
                        nr.hidden
                          ? ((mr = t), (gr = e))
                          : (mr === t && gr === e) || Cs()
                      },
                      nr,
                      'DOMContentLoaded',
                      Hs,
                      er,
                      'load',
                      Hs,
                      er,
                      'resize',
                      Cs,
                    ],
                    jr(gs),
                    Ts.forEach(function (t) {
                      return t.enable(0, 1)
                    }),
                    n = 0;
                  n < Ii.length;
                  n += 3
                )
                  _s(vs, Ii[n], Ii[n + 1]), _s(vs, Ii[n], Ii[n + 2])
              }
            }),
            (t.config = function (e) {
              'limitCallbacks' in e && (Tr = !!e.limitCallbacks)
              var n = e.syncInterval
              ;(n && clearInterval(ur)) || ((ur = n) && setInterval(Ds, n)),
                'ignoreMobileResize' in e &&
                  (wr = 1 === t.isTouch && e.ignoreMobileResize),
                'autoRefreshEvents' in e &&
                  (jr(vs) || jr(gs, e.autoRefreshEvents || 'none'),
                  (xr = -1 === (e.autoRefreshEvents + '').indexOf('resize')))
            }),
            (t.scrollerProxy = function (t, e) {
              var n = qi(t),
                i = Ii.indexOf(n),
                r = Gr(n)
              ~i && Ii.splice(i, r ? 6 : 2),
                e && (r ? Oi.unshift(er, e, rr, e, ir, e) : Oi.unshift(n, e))
            }),
            (t.matchMedia = function (t) {
              var e, n, i, r, s
              for (n in t)
                (i = Ps.indexOf(n)),
                  (r = t[n]),
                  (Dr = n),
                  'all' === n
                    ? r()
                    : (e = er.matchMedia(n)) &&
                      (e.matches && (s = r()),
                      ~i
                        ? ((Ps[i + 1] = Kr(Ps[i + 1], r)),
                          (Ps[i + 2] = Kr(Ps[i + 2], s)))
                        : ((i = Ps.length),
                          Ps.push(n, r, s),
                          e.addListener
                            ? e.addListener(Fs)
                            : e.addEventListener('change', Fs)),
                      (Ps[i + 3] = e.matches)),
                  (Dr = 0)
              return Ps
            }),
            (t.clearMatchMedia = function (t) {
              t || (Ps.length = 0), (t = Ps.indexOf(t)) >= 0 && Ps.splice(t, 4)
            }),
            (t.isInViewport = function (t, e, n) {
              var i = (qr(t) ? qi(t) : t).getBoundingClientRect(),
                r = i[n ? is : rs] * e || 0
              return n
                ? i.right - r > 0 && i.left + r < er.innerWidth
                : i.bottom - r > 0 && i.top + r < er.innerHeight
            }),
            (t.positionInViewport = function (t, e, n) {
              qr(t) && (t = qi(t))
              var i = t.getBoundingClientRect(),
                r = i[n ? is : rs],
                s =
                  null == e
                    ? r / 2
                    : e in bs
                    ? bs[e] * r
                    : ~e.indexOf('%')
                    ? (parseFloat(e) * r) / 100
                    : parseFloat(e) || 0
              return n
                ? (i.left + s) / er.innerWidth
                : (i.top + s) / er.innerHeight
            }),
            t
          )
        })()
      ;(no.version = '3.10.2'),
        (no.saveStyles = function (t) {
          return t
            ? ar(t).forEach(function (t) {
                if (t && t.style) {
                  var e = Ns.indexOf(t)
                  e >= 0 && Ns.splice(e, 5),
                    Ns.push(
                      t,
                      t.style.cssText,
                      t.getBBox && t.getAttribute('transform'),
                      $i.core.getCache(t),
                      Dr,
                    )
                }
              })
            : Ns
        }),
        (no.revert = function (t, e) {
          return Bs(!t, e)
        }),
        (no.create = function (t, e) {
          return new no(t, e)
        }),
        (no.refresh = function (t) {
          return t ? Cs() : (tr || no.register()) && Hs(!0)
        }),
        (no.update = Ws),
        (no.clearScrollMemory = zs),
        (no.maxScroll = function (t, e) {
          return Wr(t, e ? Wi : ji)
        }),
        (no.getScrollFunc = function (t, e) {
          return Xi(qi(t), e ? Wi : ji)
        }),
        (no.getById = function (t) {
          return Es[t]
        }),
        (no.getAll = function () {
          return Ts.filter(function (t) {
            return 'ScrollSmoother' !== t.vars.id
          })
        }),
        (no.isScrolling = function () {
          return !!Ir
        }),
        (no.snapDirectional = fs),
        (no.addEventListener = function (t, e) {
          var n = Ls[t] || (Ls[t] = [])
          ~n.indexOf(e) || n.push(e)
        }),
        (no.removeEventListener = function (t, e) {
          var n = Ls[t],
            i = n && n.indexOf(e)
          i >= 0 && n.splice(i, 1)
        }),
        (no.batch = function (t, e) {
          var n,
            i = [],
            r = {},
            s = e.interval || 0.016,
            o = e.batchMax || 1e9,
            a = function (t, e) {
              var n = [],
                i = [],
                r = $i
                  .delayedCall(s, function () {
                    e(n, i), (n = []), (i = [])
                  })
                  .pause()
              return function (t) {
                n.length || r.restart(!0),
                  n.push(t.trigger),
                  i.push(t),
                  o <= n.length && r.progress(1)
              }
            }
          for (n in e)
            r[n] =
              'on' === n.substr(0, 2) && Xr(e[n]) && 'onRefreshInit' !== n
                ? a(0, e[n])
                : e[n]
          return (
            Xr(o) &&
              ((o = o()),
              gs(no, 'refresh', function () {
                return (o = e.batchMax())
              })),
            ar(t).forEach(function (t) {
              var e = {}
              for (n in r) e[n] = r[n]
              ;(e.trigger = t), i.push(no.create(e))
            }),
            i
          )
        })
      var io = function (t, e, n, i) {
          return (
            e > i ? t(i) : e < 0 && t(0),
            n > i ? (i - e) / (n - e) : n < 0 ? e / (e - n) : 1
          )
        },
        ro = function (t) {
          !0 === t
            ? (rr.style.removeProperty('touch-action'),
              ir.style.removeProperty('touch-action'))
            : (rr.style.touchAction = ir.style.touchAction = t
                ? 'pan-' + t
                : 'none')
        }
      function so(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n]
          ;(i.enumerable = i.enumerable || !1),
            (i.configurable = !0),
            'value' in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i)
        }
      }
      ;(no.sort = function (t) {
        return Ts.sort(
          t ||
            function (t, e) {
              return (
                -1e6 * (t.vars.refreshPriority || 0) +
                t.start -
                (e.start + -1e6 * (e.vars.refreshPriority || 0))
              )
            },
        )
      }),
        (no.observe = function (t) {
          return new Qi(t)
        }),
        (no.normalizeScroll = function (t) {
          if (void 0 === t) return br
          if (!0 === t && br) return br.enable()
          var e = t instanceof Qi
          return (
            br && (!1 === t || (e && t !== br)) && br.kill(),
            t &&
              !e &&
              (t = (function (t) {
                Jr(t) || (t = {}),
                  (t.preventDefault = t.isNormalizer = !0),
                  t.type || (t.type = 'wheel,touch'),
                  (t.debounce = !!t.debounce),
                  (t.id = t.id || 'normalizer')
                var e,
                  n,
                  i,
                  r,
                  s,
                  o,
                  a,
                  l,
                  c,
                  u = t,
                  h = u.normalizeScrollX,
                  d = u.momentum,
                  p = 0,
                  f = Xi(ir, ji),
                  m = Xi(ir, Wi),
                  g = 1,
                  v = Xr(d)
                    ? function () {
                        return d(e)
                      }
                    : function () {
                        return d || 2.8
                      },
                  _ = function () {
                    return (p = Pr())
                  },
                  y = function () {
                    return (i = !1)
                  },
                  x = Br,
                  b = Br,
                  w = function () {
                    ;(n = Wr(ir, ji)),
                      (b = lr(0, n)),
                      h && (x = lr(0, Wr(ir, Wi))),
                      (r = Us)
                  },
                  M =
                    no.isTouch &&
                    /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent),
                  S = function () {
                    w(),
                      s.isActive() &&
                        s.vars.scrollY > n &&
                        s.resetTo('scrollY', Wr(ir, ji))
                  }
                return (
                  (t.ignoreCheck = function (t) {
                    return (
                      (M &&
                        'touchmove' === t.type &&
                        (function () {
                          if (i) return requestAnimationFrame(y), !0
                          i = !0
                        })()) ||
                      g > 1 ||
                      e.isGesturing ||
                      (t.touches && t.touches.length > 1)
                    )
                  }),
                  (t.onPress = function () {
                    var t = g
                    ;(g = (er.visualViewport && er.visualViewport.scale) || 1),
                      s.pause(),
                      t !== g && ro(g > 1 || (!h && 'x')),
                      (i = !1),
                      (o = m()),
                      (a = f()),
                      w(),
                      (r = Us)
                  }),
                  (t.onRelease = t.onGestureStart = function (t, e) {
                    var n = t.event,
                      i = n.changedTouches ? n.changedTouches[0] : n
                    if (
                      !e ||
                      (Math.abs(t.x - t.startX) <= 3 &&
                        Math.abs(t.y - t.startY) <= 3)
                    )
                      $i.delayedCall(0.05, function () {
                        if (Pr() - p > 300 && !n.defaultPrevented)
                          if (n.target.click) n.target.click()
                          else if (l.createEvent) {
                            var t = l.createEvent('MouseEvents')
                            t.initMouseEvent(
                              'click',
                              !0,
                              !0,
                              er,
                              1,
                              i.screenX,
                              i.screenY,
                              i.clientX,
                              i.clientY,
                              !1,
                              !1,
                              !1,
                              !1,
                              0,
                              null,
                            ),
                              n.target.dispatchEvent(t)
                          }
                      }),
                        c.restart(!0)
                    else {
                      var r,
                        o,
                        a = v()
                      h &&
                        ((o =
                          (r = m()) + (0.05 * a * -t.velocityX) / 0.227 / g),
                        (a *= io(m, r, o, Wr(ir, Wi))),
                        (s.vars.scrollX = x(o))),
                        (o = (r = f()) + (0.05 * a * -t.velocityY) / 0.227 / g),
                        (a *= io(f, r, o, Wr(ir, ji))),
                        (s.vars.scrollY = b(o)),
                        s.invalidate().duration(a).play(0.01)
                    }
                  }),
                  (t.onWheel = function () {
                    return s._ts && s.pause()
                  }),
                  (t.onChange = function (t, e, n, i, s) {
                    Us !== r && w(),
                      e &&
                        h &&
                        m(
                          x(
                            i[2] === e
                              ? o + (t.startX - t.x) / g
                              : m() + e - i[1],
                          ),
                        ),
                      n &&
                        f(
                          b(
                            s[2] === n
                              ? a + (t.startY - t.y) / g
                              : f() + n - s[1],
                          ),
                        ),
                      Ws()
                  }),
                  (t.onEnable = function (t) {
                    ro(!h && 'x'),
                      gs(er, 'resize', S),
                      t.target.addEventListener('click', _, { capture: !0 })
                  }),
                  (t.onDisable = function (t) {
                    ro(!0), vs(er, 'resize', S), vs(t.target, 'click', _)
                  }),
                  (e = new Qi(t)),
                  (l = e.target.ownerDocument || nr),
                  (c = e._dc),
                  (s = $i.to(e, {
                    ease: 'power4',
                    paused: !0,
                    scrollX: h ? '+=0.1' : '+=0',
                    scrollY: '+=0.1',
                    onComplete: c.vars.onComplete,
                  })),
                  e
                )
              })(t)),
            (br = t && t.enable())
          )
        }),
        (no.core = {
          _getVelocityProp: Yi,
          _scrollers: Ii,
          _proxies: Oi,
          bridge: {
            ss: function () {
              Ir || Os('scrollStart'), (Ir = Pr())
            },
            ref: function () {
              return hr
            },
          },
        }),
        Hr() && $i.registerPlugin(no)
      var oo,
        ao,
        lo,
        co,
        uo,
        ho,
        po,
        fo,
        mo,
        go,
        vo,
        _o,
        yo = function () {
          return 'undefined' != typeof window
        },
        xo = function () {
          return oo || (yo() && (oo = window.gsap) && oo.registerPlugin && oo)
        },
        bo =
          (Date.now,
          function (t) {
            var e = co.createElement('div')
            return (
              e.classList.add('ScrollSmoother-wrapper'),
              t.parentNode.insertBefore(e, t),
              e.appendChild(t),
              e
            )
          }),
        wo = (function () {
          function t(e) {
            var n = this
            ao ||
              t.register(oo) ||
              console.warn('Please gsap.registerPlugin(ScrollSmoother)'),
              (e = this.vars = e || {}),
              go && go.kill(),
              (go = this)
            var i,
              r,
              s,
              o,
              a,
              l,
              c,
              u,
              h,
              d,
              p,
              f,
              m = mo.getScrollFunc(lo),
              g =
                1 === mo.isTouch
                  ? !0 === e.smoothTouch
                    ? 0.8
                    : parseFloat(e.smoothTouch) || 0
                  : 0 === e.smooth || !1 === e.smooth
                  ? 0
                  : parseFloat(e.smooth) || 0.8,
              v = 0,
              _ = 0,
              y = 1,
              x = e.onUpdate,
              b = e.onStop,
              w = _o(0),
              M = function () {
                return w.update(-v)
              },
              S = { y: 0 },
              T = function () {
                return (i.style.overflow = 'visible')
              },
              E = function (t) {
                var e = t.getTween()
                e && (e.pause(), (e._time = e._dur), (e._tTime = e._tDur)),
                  (p = !1),
                  t.animation.progress(t.progress, !0)
              },
              D = function (t, e) {
                ;((t !== v && !h) || e) &&
                  (g &&
                    (i.style.transform =
                      'matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, ' +
                      t +
                      ', 0, 1)'),
                  (_ = t - v),
                  (v = t),
                  mo.isUpdating || mo.update())
              },
              A = function (t) {
                return arguments.length
                  ? (h && (v = -t), (S.y = -t), (p = !0), m(t), this)
                  : -v
              },
              C = function (t) {
                ;(r.scrollTop = 0),
                  mo.isInViewport(t.target) ||
                    t.target === f ||
                    n.scrollTo(t.target, !1, 'center center'),
                  (f = t.target)
              },
              L = function (t, e) {
                var n, i, r, s
                a.forEach(function (e) {
                  ;(n = e.pins),
                    (s = e.markers),
                    t.forEach(function (t) {
                      ;(t.trigger !== e.trigger &&
                        t.pinnedContainer !== e.trigger) ||
                        e === t ||
                        ((i = t.start),
                        (r =
                          (i - e.start - e.offset) / e.ratio - (i - e.start)),
                        n.forEach(function (t) {
                          return (r -= t.distance / e.ratio - t.distance)
                        }),
                        t.setPositions(i + r, t.end + r),
                        t.markerStart &&
                          s.push(
                            oo.quickSetter(
                              [t.markerStart, t.markerEnd],
                              'y',
                              'px',
                            ),
                          ),
                        t.pin &&
                          t.end > 0 &&
                          ((r = t.end - t.start),
                          n.push({
                            start: t.start,
                            end: t.end,
                            distance: r,
                            trig: t,
                          }),
                          e.setPositions(e.start, e.end + r),
                          e.vars.onRefresh(e)))
                    })
                })
              },
              R = function () {
                T(),
                  requestAnimationFrame(T),
                  a &&
                    (a.forEach(function (t) {
                      var e = t.start,
                        n = t.auto
                          ? Math.min(mo.maxScroll(t.scroller), t.end)
                          : e + (t.end - e) / t.ratio,
                        i = (n - t.end) / 2
                      ;(e -= i),
                        (n -= i),
                        (t.offset = i || 1e-4),
                        (t.pins.length = 0),
                        t.setPositions(Math.min(e, n), Math.max(e, n)),
                        t.vars.onRefresh(t)
                    }),
                    L(mo.sort())),
                  w.reset()
              },
              P = function () {
                return (
                  a &&
                  a.forEach(function (t) {
                    return t.vars.onRefresh(t)
                  })
                )
              },
              F = function () {
                return (
                  a &&
                    a.forEach(function (t) {
                      return t.vars.onRefreshInit(t)
                    }),
                  P
                )
              },
              I = function (t, e, n, i) {
                return function () {
                  var r = 'function' == typeof e ? e(n, i) : e
                  return (
                    r ||
                      0 === r ||
                      (r =
                        i.getAttribute('data-' + t) || ('speed' === t ? 1 : 0)),
                    i.setAttribute('data-' + t, r),
                    'auto' === r ? r : parseFloat(r)
                  )
                }
              },
              O = function (t, e, n, i) {
                var s,
                  o,
                  l,
                  c,
                  u,
                  h,
                  d = I('speed', e, i, t),
                  p = I('lag', n, i, t),
                  f = oo.getProperty(t, 'y'),
                  m = t._gsap,
                  g = function () {
                    ;(e = d()),
                      (n = p()),
                      (s = parseFloat(e) || 1),
                      (u = (l = 'auto' === e) ? 0 : 0.5),
                      c && c.kill(),
                      (c =
                        n &&
                        oo.to(t, {
                          ease: vo,
                          overwrite: !1,
                          y: '+=0',
                          duration: n,
                        })),
                      o && ((o.ratio = s), (o.autoSpeed = l))
                  },
                  v = function () {
                    ;(m.y = f + 'px'), m.renderTransform(1), g()
                  },
                  x = [],
                  b = [],
                  w = 0,
                  M = function (e) {
                    if (l) {
                      v()
                      var n = (function (t, e) {
                        var n,
                          i,
                          r = t.parentNode || uo,
                          s = t.getBoundingClientRect(),
                          o = r.getBoundingClientRect(),
                          a = o.top - s.top,
                          l = o.bottom - s.bottom,
                          c = (Math.abs(a) > Math.abs(l) ? a : l) / (1 - e),
                          u = -c * e
                        return (
                          c > 0 &&
                            ((u +=
                              -(i =
                                0.5 ==
                                (n = o.height / (lo.innerHeight + o.height))
                                  ? 2 * o.height
                                  : 2 *
                                    Math.min(
                                      o.height,
                                      (-c * n) / (2 * n - 1),
                                    )) / 2),
                            (c += i)),
                          { change: c, offset: u }
                        )
                      })(t, fo(0, 1, -e.start / (e.end - e.start)))
                      ;(w = n.change), (h = n.offset)
                    } else (w = (e.end - e.start) * (1 - s)), (h = 0)
                    x.forEach(function (t) {
                      return (w -= t.distance * (1 - s))
                    }),
                      e.vars.onUpdate(e),
                      c && c.progress(1)
                  }
                return (
                  g(),
                  (1 !== s || l || c) &&
                    ((o = mo.create({
                      trigger: l ? t.parentNode : t,
                      scroller: r,
                      scrub: !0,
                      refreshPriority: -999,
                      onRefreshInit: v,
                      onRefresh: M,
                      onKill: function (t) {
                        var e = a.indexOf(t)
                        e >= 0 && a.splice(e, 1)
                      },
                      onUpdate: function (t) {
                        var e,
                          n,
                          i,
                          r,
                          s = f + w * (t.progress - u),
                          o = x.length,
                          a = 0
                        if (t.offset) {
                          if (o) {
                            for (n = -S.y, i = t.end; o--; ) {
                              if (
                                (e = x[o]).trig.isActive ||
                                (n >= e.start && n <= e.end)
                              )
                                return void (
                                  c &&
                                  ((e.trig.progress +=
                                    e.trig.direction < 0 ? 0.001 : -0.001),
                                  e.trig.update(0, 0, 1),
                                  c.resetTo('y', parseFloat(m.y), -_, !0),
                                  y && c.progress(1))
                                )
                              n > e.end && (a += e.distance), (i -= e.distance)
                            }
                            s =
                              f +
                              a +
                              w *
                                ((oo.utils.clamp(t.start, t.end, n) -
                                  t.start -
                                  a) /
                                  (i - t.start) -
                                  u)
                          }
                          ;(r = s + h),
                            (s = Math.round(1e5 * r) / 1e5 || 0),
                            b.length &&
                              !l &&
                              b.forEach(function (t) {
                                return t(s - a)
                              }),
                            c
                              ? (c.resetTo('y', s, -_, !0), y && c.progress(1))
                              : ((m.y = s + 'px'), m.renderTransform(1))
                        }
                      },
                    })),
                    M(o),
                    (oo.core.getCache(o.trigger).stRevert = F),
                    (o.startY = f),
                    (o.pins = x),
                    (o.markers = b),
                    (o.ratio = s),
                    (o.autoSpeed = l),
                    (t.style.willChange = 'transform')),
                  o
                )
              }
            function N() {
              return (
                (s = i.clientHeight),
                (i.style.overflow = 'visible'),
                (ho.style.height = s + 'px'),
                s - lo.innerHeight
              )
            }
            mo.addEventListener('refresh', R),
              oo.delayedCall(0.5, function () {
                return (y = 0)
              }),
              (this.scrollTop = A),
              (this.scrollTo = function (t, e, i) {
                var r = oo.utils.clamp(
                  0,
                  mo.maxScroll(lo),
                  isNaN(t) ? n.offset(t, i) : +t,
                )
                e
                  ? h
                    ? oo.to(n, {
                        duration: g,
                        scrollTop: r,
                        overwrite: 'auto',
                        ease: vo,
                      })
                    : m(r)
                  : A(r)
              }),
              (this.offset = function (t, e) {
                t = po(t)[0]
                var n,
                  i = oo.getProperty(t, 'y'),
                  r = mo.create({ trigger: t, start: e || 'top top' })
                return (
                  a && L([r]), (n = r.start), r.kill(!1), oo.set(t, { y: i }), n
                )
              }),
              (this.content = function (t) {
                return arguments.length
                  ? ((i = po(t || '#smooth-content')[0] || ho.children[0]),
                    (u = i.getAttribute('style') || ''),
                    oo.set(i, { overflow: 'visible', width: '100%' }),
                    this)
                  : i
              }),
              (this.wrapper = function (t) {
                return arguments.length
                  ? ((r = po(t || '#smooth-wrapper')[0] || bo(i)),
                    (c = r.getAttribute('style') || ''),
                    N(),
                    oo.set(
                      r,
                      g
                        ? {
                            overflow: 'hidden',
                            position: 'fixed',
                            height: '100%',
                            width: '100%',
                            top: 0,
                            left: 0,
                            right: 0,
                            bottom: 0,
                          }
                        : {
                            overflow: 'visible',
                            position: 'relative',
                            width: '100%',
                            height: 'auto',
                            top: 'auto',
                            bottom: 'auto',
                            left: 'auto',
                            right: 'auto',
                          },
                    ),
                    this)
                  : r
              }),
              (this.effects = function (t, e) {
                var n
                if ((a || (a = []), !t)) return a.slice(0)
                ;(t = po(t)).forEach(function (t) {
                  for (var e = a.length; e--; )
                    a[e].trigger === t && (a[e].kill(), a.splice(e, 1))
                })
                var i,
                  r,
                  s = (e = e || {}),
                  o = s.speed,
                  l = s.lag,
                  c = []
                for (i = 0; i < t.length; i++)
                  (r = O(t[i], o, l, i)) && c.push(r)
                return (n = a).push.apply(n, c), c
              }),
              this.content(e.content),
              this.wrapper(e.wrapper),
              (this.render = function (t) {
                return D(t || 0 === t ? t : v)
              }),
              (this.getVelocity = function () {
                return w.getVelocity(-v)
              }),
              mo.scrollerProxy(r, {
                scrollTop: A,
                scrollHeight: function () {
                  return ho.scrollHeight
                },
                fixedMarkers: !1 !== e.fixedMarkers && !!g,
                content: i,
                getBoundingClientRect: function () {
                  return {
                    top: 0,
                    left: 0,
                    width: lo.innerWidth,
                    height: lo.innerHeight,
                  }
                },
              }),
              mo.defaults({ scroller: r })
            var k = mo.getAll().filter(function (t) {
              return t.scroller === lo || t.scroller === r
            })
            k.forEach(function (t) {
              return t.revert(!0)
            }),
              (o = mo.create({
                animation: oo.to(S, {
                  y: function () {
                    return lo.innerHeight - s
                  },
                  ease: 'none',
                  data: 'ScrollSmoother',
                  duration: 100,
                  onUpdate: function () {
                    var t = p
                    t && ((S.y = v), E(o)), D(S.y, t), M(), x && !h && x(n)
                  },
                }),
                onRefreshInit: function () {
                  return (S.y = 0)
                },
                id: 'ScrollSmoother',
                scroller: lo,
                invalidateOnRefresh: !0,
                start: 0,
                refreshPriority: -9999,
                end: N,
                onScrubComplete: function () {
                  w.reset(), b && b(n)
                },
                scrub: g || !0,
                onRefresh: function (t) {
                  E(t), D(S.y)
                },
              })),
              (this.smooth = function (t) {
                return (
                  (g = t),
                  arguments.length
                    ? o.scrubDuration(t)
                    : o.getTween()
                    ? o.getTween().duration()
                    : 0
                )
              }),
              o.getTween() && (o.getTween().vars.ease = e.ease || vo),
              (this.scrollTrigger = o),
              e.effects &&
                this.effects(
                  !0 === e.effects ? '[data-speed], [data-lag]' : e.effects,
                  {},
                ),
              k.forEach(function (t) {
                ;(t.vars.scroller = r), t.init(t.vars, t.animation)
              }),
              (this.paused = function (t) {
                return arguments.length
                  ? (!!h !== t &&
                      (t
                        ? (o.getTween() && o.getTween().pause(),
                          m(-v),
                          w.reset(),
                          (d = mo.normalizeScroll()) && d.disable(),
                          (h = mo.observe({
                            preventDefault: !0,
                            type: 'wheel,touch,scroll',
                            debounce: !1,
                            onChangeY: function () {
                              return A(-v)
                            },
                          })))
                        : (h.kill(),
                          (h = 0),
                          d && d.enable(),
                          (o.progress = (-v - o.start) / (o.end - o.start)),
                          E(o))),
                    this)
                  : !!h
              }),
              (this.kill = function () {
                n.paused(!1), E(o), o.kill()
                for (var t = a ? a.length : 0; t--; ) a[t].kill()
                mo.scrollerProxy(r),
                  mo.removeEventListener('refresh', R),
                  (r.style.cssText = c),
                  (i.style.cssText = u)
                var e = mo.defaults({})
                e && e.scroller === r && mo.defaults({ scroller: lo }),
                  n.observer && mo.normalizeScroll(!1),
                  clearInterval(l),
                  (go = null),
                  lo.removeEventListener('focusin', C)
              }),
              e.normalizeScroll &&
                (this.observer = mo.normalizeScroll({ debounce: !0 })),
              mo.config(e),
              'overscrollBehavior' in lo.getComputedStyle(ho) &&
                oo.set(ho, { overscrollBehavior: 'none' }),
              lo.addEventListener('focusin', C),
              (l = setInterval(M, 250)),
              'loading' === co.readyState ||
                requestAnimationFrame(function () {
                  return mo.refresh()
                })
          }
          var e, n
          return (
            (t.register = function (e) {
              return (
                ao ||
                  ((oo = e || xo()),
                  yo() &&
                    window.document &&
                    ((lo = window),
                    (co = document),
                    (uo = co.documentElement),
                    (ho = co.body)),
                  oo &&
                    ((po = oo.utils.toArray),
                    (fo = oo.utils.clamp),
                    (vo = oo.parseEase('expo')),
                    (mo = oo.core.globals().ScrollTrigger),
                    oo.core.globals('ScrollSmoother', t),
                    ho && mo && ((_o = mo.core._getVelocityProp), (ao = 1)))),
                ao
              )
            }),
            (e = t),
            (n = [
              {
                key: 'progress',
                get: function () {
                  return this.scrollTrigger.animation._time / 100
                },
              },
            ]) && so(e.prototype, n),
            t
          )
        })()
      ;(wo.version = '3.10.2'),
        (wo.create = function (t) {
          return go && t && go.content() === po(t.content)[0] ? go : new wo(t)
        }),
        (wo.get = function () {
          return go
        }),
        xo() && oo.registerPlugin(wo)
      var Mo = /(^\s+|\s+$)/g,
        So = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/
      function To(t) {
        var e = t.nodeType,
          n = ''
        if (1 === e || 9 === e || 11 === e) {
          if ('string' == typeof t.textContent) return t.textContent
          for (t = t.firstChild; t; t = t.nextSibling) n += To(t)
        } else if (3 === e || 4 === e) return t.nodeValue
        return n
      }
      function Eo(t, e, n, i) {
        if (((t += ''), n && (t = t.replace(Mo, '')), e && '' !== e))
          return t.replace(/>/g, '&gt;').replace(/</g, '&lt;').split(e)
        for (var r, s, o = [], a = t.length, l = 0; l < a; l++)
          (((s = t.charAt(l)).charCodeAt(0) >= 55296 &&
            s.charCodeAt(0) <= 56319) ||
            (t.charCodeAt(l + 1) >= 65024 && t.charCodeAt(l + 1) <= 65039)) &&
            ((r = ((t.substr(l, 12).split(So) || [])[1] || '').length || 2),
            (s = t.substr(l, r)),
            (o.emoji = 1),
            (l += r - 1)),
            o.push(
              '>' === s
                ? '&gt;'
                : '<' === s
                ? '&lt;'
                : !i ||
                  ' ' !== s ||
                  (' ' !== t.charAt(l - 1) && ' ' !== t.charAt(l + 1))
                ? s
                : '&nbsp;',
            )
        return o
      }
      var Do,
        Ao,
        Co,
        Lo = /(?:\r|\n|\t\t)/g,
        Ro = /(?:\s\s+)/g,
        Po = function (t) {
          return Ao.getComputedStyle(t)
        },
        Fo = Array.isArray,
        Io = [].slice,
        Oo = function (t, e) {
          var n
          return Fo(t)
            ? t
            : 'string' == (n = typeof t) && !e && t
            ? Io.call(Do.querySelectorAll(t), 0)
            : t && 'object' === n && 'length' in t
            ? Io.call(t, 0)
            : t
            ? [t]
            : []
        },
        No = function (t) {
          return 'absolute' === t.position || !0 === t.absolute
        },
        ko = function (t, e) {
          for (var n, i = e.length; --i > -1; )
            if (((n = e[i]), t.substr(0, n.length) === n)) return n.length
        },
        Bo = function (t, e) {
          void 0 === t && (t = '')
          var n = ~t.indexOf('++'),
            i = 1
          return (
            n && (t = t.split('++').join('')),
            function () {
              return (
                '<' +
                e +
                " style='position:relative;display:inline-block;'" +
                (t ? " class='" + t + (n ? i++ : '') + "'>" : '>')
              )
            }
          )
        },
        zo = function t(e, n, i) {
          var r = e.nodeType
          if (1 === r || 9 === r || 11 === r)
            for (e = e.firstChild; e; e = e.nextSibling) t(e, n, i)
          else
            (3 !== r && 4 !== r) || (e.nodeValue = e.nodeValue.split(n).join(i))
        },
        Uo = function (t, e) {
          for (var n = e.length; --n > -1; ) t.push(e[n])
        },
        Ho = function (t, e, n) {
          for (var i; t && t !== e; ) {
            if ((i = t._next || t.nextSibling))
              return i.textContent.charAt(0) === n
            t = t.parentNode || t._parent
          }
        },
        Go = function t(e) {
          var n,
            i,
            r = Oo(e.childNodes),
            s = r.length
          for (n = 0; n < s; n++)
            (i = r[n])._isSplit
              ? t(i)
              : n && i.previousSibling && 3 === i.previousSibling.nodeType
              ? ((i.previousSibling.nodeValue +=
                  3 === i.nodeType ? i.nodeValue : i.firstChild.nodeValue),
                e.removeChild(i))
              : 3 !== i.nodeType &&
                (e.insertBefore(i.firstChild, i), e.removeChild(i))
        },
        Vo = function (t, e) {
          return parseFloat(e[t]) || 0
        },
        Wo = function (t, e, n, i, r, s, o) {
          var a,
            l,
            c,
            u,
            h,
            d,
            p,
            f,
            m,
            g,
            v,
            _,
            y = Po(t),
            x = Vo('paddingLeft', y),
            b = -999,
            w = Vo('borderBottomWidth', y) + Vo('borderTopWidth', y),
            M = Vo('borderLeftWidth', y) + Vo('borderRightWidth', y),
            S = Vo('paddingTop', y) + Vo('paddingBottom', y),
            T = Vo('paddingLeft', y) + Vo('paddingRight', y),
            E = Vo('fontSize', y) * (e.lineThreshold || 0.2),
            D = y.textAlign,
            A = [],
            C = [],
            L = [],
            R = e.wordDelimiter || ' ',
            P = e.tag ? e.tag : e.span ? 'span' : 'div',
            F = e.type || e.split || 'chars,words,lines',
            I = r && ~F.indexOf('lines') ? [] : null,
            O = ~F.indexOf('words'),
            N = ~F.indexOf('chars'),
            k = No(e),
            B = e.linesClass,
            z = ~(B || '').indexOf('++'),
            U = [],
            H = 'flex' === y.display,
            G = t.style.display
          for (
            z && (B = B.split('++').join('')),
              H && (t.style.display = 'block'),
              c = (l = t.getElementsByTagName('*')).length,
              h = [],
              a = 0;
            a < c;
            a++
          )
            h[a] = l[a]
          if (I || k)
            for (a = 0; a < c; a++)
              ((d = (u = h[a]).parentNode === t) || k || (N && !O)) &&
                ((_ = u.offsetTop),
                I &&
                  d &&
                  Math.abs(_ - b) > E &&
                  ('BR' !== u.nodeName || 0 === a) &&
                  ((p = []), I.push(p), (b = _)),
                k &&
                  ((u._x = u.offsetLeft),
                  (u._y = _),
                  (u._w = u.offsetWidth),
                  (u._h = u.offsetHeight)),
                I &&
                  (((u._isSplit && d) ||
                    (!N && d) ||
                    (O && d) ||
                    (!O &&
                      u.parentNode.parentNode === t &&
                      !u.parentNode._isSplit)) &&
                    (p.push(u), (u._x -= x), Ho(u, t, R) && (u._wordEnd = !0)),
                  'BR' === u.nodeName &&
                    ((u.nextSibling && 'BR' === u.nextSibling.nodeName) ||
                      0 === a) &&
                    I.push([])))
          for (a = 0; a < c; a++)
            if (((d = (u = h[a]).parentNode === t), 'BR' !== u.nodeName))
              if (
                (k &&
                  ((m = u.style),
                  O ||
                    d ||
                    ((u._x += u.parentNode._x), (u._y += u.parentNode._y)),
                  (m.left = u._x + 'px'),
                  (m.top = u._y + 'px'),
                  (m.position = 'absolute'),
                  (m.display = 'block'),
                  (m.width = u._w + 1 + 'px'),
                  (m.height = u._h + 'px')),
                !O && N)
              )
                if (u._isSplit)
                  for (
                    u._next = l = u.nextSibling, u.parentNode.appendChild(u);
                    l && 3 === l.nodeType && ' ' === l.textContent;

                  )
                    (u._next = l.nextSibling),
                      u.parentNode.appendChild(l),
                      (l = l.nextSibling)
                else
                  u.parentNode._isSplit
                    ? ((u._parent = u.parentNode),
                      !u.previousSibling &&
                        u.firstChild &&
                        (u.firstChild._isFirst = !0),
                      u.nextSibling &&
                        ' ' === u.nextSibling.textContent &&
                        !u.nextSibling.nextSibling &&
                        U.push(u.nextSibling),
                      (u._next =
                        u.nextSibling && u.nextSibling._isFirst
                          ? null
                          : u.nextSibling),
                      u.parentNode.removeChild(u),
                      h.splice(a--, 1),
                      c--)
                    : d ||
                      ((_ = !u.nextSibling && Ho(u.parentNode, t, R)),
                      u.parentNode._parent &&
                        u.parentNode._parent.appendChild(u),
                      _ && u.parentNode.appendChild(Do.createTextNode(' ')),
                      'span' === P && (u.style.display = 'inline'),
                      A.push(u))
              else
                u.parentNode._isSplit && !u._isSplit && '' !== u.innerHTML
                  ? C.push(u)
                  : N &&
                    !u._isSplit &&
                    ('span' === P && (u.style.display = 'inline'), A.push(u))
            else
              I || k
                ? (u.parentNode && u.parentNode.removeChild(u),
                  h.splice(a--, 1),
                  c--)
                : O || t.appendChild(u)
          for (a = U.length; --a > -1; ) U[a].parentNode.removeChild(U[a])
          if (I) {
            for (
              k &&
                ((g = Do.createElement(P)),
                t.appendChild(g),
                (v = g.offsetWidth + 'px'),
                (_ = g.offsetParent === t ? 0 : t.offsetLeft),
                t.removeChild(g)),
                m = t.style.cssText,
                t.style.cssText = 'display:none;';
              t.firstChild;

            )
              t.removeChild(t.firstChild)
            for (
              f = ' ' === R && (!k || (!O && !N)), a = 0;
              a < I.length;
              a++
            ) {
              for (
                p = I[a],
                  (g = Do.createElement(P)).style.cssText =
                    'display:block;text-align:' +
                    D +
                    ';position:' +
                    (k ? 'absolute;' : 'relative;'),
                  B && (g.className = B + (z ? a + 1 : '')),
                  L.push(g),
                  c = p.length,
                  l = 0;
                l < c;
                l++
              )
                'BR' !== p[l].nodeName &&
                  ((u = p[l]),
                  g.appendChild(u),
                  f && u._wordEnd && g.appendChild(Do.createTextNode(' ')),
                  k &&
                    (0 === l &&
                      ((g.style.top = u._y + 'px'),
                      (g.style.left = x + _ + 'px')),
                    (u.style.top = '0px'),
                    _ && (u.style.left = u._x - _ + 'px')))
              0 === c
                ? (g.innerHTML = '&nbsp;')
                : O || N || (Go(g), zo(g, String.fromCharCode(160), ' ')),
                k && ((g.style.width = v), (g.style.height = u._h + 'px')),
                t.appendChild(g)
            }
            t.style.cssText = m
          }
          k &&
            (o > t.clientHeight &&
              ((t.style.height = o - S + 'px'),
              t.clientHeight < o && (t.style.height = o + w + 'px')),
            s > t.clientWidth &&
              ((t.style.width = s - T + 'px'),
              t.clientWidth < s && (t.style.width = s + M + 'px'))),
            H &&
              (G ? (t.style.display = G) : t.style.removeProperty('display')),
            Uo(n, A),
            O && Uo(i, C),
            Uo(r, L)
        },
        jo = function t(e, n, i, r) {
          var s,
            o,
            a = Oo(e.childNodes),
            l = a.length,
            c = No(n)
          if (3 !== e.nodeType || l > 1) {
            for (n.absolute = !1, s = 0; s < l; s++)
              ((o = a[s])._next = o._isFirst = o._parent = o._wordEnd = null),
                (3 !== o.nodeType || /\S+/.test(o.nodeValue)) &&
                  (c &&
                    3 !== o.nodeType &&
                    'inline' === Po(o).display &&
                    ((o.style.display = 'inline-block'),
                    (o.style.position = 'relative')),
                  (o._isSplit = !0),
                  t(o, n, i, r))
            return (n.absolute = c), void (e._isSplit = !0)
          }
          !(function (t, e, n, i) {
            var r,
              s,
              o,
              a,
              l,
              c,
              u,
              h,
              d = e.tag ? e.tag : e.span ? 'span' : 'div',
              p = ~(e.type || e.split || 'chars,words,lines').indexOf('chars'),
              f = No(e),
              m = e.wordDelimiter || ' ',
              g = ' ' !== m ? '' : f ? '&#173; ' : ' ',
              v = '</' + d + '>',
              _ = 1,
              y = e.specialChars
                ? 'function' == typeof e.specialChars
                  ? e.specialChars
                  : ko
                : null,
              x = Do.createElement('div'),
              b = t.parentNode
            for (
              b.insertBefore(x, t),
                x.textContent = t.nodeValue,
                b.removeChild(t),
                u = -1 !== (r = To((t = x))).indexOf('<'),
                !1 !== e.reduceWhiteSpace &&
                  (r = r.replace(Ro, ' ').replace(Lo, '')),
                u && (r = r.split('<').join('{{LT}}')),
                l = r.length,
                s = (' ' === r.charAt(0) ? g : '') + n(),
                o = 0;
              o < l;
              o++
            )
              if (
                ((c = r.charAt(o)), y && (h = y(r.substr(o), e.specialChars)))
              )
                (c = r.substr(o, h || 1)),
                  (s += p && ' ' !== c ? i() + c + '</' + d + '>' : c),
                  (o += h - 1)
              else if (c === m && r.charAt(o - 1) !== m && o) {
                for (s += _ ? v : '', _ = 0; r.charAt(o + 1) === m; )
                  (s += g), o++
                o === l - 1
                  ? (s += g)
                  : ')' !== r.charAt(o + 1) && ((s += g + n()), (_ = 1))
              } else
                '{' === c && '{{LT}}' === r.substr(o, 6)
                  ? ((s += p ? i() + '{{LT}}</' + d + '>' : '{{LT}}'), (o += 5))
                  : (c.charCodeAt(0) >= 55296 && c.charCodeAt(0) <= 56319) ||
                    (r.charCodeAt(o + 1) >= 65024 &&
                      r.charCodeAt(o + 1) <= 65039)
                  ? ((a =
                      ((r.substr(o, 12).split(So) || [])[1] || '').length || 2),
                    (s +=
                      p && ' ' !== c
                        ? i() + r.substr(o, a) + '</' + d + '>'
                        : r.substr(o, a)),
                    (o += a - 1))
                  : (s += p && ' ' !== c ? i() + c + '</' + d + '>' : c)
            ;(t.outerHTML = s + (_ ? v : '')), u && zo(b, '{{LT}}', '<')
          })(e, n, i, r)
        },
        qo = (function () {
          function t(t, e) {
            Co || ((Do = document), (Ao = window), (Co = 1)),
              (this.elements = Oo(t)),
              (this.chars = []),
              (this.words = []),
              (this.lines = []),
              (this._originals = []),
              (this.vars = e || {}),
              this.split(e)
          }
          var e = t.prototype
          return (
            (e.split = function (t) {
              this.isSplit && this.revert(),
                (this.vars = t = t || this.vars),
                (this._originals.length = this.chars.length = this.words.length = this.lines.length = 0)
              for (
                var e,
                  n,
                  i,
                  r = this.elements.length,
                  s = t.tag ? t.tag : t.span ? 'span' : 'div',
                  o = Bo(t.wordsClass, s),
                  a = Bo(t.charsClass, s);
                --r > -1;

              )
                (i = this.elements[r]),
                  (this._originals[r] = i.innerHTML),
                  (e = i.clientHeight),
                  (n = i.clientWidth),
                  jo(i, t, o, a),
                  Wo(i, t, this.chars, this.words, this.lines, n, e)
              return (
                this.chars.reverse(),
                this.words.reverse(),
                this.lines.reverse(),
                (this.isSplit = !0),
                this
              )
            }),
            (e.revert = function () {
              var t = this._originals
              if (!t) throw "revert() call wasn't scoped properly."
              return (
                this.elements.forEach(function (e, n) {
                  return (e.innerHTML = t[n])
                }),
                (this.chars = []),
                (this.words = []),
                (this.lines = []),
                (this.isSplit = !1),
                this
              )
            }),
            (t.create = function (e, n) {
              return new t(e, n)
            }),
            t
          )
        })()
      qo.version = '3.10.2'
      var Xo,
        Yo,
        Jo = (function () {
          function t(t) {
            ;(this.chars = Eo(t)), (this.sets = []), (this.length = 50)
            for (var e = 0; e < 20; e++) this.sets[e] = Qo(80, this.chars)
          }
          return (
            (t.prototype.grow = function (t) {
              for (var e = 0; e < 20; e++)
                this.sets[e] += Qo(t - this.length, this.chars)
              this.length = t
            }),
            t
          )
        })(),
        Zo = function () {
          return (
            Xo ||
            ('undefined' != typeof window &&
              (Xo = window.gsap) &&
              Xo.registerPlugin &&
              Xo)
          )
        },
        Ko = /\s+/g,
        Qo = function (t, e) {
          for (var n = e.length, i = ''; --t > -1; )
            i += e[~~(Math.random() * n)]
          return i
        },
        $o = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
        ta = $o.toLowerCase(),
        ea = {
          upperCase: new Jo($o),
          lowerCase: new Jo(ta),
          upperAndLowerCase: new Jo($o + ta),
        },
        na = function () {
          Yo = Xo = Zo()
        },
        ia = {
          version: '3.10.2',
          name: 'scrambleText',
          register: function (t, e, n) {
            ;(Xo = t), na()
          },
          init: function (t, e, n, i, r) {
            if (
              (Yo || na(),
              (this.prop =
                'innerHTML' in t
                  ? 'innerHTML'
                  : 'textContent' in t
                  ? 'textContent'
                  : 0),
              this.prop)
            ) {
              ;(this.target = t), 'object' != typeof e && (e = { text: e })
              var s,
                o,
                a,
                l,
                c = e.text || e.value || '',
                u = !1 !== e.trim,
                h = this
              return (
                (h.delimiter = s = e.delimiter || ''),
                (h.original = Eo(
                  To(t).replace(Ko, ' ').split('&nbsp;').join(''),
                  s,
                  u,
                )),
                ('{original}' !== c && !0 !== c && null != c) ||
                  (c = h.original.join(s)),
                (h.text = Eo((c || '').replace(Ko, ' '), s, u)),
                (h.hasClass = !(!e.newClass && !e.oldClass)),
                (h.newClass = e.newClass),
                (h.oldClass = e.oldClass),
                (l = '' === s),
                (h.textHasEmoji = l && !!h.text.emoji),
                (h.charsHaveEmoji = !!e.chars && !!Eo(e.chars).emoji),
                (h.length = l ? h.original.length : h.original.join(s).length),
                (h.lengthDif =
                  (l ? h.text.length : h.text.join(s).length) - h.length),
                (h.fillChar =
                  e.fillChar || (e.chars && ~e.chars.indexOf(' '))
                    ? '&nbsp;'
                    : ''),
                (h.charSet = a = ea[e.chars || 'upperCase'] || new Jo(e.chars)),
                (h.speed = 0.05 / (e.speed || 1)),
                (h.prevScrambleTime = 0),
                (h.setIndex = (20 * Math.random()) | 0),
                (o = h.length + Math.max(h.lengthDif, 0)) > a.length &&
                  a.grow(o),
                (h.chars = a.sets[h.setIndex]),
                (h.revealDelay = e.revealDelay || 0),
                (h.tweenLength = !1 !== e.tweenLength),
                (h.tween = n),
                (h.rightToLeft = !!e.rightToLeft),
                h._props.push('scrambleText', 'text'),
                1
              )
            }
          },
          render: function (t, e) {
            var n,
              i,
              r,
              s,
              o,
              a,
              l,
              c,
              u,
              h,
              d,
              p = e.target,
              f = e.prop,
              m = e.text,
              g = e.delimiter,
              v = e.tween,
              _ = e.prevScrambleTime,
              y = e.revealDelay,
              x = e.setIndex,
              b = e.chars,
              w = e.charSet,
              M = e.length,
              S = e.textHasEmoji,
              T = e.charsHaveEmoji,
              E = e.lengthDif,
              D = e.tweenLength,
              A = e.oldClass,
              C = e.newClass,
              L = e.rightToLeft,
              R = e.fillChar,
              P = e.speed,
              F = e.original,
              I = e.hasClass,
              O = m.length,
              N = v._time,
              k = N - _
            y &&
              (v._from && (N = v._dur - N),
              (t =
                0 === N
                  ? 0
                  : N < y
                  ? 1e-6
                  : N === v._dur
                  ? 1
                  : v._ease((N - y) / (v._dur - y)))),
              t < 0 ? (t = 0) : t > 1 && (t = 1),
              L && (t = 1 - t),
              (n = ~~(t * O + 0.5)),
              t
                ? ((k > P || k < -P) &&
                    ((e.setIndex = x = (x + ((19 * Math.random()) | 0)) % 20),
                    (e.chars = w.sets[x]),
                    (e.prevScrambleTime += k)),
                  (s = b))
                : (s = F.join(g)),
              (d = v._from ? t : 1 - t),
              (h = M + (D ? (v._from ? d * d * d : 1 - d * d * d) : 1) * E),
              L
                ? 1 !== t || (!v._from && 'isFromStart' !== v.data)
                  ? ((l = m.slice(n).join(g)),
                    (r = T
                      ? Eo(s)
                          .slice(0, (h - (S ? Eo(l) : l).length + 0.5) | 0)
                          .join('')
                      : s.substr(0, (h - (S ? Eo(l) : l).length + 0.5) | 0)),
                    (s = l))
                  : ((r = ''), (s = F.join(g)))
                : ((r = m.slice(0, n).join(g)),
                  (i = (S ? Eo(r) : r).length),
                  (s = T
                    ? Eo(s)
                        .slice(i, (h + 0.5) | 0)
                        .join('')
                    : s.substr(i, (h - i + 0.5) | 0))),
              (l = I
                ? ((o = (c = L ? A : C) && 0 !== n)
                    ? "<span class='" + c + "'>"
                    : '') +
                  r +
                  (o ? '</span>' : '') +
                  ((a = (u = L ? C : A) && n !== O)
                    ? "<span class='" + u + "'>"
                    : '') +
                  g +
                  s +
                  (a ? '</span>' : '')
                : r + g + s),
              (p[f] =
                '&nbsp;' === R && ~l.indexOf('  ')
                  ? l.split('  ').join('&nbsp;&nbsp;')
                  : l)
          },
        }
      ;(ia.emojiSafeSplit = Eo),
        (ia.getText = To),
        Zo() && Xo.registerPlugin(ia)
      var ra = n(347),
        sa = n.n(ra),
        oa = n(856),
        aa = n.n(oa)
      function la() {}
      la.prototype = {
        on: function (t, e, n) {
          var i = this.e || (this.e = {})
          return (i[t] || (i[t] = [])).push({ fn: e, ctx: n }), this
        },
        once: function (t, e, n) {
          var i = this
          function r() {
            i.off(t, r), e.apply(n, arguments)
          }
          return (r._ = e), this.on(t, r, n)
        },
        emit: function (t) {
          for (
            var e = [].slice.call(arguments, 1),
              n = ((this.e || (this.e = {}))[t] || []).slice(),
              i = 0,
              r = n.length;
            i < r;
            i++
          )
            n[i].fn.apply(n[i].ctx, e)
          return this
        },
        off: function (t, e) {
          var n = this.e || (this.e = {}),
            i = n[t],
            r = []
          if (i && e)
            for (var s = 0, o = i.length; s < o; s++)
              i[s].fn !== e && i[s].fn._ !== e && r.push(i[s])
          return r.length ? (n[t] = r) : delete n[t], this
        },
      }
      var ca = la
      ca.TinyEmitter = la
      var ua = function (t) {
        ;(this.wrap = document.querySelector('[data-router-wrapper]')),
          (this.properties = t),
          (this.Transition = t.transition
            ? new t.transition.class(this.wrap, t.transition.name)
            : null)
      }
      ;(ua.prototype.setup = function () {
        this.onEnter && this.onEnter(),
          this.onEnterCompleted && this.onEnterCompleted()
      }),
        (ua.prototype.add = function () {
          this.wrap.insertAdjacentHTML(
            'beforeend',
            this.properties.view.outerHTML,
          )
        }),
        (ua.prototype.update = function () {
          document.title = this.properties.page.title
        }),
        (ua.prototype.show = function (t) {
          var e = this
          return new Promise(function (n) {
            try {
              function i(t) {
                e.onEnterCompleted && e.onEnterCompleted(), n()
              }
              return (
                e.update(),
                e.onEnter && e.onEnter(),
                Promise.resolve(
                  e.Transition
                    ? Promise.resolve(e.Transition.show(t)).then(i)
                    : i(),
                )
              )
            } catch (t) {
              return Promise.reject(t)
            }
          })
        }),
        (ua.prototype.hide = function (t) {
          var e = this
          return new Promise(function (n) {
            try {
              function i(t) {
                e.onLeaveCompleted && e.onLeaveCompleted(), n()
              }
              return (
                e.onLeave && e.onLeave(),
                Promise.resolve(
                  e.Transition
                    ? Promise.resolve(e.Transition.hide(t)).then(i)
                    : i(),
                )
              )
            } catch (t) {
              return Promise.reject(t)
            }
          })
        })
      var ha = new window.DOMParser(),
        da = function (t, e) {
          ;(this.renderers = t), (this.transitions = e)
        }
      ;(da.prototype.getOrigin = function (t) {
        var e = t.match(/(https?:\/\/[\w\-.]+)/)
        return e ? e[1].replace(/https?:\/\//, '') : null
      }),
        (da.prototype.getPathname = function (t) {
          var e = t.match(/https?:\/\/.*?(\/[\w_\-./]+)/)
          return e ? e[1] : '/'
        }),
        (da.prototype.getAnchor = function (t) {
          var e = t.match(/(#.*)$/)
          return e ? e[1] : null
        }),
        (da.prototype.getParams = function (t) {
          var e = t.match(/\?([\w_\-.=&]+)/)
          if (!e) return null
          for (var n = e[1].split('&'), i = {}, r = 0; r < n.length; r++) {
            var s = n[r].split('=')
            i[s[0]] = s[1]
          }
          return i
        }),
        (da.prototype.getDOM = function (t) {
          return 'string' == typeof t ? ha.parseFromString(t, 'text/html') : t
        }),
        (da.prototype.getView = function (t) {
          return t.querySelector('[data-router-view]')
        }),
        (da.prototype.getSlug = function (t) {
          return t.getAttribute('data-router-view')
        }),
        (da.prototype.getRenderer = function (t) {
          if (!this.renderers) return Promise.resolve(ua)
          if (t in this.renderers) {
            var e = this.renderers[t]
            return 'function' != typeof e || ua.isPrototypeOf(e)
              ? 'function' == typeof e.then
                ? Promise.resolve(e).then(function (t) {
                    return t.default
                  })
                : Promise.resolve(e)
              : Promise.resolve(e()).then(function (t) {
                  return t.default
                })
          }
          return Promise.resolve(ua)
        }),
        (da.prototype.getTransition = function (t) {
          return this.transitions
            ? t in this.transitions
              ? { class: this.transitions[t], name: t }
              : 'default' in this.transitions
              ? { class: this.transitions.default, name: 'default' }
              : null
            : null
        }),
        (da.prototype.getProperties = function (t) {
          var e = this.getDOM(t),
            n = this.getView(e),
            i = this.getSlug(n)
          return {
            page: e,
            view: n,
            slug: i,
            renderer: this.getRenderer(i, this.renderers),
            transition: this.getTransition(i, this.transitions),
          }
        }),
        (da.prototype.getLocation = function (t) {
          return {
            href: t,
            anchor: this.getAnchor(t),
            origin: this.getOrigin(t),
            params: this.getParams(t),
            pathname: this.getPathname(t),
          }
        })
      var pa = (function (t) {
          function e(e) {
            var n = this
            void 0 === e && (e = {})
            var i = e.renderers,
              r = e.transitions
            t.call(this),
              (this.Helpers = new da(i, r)),
              (this.Transitions = r),
              (this.Contextual = !1),
              (this.location = this.Helpers.getLocation(window.location.href)),
              (this.properties = this.Helpers.getProperties(
                document.cloneNode(!0),
              )),
              (this.popping = !1),
              (this.running = !1),
              (this.trigger = null),
              (this.cache = new Map()),
              this.cache.set(this.location.href, this.properties),
              this.properties.renderer.then(function (t) {
                ;(n.From = new t(n.properties)), n.From.setup()
              }),
              (this._navigate = this.navigate.bind(this)),
              window.addEventListener('popstate', this.popState.bind(this)),
              (this.links = document.querySelectorAll(
                'a:not([target]):not([data-router-disabled])',
              )),
              this.attach(this.links)
          }
          return (
            t && (e.__proto__ = t),
            ((e.prototype = Object.create(t && t.prototype)).constructor = e),
            (e.prototype.attach = function (t) {
              for (var e = 0, n = t; e < n.length; e += 1)
                n[e].addEventListener('click', this._navigate)
            }),
            (e.prototype.detach = function (t) {
              for (var e = 0, n = t; e < n.length; e += 1)
                n[e].removeEventListener('click', this._navigate)
            }),
            (e.prototype.navigate = function (t) {
              if (!t.metaKey && !t.ctrlKey) {
                t.preventDefault()
                var e =
                  !!t.currentTarget.hasAttribute('data-transition') &&
                  t.currentTarget.dataset.transition
                this.redirect(t.currentTarget.href, e, t.currentTarget)
              }
            }),
            (e.prototype.redirect = function (t, e, n) {
              if (
                (void 0 === e && (e = !1),
                void 0 === n && (n = 'script'),
                (this.trigger = n),
                !this.running && t !== this.location.href)
              ) {
                var i = this.Helpers.getLocation(t)
                ;(this.Contextual = !1),
                  e &&
                    ((this.Contextual = this.Transitions.contextual[
                      e
                    ].prototype),
                    (this.Contextual.name = e)),
                  i.origin !== this.location.origin ||
                  (i.anchor && i.pathname === this.location.pathname)
                    ? (window.location.href = t)
                    : ((this.location = i), this.beforeFetch())
              }
            }),
            (e.prototype.popState = function () {
              ;(this.trigger = 'popstate'), (this.Contextual = !1)
              var t = this.Helpers.getLocation(window.location.href)
              this.location.pathname !== t.pathname ||
              (!this.location.anchor && !t.anchor)
                ? ((this.popping = !0), (this.location = t), this.beforeFetch())
                : (this.location = t)
            }),
            (e.prototype.pushState = function () {
              this.popping ||
                window.history.pushState(this.location, '', this.location.href)
            }),
            (e.prototype.fetch = function () {
              try {
                var t = this
                return Promise.resolve(
                  fetch(t.location.href, {
                    mode: 'same-origin',
                    method: 'GET',
                    headers: { 'X-Requested-With': 'Highway' },
                    credentials: 'same-origin',
                  }),
                ).then(function (e) {
                  if (e.status >= 200 && e.status < 300) return e.text()
                  window.location.href = t.location.href
                })
              } catch (t) {
                return Promise.reject(t)
              }
            }),
            (e.prototype.beforeFetch = function () {
              try {
                var t = this
                function i() {
                  t.afterFetch()
                }
                t.pushState(),
                  (t.running = !0),
                  t.emit('NAVIGATE_OUT', {
                    from: {
                      page: t.From.properties.page,
                      view: t.From.properties.view,
                    },
                    trigger: t.trigger,
                    location: t.location,
                  })
                var e = { trigger: t.trigger, contextual: t.Contextual },
                  n = t.cache.has(t.location.href)
                    ? Promise.resolve(t.From.hide(e)).then(function () {
                        t.properties = t.cache.get(t.location.href)
                      })
                    : Promise.resolve(
                        Promise.all([t.fetch(), t.From.hide(e)]),
                      ).then(function (e) {
                        ;(t.properties = t.Helpers.getProperties(e[0])),
                          t.cache.set(t.location.href, t.properties)
                      })
                return Promise.resolve(n && n.then ? n.then(i) : i())
              } catch (t) {
                return Promise.reject(t)
              }
            }),
            (e.prototype.afterFetch = function () {
              try {
                var t = this
                return Promise.resolve(t.properties.renderer).then(function (
                  e,
                ) {
                  return (
                    (t.To = new e(t.properties)),
                    t.To.add(),
                    t.emit('NAVIGATE_IN', {
                      to: {
                        page: t.To.properties.page,
                        view: t.To.wrap.lastElementChild,
                      },
                      trigger: t.trigger,
                      location: t.location,
                    }),
                    Promise.resolve(
                      t.To.show({
                        trigger: t.trigger,
                        contextual: t.Contextual,
                      }),
                    ).then(function () {
                      ;(t.popping = !1),
                        (t.running = !1),
                        t.detach(t.links),
                        (t.links = document.querySelectorAll(
                          'a:not([target]):not([data-router-disabled])',
                        )),
                        t.attach(t.links),
                        t.emit('NAVIGATE_END', {
                          to: {
                            page: t.To.properties.page,
                            view: t.To.wrap.lastElementChild,
                          },
                          from: {
                            page: t.From.properties.page,
                            view: t.From.properties.view,
                          },
                          trigger: t.trigger,
                          location: t.location,
                        }),
                        (t.From = t.To),
                        (t.trigger = null)
                    })
                  )
                })
              } catch (t) {
                return Promise.reject(t)
              }
            }),
            e
          )
        })(ca),
        fa = function (t, e) {
          ;(this.wrap = t), (this.name = e)
        }
      ;(fa.prototype.show = function (t) {
        var e = this,
          n = t.trigger,
          i = t.contextual,
          r = this.wrap.lastElementChild,
          s = this.wrap.firstElementChild
        return new Promise(function (t) {
          i
            ? (r.setAttribute('data-transition-in', i.name),
              r.removeAttribute('data-transition-out', i.name),
              i.in && i.in({ to: r, from: s, trigger: n, done: t }))
            : (r.setAttribute('data-transition-in', e.name),
              r.removeAttribute('data-transition-out', e.name),
              e.in && e.in({ to: r, from: s, trigger: n, done: t }))
        })
      }),
        (fa.prototype.hide = function (t) {
          var e = this,
            n = t.trigger,
            i = t.contextual,
            r = this.wrap.firstElementChild
          return new Promise(function (t) {
            i
              ? (r.setAttribute('data-transition-out', i.name),
                r.removeAttribute('data-transition-in', i.name),
                i.out && i.out({ from: r, trigger: n, done: t }))
              : (r.setAttribute('data-transition-out', e.name),
                r.removeAttribute('data-transition-in', e.name),
                e.out && e.out({ from: r, trigger: n, done: t }))
          })
        }),
        console.log('Highway v2.2.0')
      var ma = { Core: pa, Helpers: da, Renderer: ua, Transition: fa }
      const ga = 100,
        va = 301,
        _a = 302,
        ya = 306,
        xa = 1e3,
        ba = 1001,
        wa = 1002,
        Ma = 1003,
        Sa = 1004,
        Ta = 1005,
        Ea = 1006,
        Da = 1008,
        Aa = 1009,
        Ca = 1012,
        La = 1014,
        Ra = 1015,
        Pa = 1016,
        Fa = 1020,
        Ia = 1022,
        Oa = 1023,
        Na = 1026,
        ka = 1027,
        Ba = 2300,
        za = 2301,
        Ua = 2302,
        Ha = 2400,
        Ga = 2401,
        Va = 2402,
        Wa = 3e3,
        ja = 3001,
        qa = 3007,
        Xa = 3002,
        Ya = 7680,
        Ja = 35044,
        Za = 35048,
        Ka = '300 es'
      class Qa {
        addEventListener(t, e) {
          void 0 === this._listeners && (this._listeners = {})
          const n = this._listeners
          void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
        }
        hasEventListener(t, e) {
          if (void 0 === this._listeners) return !1
          const n = this._listeners
          return void 0 !== n[t] && -1 !== n[t].indexOf(e)
        }
        removeEventListener(t, e) {
          if (void 0 === this._listeners) return
          const n = this._listeners[t]
          if (void 0 !== n) {
            const t = n.indexOf(e)
            ;-1 !== t && n.splice(t, 1)
          }
        }
        dispatchEvent(t) {
          if (void 0 === this._listeners) return
          const e = this._listeners[t.type]
          if (void 0 !== e) {
            t.target = this
            const n = e.slice(0)
            for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t)
            t.target = null
          }
        }
      }
      let $a = 1234567
      const tl = Math.PI / 180,
        el = 180 / Math.PI,
        nl = []
      for (let t = 0; t < 256; t++) nl[t] = (t < 16 ? '0' : '') + t.toString(16)
      const il = 'undefined' != typeof crypto && 'randomUUID' in crypto
      function rl() {
        if (il) return crypto.randomUUID().toUpperCase()
        const t = (4294967295 * Math.random()) | 0,
          e = (4294967295 * Math.random()) | 0,
          n = (4294967295 * Math.random()) | 0,
          i = (4294967295 * Math.random()) | 0
        return (
          nl[255 & t] +
          nl[(t >> 8) & 255] +
          nl[(t >> 16) & 255] +
          nl[(t >> 24) & 255] +
          '-' +
          nl[255 & e] +
          nl[(e >> 8) & 255] +
          '-' +
          nl[((e >> 16) & 15) | 64] +
          nl[(e >> 24) & 255] +
          '-' +
          nl[(63 & n) | 128] +
          nl[(n >> 8) & 255] +
          '-' +
          nl[(n >> 16) & 255] +
          nl[(n >> 24) & 255] +
          nl[255 & i] +
          nl[(i >> 8) & 255] +
          nl[(i >> 16) & 255] +
          nl[(i >> 24) & 255]
        ).toUpperCase()
      }
      function sl(t, e, n) {
        return Math.max(e, Math.min(n, t))
      }
      function ol(t, e) {
        return ((t % e) + e) % e
      }
      function al(t, e, n) {
        return (1 - n) * t + n * e
      }
      function ll(t) {
        return 0 == (t & (t - 1)) && 0 !== t
      }
      function cl(t) {
        return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
      }
      function ul(t) {
        return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
      }
      var hl = Object.freeze({
        __proto__: null,
        DEG2RAD: tl,
        RAD2DEG: el,
        generateUUID: rl,
        clamp: sl,
        euclideanModulo: ol,
        mapLinear: function (t, e, n, i, r) {
          return i + ((t - e) * (r - i)) / (n - e)
        },
        inverseLerp: function (t, e, n) {
          return t !== e ? (n - t) / (e - t) : 0
        },
        lerp: al,
        damp: function (t, e, n, i) {
          return al(t, e, 1 - Math.exp(-n * i))
        },
        pingpong: function (t, e = 1) {
          return e - Math.abs(ol(t, 2 * e) - e)
        },
        smoothstep: function (t, e, n) {
          return t <= e
            ? 0
            : t >= n
            ? 1
            : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
        },
        smootherstep: function (t, e, n) {
          return t <= e
            ? 0
            : t >= n
            ? 1
            : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
        },
        randInt: function (t, e) {
          return t + Math.floor(Math.random() * (e - t + 1))
        },
        randFloat: function (t, e) {
          return t + Math.random() * (e - t)
        },
        randFloatSpread: function (t) {
          return t * (0.5 - Math.random())
        },
        seededRandom: function (t) {
          return (
            void 0 !== t && ($a = t % 2147483647),
            ($a = (16807 * $a) % 2147483647),
            ($a - 1) / 2147483646
          )
        },
        degToRad: function (t) {
          return t * tl
        },
        radToDeg: function (t) {
          return t * el
        },
        isPowerOfTwo: ll,
        ceilPowerOfTwo: cl,
        floorPowerOfTwo: ul,
        setQuaternionFromProperEuler: function (t, e, n, i, r) {
          const s = Math.cos,
            o = Math.sin,
            a = s(n / 2),
            l = o(n / 2),
            c = s((e + i) / 2),
            u = o((e + i) / 2),
            h = s((e - i) / 2),
            d = o((e - i) / 2),
            p = s((i - e) / 2),
            f = o((i - e) / 2)
          switch (r) {
            case 'XYX':
              t.set(a * u, l * h, l * d, a * c)
              break
            case 'YZY':
              t.set(l * d, a * u, l * h, a * c)
              break
            case 'ZXZ':
              t.set(l * h, l * d, a * u, a * c)
              break
            case 'XZX':
              t.set(a * u, l * f, l * p, a * c)
              break
            case 'YXY':
              t.set(l * p, a * u, l * f, a * c)
              break
            case 'ZYZ':
              t.set(l * f, l * p, a * u, a * c)
              break
            default:
              console.warn(
                'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' +
                  r,
              )
          }
        },
      })
      class dl {
        constructor(t = 0, e = 0) {
          ;(this.x = t), (this.y = e)
        }
        get width() {
          return this.x
        }
        set width(t) {
          this.x = t
        }
        get height() {
          return this.y
        }
        set height(t) {
          this.y = t
        }
        set(t, e) {
          return (this.x = t), (this.y = e), this
        }
        setScalar(t) {
          return (this.x = t), (this.y = t), this
        }
        setX(t) {
          return (this.x = t), this
        }
        setY(t) {
          return (this.y = t), this
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e
              break
            case 1:
              this.y = e
              break
            default:
              throw new Error('index is out of range: ' + t)
          }
          return this
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x
            case 1:
              return this.y
            default:
              throw new Error('index is out of range: ' + t)
          }
        }
        clone() {
          return new this.constructor(this.x, this.y)
        }
        copy(t) {
          return (this.x = t.x), (this.y = t.y), this
        }
        add(t, e) {
          return void 0 !== e
            ? (console.warn(
                'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.',
              ),
              this.addVectors(t, e))
            : ((this.x += t.x), (this.y += t.y), this)
        }
        addScalar(t) {
          return (this.x += t), (this.y += t), this
        }
        addVectors(t, e) {
          return (this.x = t.x + e.x), (this.y = t.y + e.y), this
        }
        addScaledVector(t, e) {
          return (this.x += t.x * e), (this.y += t.y * e), this
        }
        sub(t, e) {
          return void 0 !== e
            ? (console.warn(
                'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.',
              ),
              this.subVectors(t, e))
            : ((this.x -= t.x), (this.y -= t.y), this)
        }
        subScalar(t) {
          return (this.x -= t), (this.y -= t), this
        }
        subVectors(t, e) {
          return (this.x = t.x - e.x), (this.y = t.y - e.y), this
        }
        multiply(t) {
          return (this.x *= t.x), (this.y *= t.y), this
        }
        multiplyScalar(t) {
          return (this.x *= t), (this.y *= t), this
        }
        divide(t) {
          return (this.x /= t.x), (this.y /= t.y), this
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t)
        }
        applyMatrix3(t) {
          const e = this.x,
            n = this.y,
            i = t.elements
          return (
            (this.x = i[0] * e + i[3] * n + i[6]),
            (this.y = i[1] * e + i[4] * n + i[7]),
            this
          )
        }
        min(t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            this
          )
        }
        max(t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            this
          )
        }
        clamp(t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            this
          )
        }
        clampScalar(t, e) {
          return (
            (this.x = Math.max(t, Math.min(e, this.x))),
            (this.y = Math.max(t, Math.min(e, this.y))),
            this
          )
        }
        clampLength(t, e) {
          const n = this.length()
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(t, Math.min(e, n)),
          )
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
          )
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
          )
        }
        round() {
          return (
            (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
          )
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            this
          )
        }
        negate() {
          return (this.x = -this.x), (this.y = -this.y), this
        }
        dot(t) {
          return this.x * t.x + this.y * t.y
        }
        cross(t) {
          return this.x * t.y - this.y * t.x
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y)
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y)
        }
        normalize() {
          return this.divideScalar(this.length() || 1)
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI
        }
        distanceTo(t) {
          return Math.sqrt(this.distanceToSquared(t))
        }
        distanceToSquared(t) {
          const e = this.x - t.x,
            n = this.y - t.y
          return e * e + n * n
        }
        manhattanDistanceTo(t) {
          return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t)
        }
        lerp(t, e) {
          return (
            (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
          )
        }
        lerpVectors(t, e, n) {
          return (
            (this.x = t.x + (e.x - t.x) * n),
            (this.y = t.y + (e.y - t.y) * n),
            this
          )
        }
        equals(t) {
          return t.x === this.x && t.y === this.y
        }
        fromArray(t, e = 0) {
          return (this.x = t[e]), (this.y = t[e + 1]), this
        }
        toArray(t = [], e = 0) {
          return (t[e] = this.x), (t[e + 1] = this.y), t
        }
        fromBufferAttribute(t, e, n) {
          return (
            void 0 !== n &&
              console.warn(
                'THREE.Vector2: offset has been removed from .fromBufferAttribute().',
              ),
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            this
          )
        }
        rotateAround(t, e) {
          const n = Math.cos(e),
            i = Math.sin(e),
            r = this.x - t.x,
            s = this.y - t.y
          return (
            (this.x = r * n - s * i + t.x), (this.y = r * i + s * n + t.y), this
          )
        }
        random() {
          return (this.x = Math.random()), (this.y = Math.random()), this
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y
        }
      }
      dl.prototype.isVector2 = !0
      class pl {
        constructor() {
          ;(this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            arguments.length > 0 &&
              console.error(
                'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.',
              )
        }
        set(t, e, n, i, r, s, o, a, l) {
          const c = this.elements
          return (
            (c[0] = t),
            (c[1] = i),
            (c[2] = o),
            (c[3] = e),
            (c[4] = r),
            (c[5] = a),
            (c[6] = n),
            (c[7] = s),
            (c[8] = l),
            this
          )
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        }
        copy(t) {
          const e = this.elements,
            n = t.elements
          return (
            (e[0] = n[0]),
            (e[1] = n[1]),
            (e[2] = n[2]),
            (e[3] = n[3]),
            (e[4] = n[4]),
            (e[5] = n[5]),
            (e[6] = n[6]),
            (e[7] = n[7]),
            (e[8] = n[8]),
            this
          )
        }
        extractBasis(t, e, n) {
          return (
            t.setFromMatrix3Column(this, 0),
            e.setFromMatrix3Column(this, 1),
            n.setFromMatrix3Column(this, 2),
            this
          )
        }
        setFromMatrix4(t) {
          const e = t.elements
          return (
            this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
            this
          )
        }
        multiply(t) {
          return this.multiplyMatrices(this, t)
        }
        premultiply(t) {
          return this.multiplyMatrices(t, this)
        }
        multiplyMatrices(t, e) {
          const n = t.elements,
            i = e.elements,
            r = this.elements,
            s = n[0],
            o = n[3],
            a = n[6],
            l = n[1],
            c = n[4],
            u = n[7],
            h = n[2],
            d = n[5],
            p = n[8],
            f = i[0],
            m = i[3],
            g = i[6],
            v = i[1],
            _ = i[4],
            y = i[7],
            x = i[2],
            b = i[5],
            w = i[8]
          return (
            (r[0] = s * f + o * v + a * x),
            (r[3] = s * m + o * _ + a * b),
            (r[6] = s * g + o * y + a * w),
            (r[1] = l * f + c * v + u * x),
            (r[4] = l * m + c * _ + u * b),
            (r[7] = l * g + c * y + u * w),
            (r[2] = h * f + d * v + p * x),
            (r[5] = h * m + d * _ + p * b),
            (r[8] = h * g + d * y + p * w),
            this
          )
        }
        multiplyScalar(t) {
          const e = this.elements
          return (
            (e[0] *= t),
            (e[3] *= t),
            (e[6] *= t),
            (e[1] *= t),
            (e[4] *= t),
            (e[7] *= t),
            (e[2] *= t),
            (e[5] *= t),
            (e[8] *= t),
            this
          )
        }
        determinant() {
          const t = this.elements,
            e = t[0],
            n = t[1],
            i = t[2],
            r = t[3],
            s = t[4],
            o = t[5],
            a = t[6],
            l = t[7],
            c = t[8]
          return (
            e * s * c -
            e * o * l -
            n * r * c +
            n * o * a +
            i * r * l -
            i * s * a
          )
        }
        invert() {
          const t = this.elements,
            e = t[0],
            n = t[1],
            i = t[2],
            r = t[3],
            s = t[4],
            o = t[5],
            a = t[6],
            l = t[7],
            c = t[8],
            u = c * s - o * l,
            h = o * a - c * r,
            d = l * r - s * a,
            p = e * u + n * h + i * d
          if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0)
          const f = 1 / p
          return (
            (t[0] = u * f),
            (t[1] = (i * l - c * n) * f),
            (t[2] = (o * n - i * s) * f),
            (t[3] = h * f),
            (t[4] = (c * e - i * a) * f),
            (t[5] = (i * r - o * e) * f),
            (t[6] = d * f),
            (t[7] = (n * a - l * e) * f),
            (t[8] = (s * e - n * r) * f),
            this
          )
        }
        transpose() {
          let t
          const e = this.elements
          return (
            (t = e[1]),
            (e[1] = e[3]),
            (e[3] = t),
            (t = e[2]),
            (e[2] = e[6]),
            (e[6] = t),
            (t = e[5]),
            (e[5] = e[7]),
            (e[7] = t),
            this
          )
        }
        getNormalMatrix(t) {
          return this.setFromMatrix4(t).invert().transpose()
        }
        transposeIntoArray(t) {
          const e = this.elements
          return (
            (t[0] = e[0]),
            (t[1] = e[3]),
            (t[2] = e[6]),
            (t[3] = e[1]),
            (t[4] = e[4]),
            (t[5] = e[7]),
            (t[6] = e[2]),
            (t[7] = e[5]),
            (t[8] = e[8]),
            this
          )
        }
        setUvTransform(t, e, n, i, r, s, o) {
          const a = Math.cos(r),
            l = Math.sin(r)
          return (
            this.set(
              n * a,
              n * l,
              -n * (a * s + l * o) + s + t,
              -i * l,
              i * a,
              -i * (-l * s + a * o) + o + e,
              0,
              0,
              1,
            ),
            this
          )
        }
        scale(t, e) {
          const n = this.elements
          return (
            (n[0] *= t),
            (n[3] *= t),
            (n[6] *= t),
            (n[1] *= e),
            (n[4] *= e),
            (n[7] *= e),
            this
          )
        }
        rotate(t) {
          const e = Math.cos(t),
            n = Math.sin(t),
            i = this.elements,
            r = i[0],
            s = i[3],
            o = i[6],
            a = i[1],
            l = i[4],
            c = i[7]
          return (
            (i[0] = e * r + n * a),
            (i[3] = e * s + n * l),
            (i[6] = e * o + n * c),
            (i[1] = -n * r + e * a),
            (i[4] = -n * s + e * l),
            (i[7] = -n * o + e * c),
            this
          )
        }
        translate(t, e) {
          const n = this.elements
          return (
            (n[0] += t * n[2]),
            (n[3] += t * n[5]),
            (n[6] += t * n[8]),
            (n[1] += e * n[2]),
            (n[4] += e * n[5]),
            (n[7] += e * n[8]),
            this
          )
        }
        equals(t) {
          const e = this.elements,
            n = t.elements
          for (let t = 0; t < 9; t++) if (e[t] !== n[t]) return !1
          return !0
        }
        fromArray(t, e = 0) {
          for (let n = 0; n < 9; n++) this.elements[n] = t[n + e]
          return this
        }
        toArray(t = [], e = 0) {
          const n = this.elements
          return (
            (t[e] = n[0]),
            (t[e + 1] = n[1]),
            (t[e + 2] = n[2]),
            (t[e + 3] = n[3]),
            (t[e + 4] = n[4]),
            (t[e + 5] = n[5]),
            (t[e + 6] = n[6]),
            (t[e + 7] = n[7]),
            (t[e + 8] = n[8]),
            t
          )
        }
        clone() {
          return new this.constructor().fromArray(this.elements)
        }
      }
      function fl(t) {
        if (0 === t.length) return -1 / 0
        let e = t[0]
        for (let n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n])
        return e
      }
      function ml(t) {
        return document.createElementNS('http://www.w3.org/1999/xhtml', t)
      }
      let gl
      ;(pl.prototype.isMatrix3 = !0),
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array
      class vl {
        static getDataURL(t) {
          if (/^data:/i.test(t.src)) return t.src
          if ('undefined' == typeof HTMLCanvasElement) return t.src
          let e
          if (t instanceof HTMLCanvasElement) e = t
          else {
            void 0 === gl && (gl = ml('canvas')),
              (gl.width = t.width),
              (gl.height = t.height)
            const n = gl.getContext('2d')
            t instanceof ImageData
              ? n.putImageData(t, 0, 0)
              : n.drawImage(t, 0, 0, t.width, t.height),
              (e = gl)
          }
          return e.width > 2048 || e.height > 2048
            ? (console.warn(
                'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons',
                t,
              ),
              e.toDataURL('image/jpeg', 0.6))
            : e.toDataURL('image/png')
        }
      }
      let _l = 0
      class yl extends Qa {
        constructor(
          t = yl.DEFAULT_IMAGE,
          e = yl.DEFAULT_MAPPING,
          n = 1001,
          i = 1001,
          r = 1006,
          s = 1008,
          o = 1023,
          a = 1009,
          l = 1,
          c = 3e3,
        ) {
          super(),
            Object.defineProperty(this, 'id', { value: _l++ }),
            (this.uuid = rl()),
            (this.name = ''),
            (this.image = t),
            (this.mipmaps = []),
            (this.mapping = e),
            (this.wrapS = n),
            (this.wrapT = i),
            (this.magFilter = r),
            (this.minFilter = s),
            (this.anisotropy = l),
            (this.format = o),
            (this.internalFormat = null),
            (this.type = a),
            (this.offset = new dl(0, 0)),
            (this.repeat = new dl(1, 1)),
            (this.center = new dl(0, 0)),
            (this.rotation = 0),
            (this.matrixAutoUpdate = !0),
            (this.matrix = new pl()),
            (this.generateMipmaps = !0),
            (this.premultiplyAlpha = !1),
            (this.flipY = !0),
            (this.unpackAlignment = 4),
            (this.encoding = c),
            (this.version = 0),
            (this.onUpdate = null),
            (this.isRenderTargetTexture = !1)
        }
        updateMatrix() {
          this.matrix.setUvTransform(
            this.offset.x,
            this.offset.y,
            this.repeat.x,
            this.repeat.y,
            this.rotation,
            this.center.x,
            this.center.y,
          )
        }
        clone() {
          return new this.constructor().copy(this)
        }
        copy(t) {
          return (
            (this.name = t.name),
            (this.image = t.image),
            (this.mipmaps = t.mipmaps.slice(0)),
            (this.mapping = t.mapping),
            (this.wrapS = t.wrapS),
            (this.wrapT = t.wrapT),
            (this.magFilter = t.magFilter),
            (this.minFilter = t.minFilter),
            (this.anisotropy = t.anisotropy),
            (this.format = t.format),
            (this.internalFormat = t.internalFormat),
            (this.type = t.type),
            this.offset.copy(t.offset),
            this.repeat.copy(t.repeat),
            this.center.copy(t.center),
            (this.rotation = t.rotation),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            this.matrix.copy(t.matrix),
            (this.generateMipmaps = t.generateMipmaps),
            (this.premultiplyAlpha = t.premultiplyAlpha),
            (this.flipY = t.flipY),
            (this.unpackAlignment = t.unpackAlignment),
            (this.encoding = t.encoding),
            this
          )
        }
        toJSON(t) {
          const e = void 0 === t || 'string' == typeof t
          if (!e && void 0 !== t.textures[this.uuid])
            return t.textures[this.uuid]
          const n = {
            metadata: {
              version: 4.5,
              type: 'Texture',
              generator: 'Texture.toJSON',
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment,
          }
          if (void 0 !== this.image) {
            const i = this.image
            if (
              (void 0 === i.uuid && (i.uuid = rl()),
              !e && void 0 === t.images[i.uuid])
            ) {
              let e
              if (Array.isArray(i)) {
                e = []
                for (let t = 0, n = i.length; t < n; t++)
                  i[t].isDataTexture ? e.push(xl(i[t].image)) : e.push(xl(i[t]))
              } else e = xl(i)
              t.images[i.uuid] = { uuid: i.uuid, url: e }
            }
            n.image = i.uuid
          }
          return e || (t.textures[this.uuid] = n), n
        }
        dispose() {
          this.dispatchEvent({ type: 'dispose' })
        }
        transformUv(t) {
          if (300 !== this.mapping) return t
          if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
            switch (this.wrapS) {
              case xa:
                t.x = t.x - Math.floor(t.x)
                break
              case ba:
                t.x = t.x < 0 ? 0 : 1
                break
              case wa:
                1 === Math.abs(Math.floor(t.x) % 2)
                  ? (t.x = Math.ceil(t.x) - t.x)
                  : (t.x = t.x - Math.floor(t.x))
            }
          if (t.y < 0 || t.y > 1)
            switch (this.wrapT) {
              case xa:
                t.y = t.y - Math.floor(t.y)
                break
              case ba:
                t.y = t.y < 0 ? 0 : 1
                break
              case wa:
                1 === Math.abs(Math.floor(t.y) % 2)
                  ? (t.y = Math.ceil(t.y) - t.y)
                  : (t.y = t.y - Math.floor(t.y))
            }
          return this.flipY && (t.y = 1 - t.y), t
        }
        set needsUpdate(t) {
          !0 === t && this.version++
        }
      }
      function xl(t) {
        return ('undefined' != typeof HTMLImageElement &&
          t instanceof HTMLImageElement) ||
          ('undefined' != typeof HTMLCanvasElement &&
            t instanceof HTMLCanvasElement) ||
          ('undefined' != typeof ImageBitmap && t instanceof ImageBitmap)
          ? vl.getDataURL(t)
          : t.data
          ? {
              data: Array.prototype.slice.call(t.data),
              width: t.width,
              height: t.height,
              type: t.data.constructor.name,
            }
          : (console.warn('THREE.Texture: Unable to serialize Texture.'), {})
      }
      ;(yl.DEFAULT_IMAGE = void 0),
        (yl.DEFAULT_MAPPING = 300),
        (yl.prototype.isTexture = !0)
      class bl {
        constructor(t = 0, e = 0, n = 0, i = 1) {
          ;(this.x = t), (this.y = e), (this.z = n), (this.w = i)
        }
        get width() {
          return this.z
        }
        set width(t) {
          this.z = t
        }
        get height() {
          return this.w
        }
        set height(t) {
          this.w = t
        }
        set(t, e, n, i) {
          return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this
        }
        setScalar(t) {
          return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this
        }
        setX(t) {
          return (this.x = t), this
        }
        setY(t) {
          return (this.y = t), this
        }
        setZ(t) {
          return (this.z = t), this
        }
        setW(t) {
          return (this.w = t), this
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e
              break
            case 1:
              this.y = e
              break
            case 2:
              this.z = e
              break
            case 3:
              this.w = e
              break
            default:
              throw new Error('index is out of range: ' + t)
          }
          return this
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x
            case 1:
              return this.y
            case 2:
              return this.z
            case 3:
              return this.w
            default:
              throw new Error('index is out of range: ' + t)
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w)
        }
        copy(t) {
          return (
            (this.x = t.x),
            (this.y = t.y),
            (this.z = t.z),
            (this.w = void 0 !== t.w ? t.w : 1),
            this
          )
        }
        add(t, e) {
          return void 0 !== e
            ? (console.warn(
                'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.',
              ),
              this.addVectors(t, e))
            : ((this.x += t.x),
              (this.y += t.y),
              (this.z += t.z),
              (this.w += t.w),
              this)
        }
        addScalar(t) {
          return (
            (this.x += t), (this.y += t), (this.z += t), (this.w += t), this
          )
        }
        addVectors(t, e) {
          return (
            (this.x = t.x + e.x),
            (this.y = t.y + e.y),
            (this.z = t.z + e.z),
            (this.w = t.w + e.w),
            this
          )
        }
        addScaledVector(t, e) {
          return (
            (this.x += t.x * e),
            (this.y += t.y * e),
            (this.z += t.z * e),
            (this.w += t.w * e),
            this
          )
        }
        sub(t, e) {
          return void 0 !== e
            ? (console.warn(
                'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.',
              ),
              this.subVectors(t, e))
            : ((this.x -= t.x),
              (this.y -= t.y),
              (this.z -= t.z),
              (this.w -= t.w),
              this)
        }
        subScalar(t) {
          return (
            (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this
          )
        }
        subVectors(t, e) {
          return (
            (this.x = t.x - e.x),
            (this.y = t.y - e.y),
            (this.z = t.z - e.z),
            (this.w = t.w - e.w),
            this
          )
        }
        multiply(t) {
          return (
            (this.x *= t.x),
            (this.y *= t.y),
            (this.z *= t.z),
            (this.w *= t.w),
            this
          )
        }
        multiplyScalar(t) {
          return (
            (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this
          )
        }
        applyMatrix4(t) {
          const e = this.x,
            n = this.y,
            i = this.z,
            r = this.w,
            s = t.elements
          return (
            (this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r),
            (this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r),
            (this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r),
            (this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r),
            this
          )
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t)
        }
        setAxisAngleFromQuaternion(t) {
          this.w = 2 * Math.acos(t.w)
          const e = Math.sqrt(1 - t.w * t.w)
          return (
            e < 1e-4
              ? ((this.x = 1), (this.y = 0), (this.z = 0))
              : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
            this
          )
        }
        setAxisAngleFromRotationMatrix(t) {
          let e, n, i, r
          const s = 0.01,
            o = 0.1,
            a = t.elements,
            l = a[0],
            c = a[4],
            u = a[8],
            h = a[1],
            d = a[5],
            p = a[9],
            f = a[2],
            m = a[6],
            g = a[10]
          if (
            Math.abs(c - h) < s &&
            Math.abs(u - f) < s &&
            Math.abs(p - m) < s
          ) {
            if (
              Math.abs(c + h) < o &&
              Math.abs(u + f) < o &&
              Math.abs(p + m) < o &&
              Math.abs(l + d + g - 3) < o
            )
              return this.set(1, 0, 0, 0), this
            e = Math.PI
            const t = (l + 1) / 2,
              a = (d + 1) / 2,
              v = (g + 1) / 2,
              _ = (c + h) / 4,
              y = (u + f) / 4,
              x = (p + m) / 4
            return (
              t > a && t > v
                ? t < s
                  ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                  : ((n = Math.sqrt(t)), (i = _ / n), (r = y / n))
                : a > v
                ? a < s
                  ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                  : ((i = Math.sqrt(a)), (n = _ / i), (r = x / i))
                : v < s
                ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
                : ((r = Math.sqrt(v)), (n = y / r), (i = x / r)),
              this.set(n, i, r, e),
              this
            )
          }
          let v = Math.sqrt(
            (m - p) * (m - p) + (u - f) * (u - f) + (h - c) * (h - c),
          )
          return (
            Math.abs(v) < 0.001 && (v = 1),
            (this.x = (m - p) / v),
            (this.y = (u - f) / v),
            (this.z = (h - c) / v),
            (this.w = Math.acos((l + d + g - 1) / 2)),
            this
          )
        }
        min(t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            (this.z = Math.min(this.z, t.z)),
            (this.w = Math.min(this.w, t.w)),
            this
          )
        }
        max(t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            (this.z = Math.max(this.z, t.z)),
            (this.w = Math.max(this.w, t.w)),
            this
          )
        }
        clamp(t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            (this.z = Math.max(t.z, Math.min(e.z, this.z))),
            (this.w = Math.max(t.w, Math.min(e.w, this.w))),
            this
          )
        }
        clampScalar(t, e) {
          return (
            (this.x = Math.max(t, Math.min(e, this.x))),
            (this.y = Math.max(t, Math.min(e, this.y))),
            (this.z = Math.max(t, Math.min(e, this.z))),
            (this.w = Math.max(t, Math.min(e, this.w))),
            this
          )
        }
        clampLength(t, e) {
          const n = this.length()
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(t, Math.min(e, n)),
          )
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
          )
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
          )
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
          )
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
            this
          )
        }
        negate() {
          return (
            (this.x = -this.x),
            (this.y = -this.y),
            (this.z = -this.z),
            (this.w = -this.w),
            this
          )
        }
        dot(t) {
          return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
        }
        lengthSq() {
          return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
          )
        }
        length() {
          return Math.sqrt(
            this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w,
          )
        }
        manhattanLength() {
          return (
            Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
          )
        }
        normalize() {
          return this.divideScalar(this.length() || 1)
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t)
        }
        lerp(t, e) {
          return (
            (this.x += (t.x - this.x) * e),
            (this.y += (t.y - this.y) * e),
            (this.z += (t.z - this.z) * e),
            (this.w += (t.w - this.w) * e),
            this
          )
        }
        lerpVectors(t, e, n) {
          return (
            (this.x = t.x + (e.x - t.x) * n),
            (this.y = t.y + (e.y - t.y) * n),
            (this.z = t.z + (e.z - t.z) * n),
            (this.w = t.w + (e.w - t.w) * n),
            this
          )
        }
        equals(t) {
          return (
            t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
          )
        }
        fromArray(t, e = 0) {
          return (
            (this.x = t[e]),
            (this.y = t[e + 1]),
            (this.z = t[e + 2]),
            (this.w = t[e + 3]),
            this
          )
        }
        toArray(t = [], e = 0) {
          return (
            (t[e] = this.x),
            (t[e + 1] = this.y),
            (t[e + 2] = this.z),
            (t[e + 3] = this.w),
            t
          )
        }
        fromBufferAttribute(t, e, n) {
          return (
            void 0 !== n &&
              console.warn(
                'THREE.Vector4: offset has been removed from .fromBufferAttribute().',
              ),
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            (this.z = t.getZ(e)),
            (this.w = t.getW(e)),
            this
          )
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            (this.w = Math.random()),
            this
          )
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z, yield this.w
        }
      }
      bl.prototype.isVector4 = !0
      class wl extends Qa {
        constructor(t, e, n = {}) {
          super(),
            (this.width = t),
            (this.height = e),
            (this.depth = 1),
            (this.scissor = new bl(0, 0, t, e)),
            (this.scissorTest = !1),
            (this.viewport = new bl(0, 0, t, e)),
            (this.texture = new yl(
              void 0,
              n.mapping,
              n.wrapS,
              n.wrapT,
              n.magFilter,
              n.minFilter,
              n.format,
              n.type,
              n.anisotropy,
              n.encoding,
            )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.image = { width: t, height: e, depth: 1 }),
            (this.texture.generateMipmaps =
              void 0 !== n.generateMipmaps && n.generateMipmaps),
            (this.texture.internalFormat =
              void 0 !== n.internalFormat ? n.internalFormat : null),
            (this.texture.minFilter =
              void 0 !== n.minFilter ? n.minFilter : Ea),
            (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
            (this.stencilBuffer =
              void 0 !== n.stencilBuffer && n.stencilBuffer),
            (this.depthTexture =
              void 0 !== n.depthTexture ? n.depthTexture : null)
        }
        setTexture(t) {
          ;(t.image = {
            width: this.width,
            height: this.height,
            depth: this.depth,
          }),
            (this.texture = t)
        }
        setSize(t, e, n = 1) {
          ;(this.width === t && this.height === e && this.depth === n) ||
            ((this.width = t),
            (this.height = e),
            (this.depth = n),
            (this.texture.image.width = t),
            (this.texture.image.height = e),
            (this.texture.image.depth = n),
            this.dispose()),
            this.viewport.set(0, 0, t, e),
            this.scissor.set(0, 0, t, e)
        }
        clone() {
          return new this.constructor().copy(this)
        }
        copy(t) {
          return (
            (this.width = t.width),
            (this.height = t.height),
            (this.depth = t.depth),
            this.viewport.copy(t.viewport),
            (this.texture = t.texture.clone()),
            (this.texture.image = { ...this.texture.image }),
            (this.depthBuffer = t.depthBuffer),
            (this.stencilBuffer = t.stencilBuffer),
            (this.depthTexture = t.depthTexture),
            this
          )
        }
        dispose() {
          this.dispatchEvent({ type: 'dispose' })
        }
      }
      ;(wl.prototype.isWebGLRenderTarget = !0),
        (class extends wl {
          constructor(t, e, n) {
            super(t, e)
            const i = this.texture
            this.texture = []
            for (let t = 0; t < n; t++) this.texture[t] = i.clone()
          }
          setSize(t, e, n = 1) {
            if (this.width !== t || this.height !== e || this.depth !== n) {
              ;(this.width = t), (this.height = e), (this.depth = n)
              for (let i = 0, r = this.texture.length; i < r; i++)
                (this.texture[i].image.width = t),
                  (this.texture[i].image.height = e),
                  (this.texture[i].image.depth = n)
              this.dispose()
            }
            return (
              this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this
            )
          }
          copy(t) {
            this.dispose(),
              (this.width = t.width),
              (this.height = t.height),
              (this.depth = t.depth),
              this.viewport.set(0, 0, this.width, this.height),
              this.scissor.set(0, 0, this.width, this.height),
              (this.depthBuffer = t.depthBuffer),
              (this.stencilBuffer = t.stencilBuffer),
              (this.depthTexture = t.depthTexture),
              (this.texture.length = 0)
            for (let e = 0, n = t.texture.length; e < n; e++)
              this.texture[e] = t.texture[e].clone()
            return this
          }
        }.prototype.isWebGLMultipleRenderTargets = !0)
      class Ml extends wl {
        constructor(t, e, n) {
          super(t, e, n), (this.samples = 4)
        }
        copy(t) {
          return super.copy.call(this, t), (this.samples = t.samples), this
        }
      }
      Ml.prototype.isWebGLMultisampleRenderTarget = !0
      class Sl {
        constructor(t = 0, e = 0, n = 0, i = 1) {
          ;(this._x = t), (this._y = e), (this._z = n), (this._w = i)
        }
        static slerp(t, e, n, i) {
          return (
            console.warn(
              'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.',
            ),
            n.slerpQuaternions(t, e, i)
          )
        }
        static slerpFlat(t, e, n, i, r, s, o) {
          let a = n[i + 0],
            l = n[i + 1],
            c = n[i + 2],
            u = n[i + 3]
          const h = r[s + 0],
            d = r[s + 1],
            p = r[s + 2],
            f = r[s + 3]
          if (0 === o)
            return (
              (t[e + 0] = a),
              (t[e + 1] = l),
              (t[e + 2] = c),
              void (t[e + 3] = u)
            )
          if (1 === o)
            return (
              (t[e + 0] = h),
              (t[e + 1] = d),
              (t[e + 2] = p),
              void (t[e + 3] = f)
            )
          if (u !== f || a !== h || l !== d || c !== p) {
            let t = 1 - o
            const e = a * h + l * d + c * p + u * f,
              n = e >= 0 ? 1 : -1,
              i = 1 - e * e
            if (i > Number.EPSILON) {
              const r = Math.sqrt(i),
                s = Math.atan2(r, e * n)
              ;(t = Math.sin(t * s) / r), (o = Math.sin(o * s) / r)
            }
            const r = o * n
            if (
              ((a = a * t + h * r),
              (l = l * t + d * r),
              (c = c * t + p * r),
              (u = u * t + f * r),
              t === 1 - o)
            ) {
              const t = 1 / Math.sqrt(a * a + l * l + c * c + u * u)
              ;(a *= t), (l *= t), (c *= t), (u *= t)
            }
          }
          ;(t[e] = a), (t[e + 1] = l), (t[e + 2] = c), (t[e + 3] = u)
        }
        static multiplyQuaternionsFlat(t, e, n, i, r, s) {
          const o = n[i],
            a = n[i + 1],
            l = n[i + 2],
            c = n[i + 3],
            u = r[s],
            h = r[s + 1],
            d = r[s + 2],
            p = r[s + 3]
          return (
            (t[e] = o * p + c * u + a * d - l * h),
            (t[e + 1] = a * p + c * h + l * u - o * d),
            (t[e + 2] = l * p + c * d + o * h - a * u),
            (t[e + 3] = c * p - o * u - a * h - l * d),
            t
          )
        }
        get x() {
          return this._x
        }
        set x(t) {
          ;(this._x = t), this._onChangeCallback()
        }
        get y() {
          return this._y
        }
        set y(t) {
          ;(this._y = t), this._onChangeCallback()
        }
        get z() {
          return this._z
        }
        set z(t) {
          ;(this._z = t), this._onChangeCallback()
        }
        get w() {
          return this._w
        }
        set w(t) {
          ;(this._w = t), this._onChangeCallback()
        }
        set(t, e, n, i) {
          return (
            (this._x = t),
            (this._y = e),
            (this._z = n),
            (this._w = i),
            this._onChangeCallback(),
            this
          )
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w)
        }
        copy(t) {
          return (
            (this._x = t.x),
            (this._y = t.y),
            (this._z = t.z),
            (this._w = t.w),
            this._onChangeCallback(),
            this
          )
        }
        setFromEuler(t, e) {
          if (!t || !t.isEuler)
            throw new Error(
              'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.',
            )
          const n = t._x,
            i = t._y,
            r = t._z,
            s = t._order,
            o = Math.cos,
            a = Math.sin,
            l = o(n / 2),
            c = o(i / 2),
            u = o(r / 2),
            h = a(n / 2),
            d = a(i / 2),
            p = a(r / 2)
          switch (s) {
            case 'XYZ':
              ;(this._x = h * c * u + l * d * p),
                (this._y = l * d * u - h * c * p),
                (this._z = l * c * p + h * d * u),
                (this._w = l * c * u - h * d * p)
              break
            case 'YXZ':
              ;(this._x = h * c * u + l * d * p),
                (this._y = l * d * u - h * c * p),
                (this._z = l * c * p - h * d * u),
                (this._w = l * c * u + h * d * p)
              break
            case 'ZXY':
              ;(this._x = h * c * u - l * d * p),
                (this._y = l * d * u + h * c * p),
                (this._z = l * c * p + h * d * u),
                (this._w = l * c * u - h * d * p)
              break
            case 'ZYX':
              ;(this._x = h * c * u - l * d * p),
                (this._y = l * d * u + h * c * p),
                (this._z = l * c * p - h * d * u),
                (this._w = l * c * u + h * d * p)
              break
            case 'YZX':
              ;(this._x = h * c * u + l * d * p),
                (this._y = l * d * u + h * c * p),
                (this._z = l * c * p - h * d * u),
                (this._w = l * c * u - h * d * p)
              break
            case 'XZY':
              ;(this._x = h * c * u - l * d * p),
                (this._y = l * d * u - h * c * p),
                (this._z = l * c * p + h * d * u),
                (this._w = l * c * u + h * d * p)
              break
            default:
              console.warn(
                'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' +
                  s,
              )
          }
          return !1 !== e && this._onChangeCallback(), this
        }
        setFromAxisAngle(t, e) {
          const n = e / 2,
            i = Math.sin(n)
          return (
            (this._x = t.x * i),
            (this._y = t.y * i),
            (this._z = t.z * i),
            (this._w = Math.cos(n)),
            this._onChangeCallback(),
            this
          )
        }
        setFromRotationMatrix(t) {
          const e = t.elements,
            n = e[0],
            i = e[4],
            r = e[8],
            s = e[1],
            o = e[5],
            a = e[9],
            l = e[2],
            c = e[6],
            u = e[10],
            h = n + o + u
          if (h > 0) {
            const t = 0.5 / Math.sqrt(h + 1)
            ;(this._w = 0.25 / t),
              (this._x = (c - a) * t),
              (this._y = (r - l) * t),
              (this._z = (s - i) * t)
          } else if (n > o && n > u) {
            const t = 2 * Math.sqrt(1 + n - o - u)
            ;(this._w = (c - a) / t),
              (this._x = 0.25 * t),
              (this._y = (i + s) / t),
              (this._z = (r + l) / t)
          } else if (o > u) {
            const t = 2 * Math.sqrt(1 + o - n - u)
            ;(this._w = (r - l) / t),
              (this._x = (i + s) / t),
              (this._y = 0.25 * t),
              (this._z = (a + c) / t)
          } else {
            const t = 2 * Math.sqrt(1 + u - n - o)
            ;(this._w = (s - i) / t),
              (this._x = (r + l) / t),
              (this._y = (a + c) / t),
              (this._z = 0.25 * t)
          }
          return this._onChangeCallback(), this
        }
        setFromUnitVectors(t, e) {
          let n = t.dot(e) + 1
          return (
            n < Number.EPSILON
              ? ((n = 0),
                Math.abs(t.x) > Math.abs(t.z)
                  ? ((this._x = -t.y),
                    (this._y = t.x),
                    (this._z = 0),
                    (this._w = n))
                  : ((this._x = 0),
                    (this._y = -t.z),
                    (this._z = t.y),
                    (this._w = n)))
              : ((this._x = t.y * e.z - t.z * e.y),
                (this._y = t.z * e.x - t.x * e.z),
                (this._z = t.x * e.y - t.y * e.x),
                (this._w = n)),
            this.normalize()
          )
        }
        angleTo(t) {
          return 2 * Math.acos(Math.abs(sl(this.dot(t), -1, 1)))
        }
        rotateTowards(t, e) {
          const n = this.angleTo(t)
          if (0 === n) return this
          const i = Math.min(1, e / n)
          return this.slerp(t, i), this
        }
        identity() {
          return this.set(0, 0, 0, 1)
        }
        invert() {
          return this.conjugate()
        }
        conjugate() {
          return (
            (this._x *= -1),
            (this._y *= -1),
            (this._z *= -1),
            this._onChangeCallback(),
            this
          )
        }
        dot(t) {
          return (
            this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
          )
        }
        lengthSq() {
          return (
            this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
          )
        }
        length() {
          return Math.sqrt(
            this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w,
          )
        }
        normalize() {
          let t = this.length()
          return (
            0 === t
              ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
              : ((t = 1 / t),
                (this._x = this._x * t),
                (this._y = this._y * t),
                (this._z = this._z * t),
                (this._w = this._w * t)),
            this._onChangeCallback(),
            this
          )
        }
        multiply(t, e) {
          return void 0 !== e
            ? (console.warn(
                'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.',
              ),
              this.multiplyQuaternions(t, e))
            : this.multiplyQuaternions(this, t)
        }
        premultiply(t) {
          return this.multiplyQuaternions(t, this)
        }
        multiplyQuaternions(t, e) {
          const n = t._x,
            i = t._y,
            r = t._z,
            s = t._w,
            o = e._x,
            a = e._y,
            l = e._z,
            c = e._w
          return (
            (this._x = n * c + s * o + i * l - r * a),
            (this._y = i * c + s * a + r * o - n * l),
            (this._z = r * c + s * l + n * a - i * o),
            (this._w = s * c - n * o - i * a - r * l),
            this._onChangeCallback(),
            this
          )
        }
        slerp(t, e) {
          if (0 === e) return this
          if (1 === e) return this.copy(t)
          const n = this._x,
            i = this._y,
            r = this._z,
            s = this._w
          let o = s * t._w + n * t._x + i * t._y + r * t._z
          if (
            (o < 0
              ? ((this._w = -t._w),
                (this._x = -t._x),
                (this._y = -t._y),
                (this._z = -t._z),
                (o = -o))
              : this.copy(t),
            o >= 1)
          )
            return (
              (this._w = s), (this._x = n), (this._y = i), (this._z = r), this
            )
          const a = 1 - o * o
          if (a <= Number.EPSILON) {
            const t = 1 - e
            return (
              (this._w = t * s + e * this._w),
              (this._x = t * n + e * this._x),
              (this._y = t * i + e * this._y),
              (this._z = t * r + e * this._z),
              this.normalize(),
              this._onChangeCallback(),
              this
            )
          }
          const l = Math.sqrt(a),
            c = Math.atan2(l, o),
            u = Math.sin((1 - e) * c) / l,
            h = Math.sin(e * c) / l
          return (
            (this._w = s * u + this._w * h),
            (this._x = n * u + this._x * h),
            (this._y = i * u + this._y * h),
            (this._z = r * u + this._z * h),
            this._onChangeCallback(),
            this
          )
        }
        slerpQuaternions(t, e, n) {
          this.copy(t).slerp(e, n)
        }
        random() {
          const t = Math.random(),
            e = Math.sqrt(1 - t),
            n = Math.sqrt(t),
            i = 2 * Math.PI * Math.random(),
            r = 2 * Math.PI * Math.random()
          return this.set(
            e * Math.cos(i),
            n * Math.sin(r),
            n * Math.cos(r),
            e * Math.sin(i),
          )
        }
        equals(t) {
          return (
            t._x === this._x &&
            t._y === this._y &&
            t._z === this._z &&
            t._w === this._w
          )
        }
        fromArray(t, e = 0) {
          return (
            (this._x = t[e]),
            (this._y = t[e + 1]),
            (this._z = t[e + 2]),
            (this._w = t[e + 3]),
            this._onChangeCallback(),
            this
          )
        }
        toArray(t = [], e = 0) {
          return (
            (t[e] = this._x),
            (t[e + 1] = this._y),
            (t[e + 2] = this._z),
            (t[e + 3] = this._w),
            t
          )
        }
        fromBufferAttribute(t, e) {
          return (
            (this._x = t.getX(e)),
            (this._y = t.getY(e)),
            (this._z = t.getZ(e)),
            (this._w = t.getW(e)),
            this
          )
        }
        _onChange(t) {
          return (this._onChangeCallback = t), this
        }
        _onChangeCallback() {}
      }
      Sl.prototype.isQuaternion = !0
      class Tl {
        constructor(t = 0, e = 0, n = 0) {
          ;(this.x = t), (this.y = e), (this.z = n)
        }
        set(t, e, n) {
          return (
            void 0 === n && (n = this.z),
            (this.x = t),
            (this.y = e),
            (this.z = n),
            this
          )
        }
        setScalar(t) {
          return (this.x = t), (this.y = t), (this.z = t), this
        }
        setX(t) {
          return (this.x = t), this
        }
        setY(t) {
          return (this.y = t), this
        }
        setZ(t) {
          return (this.z = t), this
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e
              break
            case 1:
              this.y = e
              break
            case 2:
              this.z = e
              break
            default:
              throw new Error('index is out of range: ' + t)
          }
          return this
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x
            case 1:
              return this.y
            case 2:
              return this.z
            default:
              throw new Error('index is out of range: ' + t)
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z)
        }
        copy(t) {
          return (this.x = t.x), (this.y = t.y), (this.z = t.z), this
        }
        add(t, e) {
          return void 0 !== e
            ? (console.warn(
                'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.',
              ),
              this.addVectors(t, e))
            : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this)
        }
        addScalar(t) {
          return (this.x += t), (this.y += t), (this.z += t), this
        }
        addVectors(t, e) {
          return (
            (this.x = t.x + e.x),
            (this.y = t.y + e.y),
            (this.z = t.z + e.z),
            this
          )
        }
        addScaledVector(t, e) {
          return (
            (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
          )
        }
        sub(t, e) {
          return void 0 !== e
            ? (console.warn(
                'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.',
              ),
              this.subVectors(t, e))
            : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this)
        }
        subScalar(t) {
          return (this.x -= t), (this.y -= t), (this.z -= t), this
        }
        subVectors(t, e) {
          return (
            (this.x = t.x - e.x),
            (this.y = t.y - e.y),
            (this.z = t.z - e.z),
            this
          )
        }
        multiply(t, e) {
          return void 0 !== e
            ? (console.warn(
                'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.',
              ),
              this.multiplyVectors(t, e))
            : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this)
        }
        multiplyScalar(t) {
          return (this.x *= t), (this.y *= t), (this.z *= t), this
        }
        multiplyVectors(t, e) {
          return (
            (this.x = t.x * e.x),
            (this.y = t.y * e.y),
            (this.z = t.z * e.z),
            this
          )
        }
        applyEuler(t) {
          return (
            (t && t.isEuler) ||
              console.error(
                'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.',
              ),
            this.applyQuaternion(Dl.setFromEuler(t))
          )
        }
        applyAxisAngle(t, e) {
          return this.applyQuaternion(Dl.setFromAxisAngle(t, e))
        }
        applyMatrix3(t) {
          const e = this.x,
            n = this.y,
            i = this.z,
            r = t.elements
          return (
            (this.x = r[0] * e + r[3] * n + r[6] * i),
            (this.y = r[1] * e + r[4] * n + r[7] * i),
            (this.z = r[2] * e + r[5] * n + r[8] * i),
            this
          )
        }
        applyNormalMatrix(t) {
          return this.applyMatrix3(t).normalize()
        }
        applyMatrix4(t) {
          const e = this.x,
            n = this.y,
            i = this.z,
            r = t.elements,
            s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15])
          return (
            (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s),
            (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s),
            (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s),
            this
          )
        }
        applyQuaternion(t) {
          const e = this.x,
            n = this.y,
            i = this.z,
            r = t.x,
            s = t.y,
            o = t.z,
            a = t.w,
            l = a * e + s * i - o * n,
            c = a * n + o * e - r * i,
            u = a * i + r * n - s * e,
            h = -r * e - s * n - o * i
          return (
            (this.x = l * a + h * -r + c * -o - u * -s),
            (this.y = c * a + h * -s + u * -r - l * -o),
            (this.z = u * a + h * -o + l * -s - c * -r),
            this
          )
        }
        project(t) {
          return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
            t.projectionMatrix,
          )
        }
        unproject(t) {
          return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
            t.matrixWorld,
          )
        }
        transformDirection(t) {
          const e = this.x,
            n = this.y,
            i = this.z,
            r = t.elements
          return (
            (this.x = r[0] * e + r[4] * n + r[8] * i),
            (this.y = r[1] * e + r[5] * n + r[9] * i),
            (this.z = r[2] * e + r[6] * n + r[10] * i),
            this.normalize()
          )
        }
        divide(t) {
          return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t)
        }
        min(t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            (this.z = Math.min(this.z, t.z)),
            this
          )
        }
        max(t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            (this.z = Math.max(this.z, t.z)),
            this
          )
        }
        clamp(t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            (this.z = Math.max(t.z, Math.min(e.z, this.z))),
            this
          )
        }
        clampScalar(t, e) {
          return (
            (this.x = Math.max(t, Math.min(e, this.x))),
            (this.y = Math.max(t, Math.min(e, this.y))),
            (this.z = Math.max(t, Math.min(e, this.z))),
            this
          )
        }
        clampLength(t, e) {
          const n = this.length()
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(t, Math.min(e, n)),
          )
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            this
          )
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            this
          )
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            this
          )
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            this
          )
        }
        negate() {
          return (
            (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
          )
        }
        dot(t) {
          return this.x * t.x + this.y * t.y + this.z * t.z
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        }
        normalize() {
          return this.divideScalar(this.length() || 1)
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t)
        }
        lerp(t, e) {
          return (
            (this.x += (t.x - this.x) * e),
            (this.y += (t.y - this.y) * e),
            (this.z += (t.z - this.z) * e),
            this
          )
        }
        lerpVectors(t, e, n) {
          return (
            (this.x = t.x + (e.x - t.x) * n),
            (this.y = t.y + (e.y - t.y) * n),
            (this.z = t.z + (e.z - t.z) * n),
            this
          )
        }
        cross(t, e) {
          return void 0 !== e
            ? (console.warn(
                'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.',
              ),
              this.crossVectors(t, e))
            : this.crossVectors(this, t)
        }
        crossVectors(t, e) {
          const n = t.x,
            i = t.y,
            r = t.z,
            s = e.x,
            o = e.y,
            a = e.z
          return (
            (this.x = i * a - r * o),
            (this.y = r * s - n * a),
            (this.z = n * o - i * s),
            this
          )
        }
        projectOnVector(t) {
          const e = t.lengthSq()
          if (0 === e) return this.set(0, 0, 0)
          const n = t.dot(this) / e
          return this.copy(t).multiplyScalar(n)
        }
        projectOnPlane(t) {
          return El.copy(this).projectOnVector(t), this.sub(El)
        }
        reflect(t) {
          return this.sub(El.copy(t).multiplyScalar(2 * this.dot(t)))
        }
        angleTo(t) {
          const e = Math.sqrt(this.lengthSq() * t.lengthSq())
          if (0 === e) return Math.PI / 2
          const n = this.dot(t) / e
          return Math.acos(sl(n, -1, 1))
        }
        distanceTo(t) {
          return Math.sqrt(this.distanceToSquared(t))
        }
        distanceToSquared(t) {
          const e = this.x - t.x,
            n = this.y - t.y,
            i = this.z - t.z
          return e * e + n * n + i * i
        }
        manhattanDistanceTo(t) {
          return (
            Math.abs(this.x - t.x) +
            Math.abs(this.y - t.y) +
            Math.abs(this.z - t.z)
          )
        }
        setFromSpherical(t) {
          return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
        }
        setFromSphericalCoords(t, e, n) {
          const i = Math.sin(e) * t
          return (
            (this.x = i * Math.sin(n)),
            (this.y = Math.cos(e) * t),
            (this.z = i * Math.cos(n)),
            this
          )
        }
        setFromCylindrical(t) {
          return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
        }
        setFromCylindricalCoords(t, e, n) {
          return (
            (this.x = t * Math.sin(e)),
            (this.y = n),
            (this.z = t * Math.cos(e)),
            this
          )
        }
        setFromMatrixPosition(t) {
          const e = t.elements
          return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this
        }
        setFromMatrixScale(t) {
          const e = this.setFromMatrixColumn(t, 0).length(),
            n = this.setFromMatrixColumn(t, 1).length(),
            i = this.setFromMatrixColumn(t, 2).length()
          return (this.x = e), (this.y = n), (this.z = i), this
        }
        setFromMatrixColumn(t, e) {
          return this.fromArray(t.elements, 4 * e)
        }
        setFromMatrix3Column(t, e) {
          return this.fromArray(t.elements, 3 * e)
        }
        equals(t) {
          return t.x === this.x && t.y === this.y && t.z === this.z
        }
        fromArray(t, e = 0) {
          return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this
        }
        toArray(t = [], e = 0) {
          return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t
        }
        fromBufferAttribute(t, e, n) {
          return (
            void 0 !== n &&
              console.warn(
                'THREE.Vector3: offset has been removed from .fromBufferAttribute().',
              ),
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            (this.z = t.getZ(e)),
            this
          )
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            this
          )
        }
        randomDirection() {
          const t = 2 * (Math.random() - 0.5),
            e = Math.random() * Math.PI * 2,
            n = Math.sqrt(1 - t ** 2)
          return (
            (this.x = n * Math.cos(e)),
            (this.y = n * Math.sin(e)),
            (this.z = t),
            this
          )
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z
        }
      }
      Tl.prototype.isVector3 = !0
      const El = new Tl(),
        Dl = new Sl()
      class Al {
        constructor(
          t = new Tl(1 / 0, 1 / 0, 1 / 0),
          e = new Tl(-1 / 0, -1 / 0, -1 / 0),
        ) {
          ;(this.min = t), (this.max = e)
        }
        set(t, e) {
          return this.min.copy(t), this.max.copy(e), this
        }
        setFromArray(t) {
          let e = 1 / 0,
            n = 1 / 0,
            i = 1 / 0,
            r = -1 / 0,
            s = -1 / 0,
            o = -1 / 0
          for (let a = 0, l = t.length; a < l; a += 3) {
            const l = t[a],
              c = t[a + 1],
              u = t[a + 2]
            l < e && (e = l),
              c < n && (n = c),
              u < i && (i = u),
              l > r && (r = l),
              c > s && (s = c),
              u > o && (o = u)
          }
          return this.min.set(e, n, i), this.max.set(r, s, o), this
        }
        setFromBufferAttribute(t) {
          let e = 1 / 0,
            n = 1 / 0,
            i = 1 / 0,
            r = -1 / 0,
            s = -1 / 0,
            o = -1 / 0
          for (let a = 0, l = t.count; a < l; a++) {
            const l = t.getX(a),
              c = t.getY(a),
              u = t.getZ(a)
            l < e && (e = l),
              c < n && (n = c),
              u < i && (i = u),
              l > r && (r = l),
              c > s && (s = c),
              u > o && (o = u)
          }
          return this.min.set(e, n, i), this.max.set(r, s, o), this
        }
        setFromPoints(t) {
          this.makeEmpty()
          for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e])
          return this
        }
        setFromCenterAndSize(t, e) {
          const n = Ll.copy(e).multiplyScalar(0.5)
          return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
        }
        setFromObject(t) {
          return this.makeEmpty(), this.expandByObject(t)
        }
        clone() {
          return new this.constructor().copy(this)
        }
        copy(t) {
          return this.min.copy(t.min), this.max.copy(t.max), this
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = this.min.z = 1 / 0),
            (this.max.x = this.max.y = this.max.z = -1 / 0),
            this
          )
        }
        isEmpty() {
          return (
            this.max.x < this.min.x ||
            this.max.y < this.min.y ||
            this.max.z < this.min.z
          )
        }
        getCenter(t) {
          return this.isEmpty()
            ? t.set(0, 0, 0)
            : t.addVectors(this.min, this.max).multiplyScalar(0.5)
        }
        getSize(t) {
          return this.isEmpty()
            ? t.set(0, 0, 0)
            : t.subVectors(this.max, this.min)
        }
        expandByPoint(t) {
          return this.min.min(t), this.max.max(t), this
        }
        expandByVector(t) {
          return this.min.sub(t), this.max.add(t), this
        }
        expandByScalar(t) {
          return this.min.addScalar(-t), this.max.addScalar(t), this
        }
        expandByObject(t) {
          t.updateWorldMatrix(!1, !1)
          const e = t.geometry
          void 0 !== e &&
            (null === e.boundingBox && e.computeBoundingBox(),
            Rl.copy(e.boundingBox),
            Rl.applyMatrix4(t.matrixWorld),
            this.union(Rl))
          const n = t.children
          for (let t = 0, e = n.length; t < e; t++) this.expandByObject(n[t])
          return this
        }
        containsPoint(t) {
          return !(
            t.x < this.min.x ||
            t.x > this.max.x ||
            t.y < this.min.y ||
            t.y > this.max.y ||
            t.z < this.min.z ||
            t.z > this.max.z
          )
        }
        containsBox(t) {
          return (
            this.min.x <= t.min.x &&
            t.max.x <= this.max.x &&
            this.min.y <= t.min.y &&
            t.max.y <= this.max.y &&
            this.min.z <= t.min.z &&
            t.max.z <= this.max.z
          )
        }
        getParameter(t, e) {
          return e.set(
            (t.x - this.min.x) / (this.max.x - this.min.x),
            (t.y - this.min.y) / (this.max.y - this.min.y),
            (t.z - this.min.z) / (this.max.z - this.min.z),
          )
        }
        intersectsBox(t) {
          return !(
            t.max.x < this.min.x ||
            t.min.x > this.max.x ||
            t.max.y < this.min.y ||
            t.min.y > this.max.y ||
            t.max.z < this.min.z ||
            t.min.z > this.max.z
          )
        }
        intersectsSphere(t) {
          return (
            this.clampPoint(t.center, Ll),
            Ll.distanceToSquared(t.center) <= t.radius * t.radius
          )
        }
        intersectsPlane(t) {
          let e, n
          return (
            t.normal.x > 0
              ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
              : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
            t.normal.y > 0
              ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
              : ((e += t.normal.y * this.max.y),
                (n += t.normal.y * this.min.y)),
            t.normal.z > 0
              ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
              : ((e += t.normal.z * this.max.z),
                (n += t.normal.z * this.min.z)),
            e <= -t.constant && n >= -t.constant
          )
        }
        intersectsTriangle(t) {
          if (this.isEmpty()) return !1
          this.getCenter(Bl),
            zl.subVectors(this.max, Bl),
            Pl.subVectors(t.a, Bl),
            Fl.subVectors(t.b, Bl),
            Il.subVectors(t.c, Bl),
            Ol.subVectors(Fl, Pl),
            Nl.subVectors(Il, Fl),
            kl.subVectors(Pl, Il)
          let e = [
            0,
            -Ol.z,
            Ol.y,
            0,
            -Nl.z,
            Nl.y,
            0,
            -kl.z,
            kl.y,
            Ol.z,
            0,
            -Ol.x,
            Nl.z,
            0,
            -Nl.x,
            kl.z,
            0,
            -kl.x,
            -Ol.y,
            Ol.x,
            0,
            -Nl.y,
            Nl.x,
            0,
            -kl.y,
            kl.x,
            0,
          ]
          return (
            !!Gl(e, Pl, Fl, Il, zl) &&
            ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            !!Gl(e, Pl, Fl, Il, zl) &&
              (Ul.crossVectors(Ol, Nl),
              (e = [Ul.x, Ul.y, Ul.z]),
              Gl(e, Pl, Fl, Il, zl)))
          )
        }
        clampPoint(t, e) {
          return e.copy(t).clamp(this.min, this.max)
        }
        distanceToPoint(t) {
          return Ll.copy(t).clamp(this.min, this.max).sub(t).length()
        }
        getBoundingSphere(t) {
          return (
            this.getCenter(t.center),
            (t.radius = 0.5 * this.getSize(Ll).length()),
            t
          )
        }
        intersect(t) {
          return (
            this.min.max(t.min),
            this.max.min(t.max),
            this.isEmpty() && this.makeEmpty(),
            this
          )
        }
        union(t) {
          return this.min.min(t.min), this.max.max(t.max), this
        }
        applyMatrix4(t) {
          return (
            this.isEmpty() ||
              (Cl[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
              Cl[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
              Cl[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
              Cl[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
              Cl[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
              Cl[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
              Cl[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
              Cl[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
              this.setFromPoints(Cl)),
            this
          )
        }
        translate(t) {
          return this.min.add(t), this.max.add(t), this
        }
        equals(t) {
          return t.min.equals(this.min) && t.max.equals(this.max)
        }
      }
      Al.prototype.isBox3 = !0
      const Cl = [
          new Tl(),
          new Tl(),
          new Tl(),
          new Tl(),
          new Tl(),
          new Tl(),
          new Tl(),
          new Tl(),
        ],
        Ll = new Tl(),
        Rl = new Al(),
        Pl = new Tl(),
        Fl = new Tl(),
        Il = new Tl(),
        Ol = new Tl(),
        Nl = new Tl(),
        kl = new Tl(),
        Bl = new Tl(),
        zl = new Tl(),
        Ul = new Tl(),
        Hl = new Tl()
      function Gl(t, e, n, i, r) {
        for (let s = 0, o = t.length - 3; s <= o; s += 3) {
          Hl.fromArray(t, s)
          const o =
              r.x * Math.abs(Hl.x) +
              r.y * Math.abs(Hl.y) +
              r.z * Math.abs(Hl.z),
            a = e.dot(Hl),
            l = n.dot(Hl),
            c = i.dot(Hl)
          if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > o) return !1
        }
        return !0
      }
      const Vl = new Al(),
        Wl = new Tl(),
        jl = new Tl(),
        ql = new Tl()
      class Xl {
        constructor(t = new Tl(), e = -1) {
          ;(this.center = t), (this.radius = e)
        }
        set(t, e) {
          return this.center.copy(t), (this.radius = e), this
        }
        setFromPoints(t, e) {
          const n = this.center
          void 0 !== e ? n.copy(e) : Vl.setFromPoints(t).getCenter(n)
          let i = 0
          for (let e = 0, r = t.length; e < r; e++)
            i = Math.max(i, n.distanceToSquared(t[e]))
          return (this.radius = Math.sqrt(i)), this
        }
        copy(t) {
          return this.center.copy(t.center), (this.radius = t.radius), this
        }
        isEmpty() {
          return this.radius < 0
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), (this.radius = -1), this
        }
        containsPoint(t) {
          return t.distanceToSquared(this.center) <= this.radius * this.radius
        }
        distanceToPoint(t) {
          return t.distanceTo(this.center) - this.radius
        }
        intersectsSphere(t) {
          const e = this.radius + t.radius
          return t.center.distanceToSquared(this.center) <= e * e
        }
        intersectsBox(t) {
          return t.intersectsSphere(this)
        }
        intersectsPlane(t) {
          return Math.abs(t.distanceToPoint(this.center)) <= this.radius
        }
        clampPoint(t, e) {
          const n = this.center.distanceToSquared(t)
          return (
            e.copy(t),
            n > this.radius * this.radius &&
              (e.sub(this.center).normalize(),
              e.multiplyScalar(this.radius).add(this.center)),
            e
          )
        }
        getBoundingBox(t) {
          return this.isEmpty()
            ? (t.makeEmpty(), t)
            : (t.set(this.center, this.center),
              t.expandByScalar(this.radius),
              t)
        }
        applyMatrix4(t) {
          return (
            this.center.applyMatrix4(t),
            (this.radius = this.radius * t.getMaxScaleOnAxis()),
            this
          )
        }
        translate(t) {
          return this.center.add(t), this
        }
        expandByPoint(t) {
          ql.subVectors(t, this.center)
          const e = ql.lengthSq()
          if (e > this.radius * this.radius) {
            const t = Math.sqrt(e),
              n = 0.5 * (t - this.radius)
            this.center.add(ql.multiplyScalar(n / t)), (this.radius += n)
          }
          return this
        }
        union(t) {
          return (
            jl
              .subVectors(t.center, this.center)
              .normalize()
              .multiplyScalar(t.radius),
            this.expandByPoint(Wl.copy(t.center).add(jl)),
            this.expandByPoint(Wl.copy(t.center).sub(jl)),
            this
          )
        }
        equals(t) {
          return t.center.equals(this.center) && t.radius === this.radius
        }
        clone() {
          return new this.constructor().copy(this)
        }
      }
      const Yl = new Tl(),
        Jl = new Tl(),
        Zl = new Tl(),
        Kl = new Tl(),
        Ql = new Tl(),
        $l = new Tl(),
        tc = new Tl()
      class ec {
        constructor(t = new Tl(), e = new Tl(0, 0, -1)) {
          ;(this.origin = t), (this.direction = e)
        }
        set(t, e) {
          return this.origin.copy(t), this.direction.copy(e), this
        }
        copy(t) {
          return (
            this.origin.copy(t.origin), this.direction.copy(t.direction), this
          )
        }
        at(t, e) {
          return e.copy(this.direction).multiplyScalar(t).add(this.origin)
        }
        lookAt(t) {
          return this.direction.copy(t).sub(this.origin).normalize(), this
        }
        recast(t) {
          return this.origin.copy(this.at(t, Yl)), this
        }
        closestPointToPoint(t, e) {
          e.subVectors(t, this.origin)
          const n = e.dot(this.direction)
          return n < 0
            ? e.copy(this.origin)
            : e.copy(this.direction).multiplyScalar(n).add(this.origin)
        }
        distanceToPoint(t) {
          return Math.sqrt(this.distanceSqToPoint(t))
        }
        distanceSqToPoint(t) {
          const e = Yl.subVectors(t, this.origin).dot(this.direction)
          return e < 0
            ? this.origin.distanceToSquared(t)
            : (Yl.copy(this.direction).multiplyScalar(e).add(this.origin),
              Yl.distanceToSquared(t))
        }
        distanceSqToSegment(t, e, n, i) {
          Jl.copy(t).add(e).multiplyScalar(0.5),
            Zl.copy(e).sub(t).normalize(),
            Kl.copy(this.origin).sub(Jl)
          const r = 0.5 * t.distanceTo(e),
            s = -this.direction.dot(Zl),
            o = Kl.dot(this.direction),
            a = -Kl.dot(Zl),
            l = Kl.lengthSq(),
            c = Math.abs(1 - s * s)
          let u, h, d, p
          if (c > 0)
            if (((u = s * a - o), (h = s * o - a), (p = r * c), u >= 0))
              if (h >= -p)
                if (h <= p) {
                  const t = 1 / c
                  ;(u *= t),
                    (h *= t),
                    (d = u * (u + s * h + 2 * o) + h * (s * u + h + 2 * a) + l)
                } else
                  (h = r),
                    (u = Math.max(0, -(s * h + o))),
                    (d = -u * u + h * (h + 2 * a) + l)
              else
                (h = -r),
                  (u = Math.max(0, -(s * h + o))),
                  (d = -u * u + h * (h + 2 * a) + l)
            else
              h <= -p
                ? ((u = Math.max(0, -(-s * r + o))),
                  (h = u > 0 ? -r : Math.min(Math.max(-r, -a), r)),
                  (d = -u * u + h * (h + 2 * a) + l))
                : h <= p
                ? ((u = 0),
                  (h = Math.min(Math.max(-r, -a), r)),
                  (d = h * (h + 2 * a) + l))
                : ((u = Math.max(0, -(s * r + o))),
                  (h = u > 0 ? r : Math.min(Math.max(-r, -a), r)),
                  (d = -u * u + h * (h + 2 * a) + l))
          else
            (h = s > 0 ? -r : r),
              (u = Math.max(0, -(s * h + o))),
              (d = -u * u + h * (h + 2 * a) + l)
          return (
            n && n.copy(this.direction).multiplyScalar(u).add(this.origin),
            i && i.copy(Zl).multiplyScalar(h).add(Jl),
            d
          )
        }
        intersectSphere(t, e) {
          Yl.subVectors(t.center, this.origin)
          const n = Yl.dot(this.direction),
            i = Yl.dot(Yl) - n * n,
            r = t.radius * t.radius
          if (i > r) return null
          const s = Math.sqrt(r - i),
            o = n - s,
            a = n + s
          return o < 0 && a < 0 ? null : o < 0 ? this.at(a, e) : this.at(o, e)
        }
        intersectsSphere(t) {
          return this.distanceSqToPoint(t.center) <= t.radius * t.radius
        }
        distanceToPlane(t) {
          const e = t.normal.dot(this.direction)
          if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null
          const n = -(this.origin.dot(t.normal) + t.constant) / e
          return n >= 0 ? n : null
        }
        intersectPlane(t, e) {
          const n = this.distanceToPlane(t)
          return null === n ? null : this.at(n, e)
        }
        intersectsPlane(t) {
          const e = t.distanceToPoint(this.origin)
          return 0 === e || t.normal.dot(this.direction) * e < 0
        }
        intersectBox(t, e) {
          let n, i, r, s, o, a
          const l = 1 / this.direction.x,
            c = 1 / this.direction.y,
            u = 1 / this.direction.z,
            h = this.origin
          return (
            l >= 0
              ? ((n = (t.min.x - h.x) * l), (i = (t.max.x - h.x) * l))
              : ((n = (t.max.x - h.x) * l), (i = (t.min.x - h.x) * l)),
            c >= 0
              ? ((r = (t.min.y - h.y) * c), (s = (t.max.y - h.y) * c))
              : ((r = (t.max.y - h.y) * c), (s = (t.min.y - h.y) * c)),
            n > s || r > i
              ? null
              : ((r > n || n != n) && (n = r),
                (s < i || i != i) && (i = s),
                u >= 0
                  ? ((o = (t.min.z - h.z) * u), (a = (t.max.z - h.z) * u))
                  : ((o = (t.max.z - h.z) * u), (a = (t.min.z - h.z) * u)),
                n > a || o > i
                  ? null
                  : ((o > n || n != n) && (n = o),
                    (a < i || i != i) && (i = a),
                    i < 0 ? null : this.at(n >= 0 ? n : i, e)))
          )
        }
        intersectsBox(t) {
          return null !== this.intersectBox(t, Yl)
        }
        intersectTriangle(t, e, n, i, r) {
          Ql.subVectors(e, t), $l.subVectors(n, t), tc.crossVectors(Ql, $l)
          let s,
            o = this.direction.dot(tc)
          if (o > 0) {
            if (i) return null
            s = 1
          } else {
            if (!(o < 0)) return null
            ;(s = -1), (o = -o)
          }
          Kl.subVectors(this.origin, t)
          const a = s * this.direction.dot($l.crossVectors(Kl, $l))
          if (a < 0) return null
          const l = s * this.direction.dot(Ql.cross(Kl))
          if (l < 0) return null
          if (a + l > o) return null
          const c = -s * Kl.dot(tc)
          return c < 0 ? null : this.at(c / o, r)
        }
        applyMatrix4(t) {
          return (
            this.origin.applyMatrix4(t),
            this.direction.transformDirection(t),
            this
          )
        }
        equals(t) {
          return (
            t.origin.equals(this.origin) && t.direction.equals(this.direction)
          )
        }
        clone() {
          return new this.constructor().copy(this)
        }
      }
      class nc {
        constructor() {
          ;(this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
            arguments.length > 0 &&
              console.error(
                'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.',
              )
        }
        set(t, e, n, i, r, s, o, a, l, c, u, h, d, p, f, m) {
          const g = this.elements
          return (
            (g[0] = t),
            (g[4] = e),
            (g[8] = n),
            (g[12] = i),
            (g[1] = r),
            (g[5] = s),
            (g[9] = o),
            (g[13] = a),
            (g[2] = l),
            (g[6] = c),
            (g[10] = u),
            (g[14] = h),
            (g[3] = d),
            (g[7] = p),
            (g[11] = f),
            (g[15] = m),
            this
          )
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        }
        clone() {
          return new nc().fromArray(this.elements)
        }
        copy(t) {
          const e = this.elements,
            n = t.elements
          return (
            (e[0] = n[0]),
            (e[1] = n[1]),
            (e[2] = n[2]),
            (e[3] = n[3]),
            (e[4] = n[4]),
            (e[5] = n[5]),
            (e[6] = n[6]),
            (e[7] = n[7]),
            (e[8] = n[8]),
            (e[9] = n[9]),
            (e[10] = n[10]),
            (e[11] = n[11]),
            (e[12] = n[12]),
            (e[13] = n[13]),
            (e[14] = n[14]),
            (e[15] = n[15]),
            this
          )
        }
        copyPosition(t) {
          const e = this.elements,
            n = t.elements
          return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this
        }
        setFromMatrix3(t) {
          const e = t.elements
          return (
            this.set(
              e[0],
              e[3],
              e[6],
              0,
              e[1],
              e[4],
              e[7],
              0,
              e[2],
              e[5],
              e[8],
              0,
              0,
              0,
              0,
              1,
            ),
            this
          )
        }
        extractBasis(t, e, n) {
          return (
            t.setFromMatrixColumn(this, 0),
            e.setFromMatrixColumn(this, 1),
            n.setFromMatrixColumn(this, 2),
            this
          )
        }
        makeBasis(t, e, n) {
          return (
            this.set(
              t.x,
              e.x,
              n.x,
              0,
              t.y,
              e.y,
              n.y,
              0,
              t.z,
              e.z,
              n.z,
              0,
              0,
              0,
              0,
              1,
            ),
            this
          )
        }
        extractRotation(t) {
          const e = this.elements,
            n = t.elements,
            i = 1 / ic.setFromMatrixColumn(t, 0).length(),
            r = 1 / ic.setFromMatrixColumn(t, 1).length(),
            s = 1 / ic.setFromMatrixColumn(t, 2).length()
          return (
            (e[0] = n[0] * i),
            (e[1] = n[1] * i),
            (e[2] = n[2] * i),
            (e[3] = 0),
            (e[4] = n[4] * r),
            (e[5] = n[5] * r),
            (e[6] = n[6] * r),
            (e[7] = 0),
            (e[8] = n[8] * s),
            (e[9] = n[9] * s),
            (e[10] = n[10] * s),
            (e[11] = 0),
            (e[12] = 0),
            (e[13] = 0),
            (e[14] = 0),
            (e[15] = 1),
            this
          )
        }
        makeRotationFromEuler(t) {
          ;(t && t.isEuler) ||
            console.error(
              'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.',
            )
          const e = this.elements,
            n = t.x,
            i = t.y,
            r = t.z,
            s = Math.cos(n),
            o = Math.sin(n),
            a = Math.cos(i),
            l = Math.sin(i),
            c = Math.cos(r),
            u = Math.sin(r)
          if ('XYZ' === t.order) {
            const t = s * c,
              n = s * u,
              i = o * c,
              r = o * u
            ;(e[0] = a * c),
              (e[4] = -a * u),
              (e[8] = l),
              (e[1] = n + i * l),
              (e[5] = t - r * l),
              (e[9] = -o * a),
              (e[2] = r - t * l),
              (e[6] = i + n * l),
              (e[10] = s * a)
          } else if ('YXZ' === t.order) {
            const t = a * c,
              n = a * u,
              i = l * c,
              r = l * u
            ;(e[0] = t + r * o),
              (e[4] = i * o - n),
              (e[8] = s * l),
              (e[1] = s * u),
              (e[5] = s * c),
              (e[9] = -o),
              (e[2] = n * o - i),
              (e[6] = r + t * o),
              (e[10] = s * a)
          } else if ('ZXY' === t.order) {
            const t = a * c,
              n = a * u,
              i = l * c,
              r = l * u
            ;(e[0] = t - r * o),
              (e[4] = -s * u),
              (e[8] = i + n * o),
              (e[1] = n + i * o),
              (e[5] = s * c),
              (e[9] = r - t * o),
              (e[2] = -s * l),
              (e[6] = o),
              (e[10] = s * a)
          } else if ('ZYX' === t.order) {
            const t = s * c,
              n = s * u,
              i = o * c,
              r = o * u
            ;(e[0] = a * c),
              (e[4] = i * l - n),
              (e[8] = t * l + r),
              (e[1] = a * u),
              (e[5] = r * l + t),
              (e[9] = n * l - i),
              (e[2] = -l),
              (e[6] = o * a),
              (e[10] = s * a)
          } else if ('YZX' === t.order) {
            const t = s * a,
              n = s * l,
              i = o * a,
              r = o * l
            ;(e[0] = a * c),
              (e[4] = r - t * u),
              (e[8] = i * u + n),
              (e[1] = u),
              (e[5] = s * c),
              (e[9] = -o * c),
              (e[2] = -l * c),
              (e[6] = n * u + i),
              (e[10] = t - r * u)
          } else if ('XZY' === t.order) {
            const t = s * a,
              n = s * l,
              i = o * a,
              r = o * l
            ;(e[0] = a * c),
              (e[4] = -u),
              (e[8] = l * c),
              (e[1] = t * u + r),
              (e[5] = s * c),
              (e[9] = n * u - i),
              (e[2] = i * u - n),
              (e[6] = o * c),
              (e[10] = r * u + t)
          }
          return (
            (e[3] = 0),
            (e[7] = 0),
            (e[11] = 0),
            (e[12] = 0),
            (e[13] = 0),
            (e[14] = 0),
            (e[15] = 1),
            this
          )
        }
        makeRotationFromQuaternion(t) {
          return this.compose(sc, t, oc)
        }
        lookAt(t, e, n) {
          const i = this.elements
          return (
            cc.subVectors(t, e),
            0 === cc.lengthSq() && (cc.z = 1),
            cc.normalize(),
            ac.crossVectors(n, cc),
            0 === ac.lengthSq() &&
              (1 === Math.abs(n.z) ? (cc.x += 1e-4) : (cc.z += 1e-4),
              cc.normalize(),
              ac.crossVectors(n, cc)),
            ac.normalize(),
            lc.crossVectors(cc, ac),
            (i[0] = ac.x),
            (i[4] = lc.x),
            (i[8] = cc.x),
            (i[1] = ac.y),
            (i[5] = lc.y),
            (i[9] = cc.y),
            (i[2] = ac.z),
            (i[6] = lc.z),
            (i[10] = cc.z),
            this
          )
        }
        multiply(t, e) {
          return void 0 !== e
            ? (console.warn(
                'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.',
              ),
              this.multiplyMatrices(t, e))
            : this.multiplyMatrices(this, t)
        }
        premultiply(t) {
          return this.multiplyMatrices(t, this)
        }
        multiplyMatrices(t, e) {
          const n = t.elements,
            i = e.elements,
            r = this.elements,
            s = n[0],
            o = n[4],
            a = n[8],
            l = n[12],
            c = n[1],
            u = n[5],
            h = n[9],
            d = n[13],
            p = n[2],
            f = n[6],
            m = n[10],
            g = n[14],
            v = n[3],
            _ = n[7],
            y = n[11],
            x = n[15],
            b = i[0],
            w = i[4],
            M = i[8],
            S = i[12],
            T = i[1],
            E = i[5],
            D = i[9],
            A = i[13],
            C = i[2],
            L = i[6],
            R = i[10],
            P = i[14],
            F = i[3],
            I = i[7],
            O = i[11],
            N = i[15]
          return (
            (r[0] = s * b + o * T + a * C + l * F),
            (r[4] = s * w + o * E + a * L + l * I),
            (r[8] = s * M + o * D + a * R + l * O),
            (r[12] = s * S + o * A + a * P + l * N),
            (r[1] = c * b + u * T + h * C + d * F),
            (r[5] = c * w + u * E + h * L + d * I),
            (r[9] = c * M + u * D + h * R + d * O),
            (r[13] = c * S + u * A + h * P + d * N),
            (r[2] = p * b + f * T + m * C + g * F),
            (r[6] = p * w + f * E + m * L + g * I),
            (r[10] = p * M + f * D + m * R + g * O),
            (r[14] = p * S + f * A + m * P + g * N),
            (r[3] = v * b + _ * T + y * C + x * F),
            (r[7] = v * w + _ * E + y * L + x * I),
            (r[11] = v * M + _ * D + y * R + x * O),
            (r[15] = v * S + _ * A + y * P + x * N),
            this
          )
        }
        multiplyScalar(t) {
          const e = this.elements
          return (
            (e[0] *= t),
            (e[4] *= t),
            (e[8] *= t),
            (e[12] *= t),
            (e[1] *= t),
            (e[5] *= t),
            (e[9] *= t),
            (e[13] *= t),
            (e[2] *= t),
            (e[6] *= t),
            (e[10] *= t),
            (e[14] *= t),
            (e[3] *= t),
            (e[7] *= t),
            (e[11] *= t),
            (e[15] *= t),
            this
          )
        }
        determinant() {
          const t = this.elements,
            e = t[0],
            n = t[4],
            i = t[8],
            r = t[12],
            s = t[1],
            o = t[5],
            a = t[9],
            l = t[13],
            c = t[2],
            u = t[6],
            h = t[10],
            d = t[14]
          return (
            t[3] *
              (+r * a * u -
                i * l * u -
                r * o * h +
                n * l * h +
                i * o * d -
                n * a * d) +
            t[7] *
              (+e * a * d -
                e * l * h +
                r * s * h -
                i * s * d +
                i * l * c -
                r * a * c) +
            t[11] *
              (+e * l * u -
                e * o * d -
                r * s * u +
                n * s * d +
                r * o * c -
                n * l * c) +
            t[15] *
              (-i * o * c -
                e * a * u +
                e * o * h +
                i * s * u -
                n * s * h +
                n * a * c)
          )
        }
        transpose() {
          const t = this.elements
          let e
          return (
            (e = t[1]),
            (t[1] = t[4]),
            (t[4] = e),
            (e = t[2]),
            (t[2] = t[8]),
            (t[8] = e),
            (e = t[6]),
            (t[6] = t[9]),
            (t[9] = e),
            (e = t[3]),
            (t[3] = t[12]),
            (t[12] = e),
            (e = t[7]),
            (t[7] = t[13]),
            (t[13] = e),
            (e = t[11]),
            (t[11] = t[14]),
            (t[14] = e),
            this
          )
        }
        setPosition(t, e, n) {
          const i = this.elements
          return (
            t.isVector3
              ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
              : ((i[12] = t), (i[13] = e), (i[14] = n)),
            this
          )
        }
        invert() {
          const t = this.elements,
            e = t[0],
            n = t[1],
            i = t[2],
            r = t[3],
            s = t[4],
            o = t[5],
            a = t[6],
            l = t[7],
            c = t[8],
            u = t[9],
            h = t[10],
            d = t[11],
            p = t[12],
            f = t[13],
            m = t[14],
            g = t[15],
            v =
              u * m * l -
              f * h * l +
              f * a * d -
              o * m * d -
              u * a * g +
              o * h * g,
            _ =
              p * h * l -
              c * m * l -
              p * a * d +
              s * m * d +
              c * a * g -
              s * h * g,
            y =
              c * f * l -
              p * u * l +
              p * o * d -
              s * f * d -
              c * o * g +
              s * u * g,
            x =
              p * u * a -
              c * f * a -
              p * o * h +
              s * f * h +
              c * o * m -
              s * u * m,
            b = e * v + n * _ + i * y + r * x
          if (0 === b)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
          const w = 1 / b
          return (
            (t[0] = v * w),
            (t[1] =
              (f * h * r -
                u * m * r -
                f * i * d +
                n * m * d +
                u * i * g -
                n * h * g) *
              w),
            (t[2] =
              (o * m * r -
                f * a * r +
                f * i * l -
                n * m * l -
                o * i * g +
                n * a * g) *
              w),
            (t[3] =
              (u * a * r -
                o * h * r -
                u * i * l +
                n * h * l +
                o * i * d -
                n * a * d) *
              w),
            (t[4] = _ * w),
            (t[5] =
              (c * m * r -
                p * h * r +
                p * i * d -
                e * m * d -
                c * i * g +
                e * h * g) *
              w),
            (t[6] =
              (p * a * r -
                s * m * r -
                p * i * l +
                e * m * l +
                s * i * g -
                e * a * g) *
              w),
            (t[7] =
              (s * h * r -
                c * a * r +
                c * i * l -
                e * h * l -
                s * i * d +
                e * a * d) *
              w),
            (t[8] = y * w),
            (t[9] =
              (p * u * r -
                c * f * r -
                p * n * d +
                e * f * d +
                c * n * g -
                e * u * g) *
              w),
            (t[10] =
              (s * f * r -
                p * o * r +
                p * n * l -
                e * f * l -
                s * n * g +
                e * o * g) *
              w),
            (t[11] =
              (c * o * r -
                s * u * r -
                c * n * l +
                e * u * l +
                s * n * d -
                e * o * d) *
              w),
            (t[12] = x * w),
            (t[13] =
              (c * f * i -
                p * u * i +
                p * n * h -
                e * f * h -
                c * n * m +
                e * u * m) *
              w),
            (t[14] =
              (p * o * i -
                s * f * i -
                p * n * a +
                e * f * a +
                s * n * m -
                e * o * m) *
              w),
            (t[15] =
              (s * u * i -
                c * o * i +
                c * n * a -
                e * u * a -
                s * n * h +
                e * o * h) *
              w),
            this
          )
        }
        scale(t) {
          const e = this.elements,
            n = t.x,
            i = t.y,
            r = t.z
          return (
            (e[0] *= n),
            (e[4] *= i),
            (e[8] *= r),
            (e[1] *= n),
            (e[5] *= i),
            (e[9] *= r),
            (e[2] *= n),
            (e[6] *= i),
            (e[10] *= r),
            (e[3] *= n),
            (e[7] *= i),
            (e[11] *= r),
            this
          )
        }
        getMaxScaleOnAxis() {
          const t = this.elements,
            e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
            n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
            i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10]
          return Math.sqrt(Math.max(e, n, i))
        }
        makeTranslation(t, e, n) {
          return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
        }
        makeRotationX(t) {
          const e = Math.cos(t),
            n = Math.sin(t)
          return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
        }
        makeRotationY(t) {
          const e = Math.cos(t),
            n = Math.sin(t)
          return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
        }
        makeRotationZ(t) {
          const e = Math.cos(t),
            n = Math.sin(t)
          return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        }
        makeRotationAxis(t, e) {
          const n = Math.cos(e),
            i = Math.sin(e),
            r = 1 - n,
            s = t.x,
            o = t.y,
            a = t.z,
            l = r * s,
            c = r * o
          return (
            this.set(
              l * s + n,
              l * o - i * a,
              l * a + i * o,
              0,
              l * o + i * a,
              c * o + n,
              c * a - i * s,
              0,
              l * a - i * o,
              c * a + i * s,
              r * a * a + n,
              0,
              0,
              0,
              0,
              1,
            ),
            this
          )
        }
        makeScale(t, e, n) {
          return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
        }
        makeShear(t, e, n, i, r, s) {
          return this.set(1, n, r, 0, t, 1, s, 0, e, i, 1, 0, 0, 0, 0, 1), this
        }
        compose(t, e, n) {
          const i = this.elements,
            r = e._x,
            s = e._y,
            o = e._z,
            a = e._w,
            l = r + r,
            c = s + s,
            u = o + o,
            h = r * l,
            d = r * c,
            p = r * u,
            f = s * c,
            m = s * u,
            g = o * u,
            v = a * l,
            _ = a * c,
            y = a * u,
            x = n.x,
            b = n.y,
            w = n.z
          return (
            (i[0] = (1 - (f + g)) * x),
            (i[1] = (d + y) * x),
            (i[2] = (p - _) * x),
            (i[3] = 0),
            (i[4] = (d - y) * b),
            (i[5] = (1 - (h + g)) * b),
            (i[6] = (m + v) * b),
            (i[7] = 0),
            (i[8] = (p + _) * w),
            (i[9] = (m - v) * w),
            (i[10] = (1 - (h + f)) * w),
            (i[11] = 0),
            (i[12] = t.x),
            (i[13] = t.y),
            (i[14] = t.z),
            (i[15] = 1),
            this
          )
        }
        decompose(t, e, n) {
          const i = this.elements
          let r = ic.set(i[0], i[1], i[2]).length()
          const s = ic.set(i[4], i[5], i[6]).length(),
            o = ic.set(i[8], i[9], i[10]).length()
          this.determinant() < 0 && (r = -r),
            (t.x = i[12]),
            (t.y = i[13]),
            (t.z = i[14]),
            rc.copy(this)
          const a = 1 / r,
            l = 1 / s,
            c = 1 / o
          return (
            (rc.elements[0] *= a),
            (rc.elements[1] *= a),
            (rc.elements[2] *= a),
            (rc.elements[4] *= l),
            (rc.elements[5] *= l),
            (rc.elements[6] *= l),
            (rc.elements[8] *= c),
            (rc.elements[9] *= c),
            (rc.elements[10] *= c),
            e.setFromRotationMatrix(rc),
            (n.x = r),
            (n.y = s),
            (n.z = o),
            this
          )
        }
        makePerspective(t, e, n, i, r, s) {
          void 0 === s &&
            console.warn(
              'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.',
            )
          const o = this.elements,
            a = (2 * r) / (e - t),
            l = (2 * r) / (n - i),
            c = (e + t) / (e - t),
            u = (n + i) / (n - i),
            h = -(s + r) / (s - r),
            d = (-2 * s * r) / (s - r)
          return (
            (o[0] = a),
            (o[4] = 0),
            (o[8] = c),
            (o[12] = 0),
            (o[1] = 0),
            (o[5] = l),
            (o[9] = u),
            (o[13] = 0),
            (o[2] = 0),
            (o[6] = 0),
            (o[10] = h),
            (o[14] = d),
            (o[3] = 0),
            (o[7] = 0),
            (o[11] = -1),
            (o[15] = 0),
            this
          )
        }
        makeOrthographic(t, e, n, i, r, s) {
          const o = this.elements,
            a = 1 / (e - t),
            l = 1 / (n - i),
            c = 1 / (s - r),
            u = (e + t) * a,
            h = (n + i) * l,
            d = (s + r) * c
          return (
            (o[0] = 2 * a),
            (o[4] = 0),
            (o[8] = 0),
            (o[12] = -u),
            (o[1] = 0),
            (o[5] = 2 * l),
            (o[9] = 0),
            (o[13] = -h),
            (o[2] = 0),
            (o[6] = 0),
            (o[10] = -2 * c),
            (o[14] = -d),
            (o[3] = 0),
            (o[7] = 0),
            (o[11] = 0),
            (o[15] = 1),
            this
          )
        }
        equals(t) {
          const e = this.elements,
            n = t.elements
          for (let t = 0; t < 16; t++) if (e[t] !== n[t]) return !1
          return !0
        }
        fromArray(t, e = 0) {
          for (let n = 0; n < 16; n++) this.elements[n] = t[n + e]
          return this
        }
        toArray(t = [], e = 0) {
          const n = this.elements
          return (
            (t[e] = n[0]),
            (t[e + 1] = n[1]),
            (t[e + 2] = n[2]),
            (t[e + 3] = n[3]),
            (t[e + 4] = n[4]),
            (t[e + 5] = n[5]),
            (t[e + 6] = n[6]),
            (t[e + 7] = n[7]),
            (t[e + 8] = n[8]),
            (t[e + 9] = n[9]),
            (t[e + 10] = n[10]),
            (t[e + 11] = n[11]),
            (t[e + 12] = n[12]),
            (t[e + 13] = n[13]),
            (t[e + 14] = n[14]),
            (t[e + 15] = n[15]),
            t
          )
        }
      }
      nc.prototype.isMatrix4 = !0
      const ic = new Tl(),
        rc = new nc(),
        sc = new Tl(0, 0, 0),
        oc = new Tl(1, 1, 1),
        ac = new Tl(),
        lc = new Tl(),
        cc = new Tl(),
        uc = new nc(),
        hc = new Sl()
      class dc {
        constructor(t = 0, e = 0, n = 0, i = dc.DefaultOrder) {
          ;(this._x = t), (this._y = e), (this._z = n), (this._order = i)
        }
        get x() {
          return this._x
        }
        set x(t) {
          ;(this._x = t), this._onChangeCallback()
        }
        get y() {
          return this._y
        }
        set y(t) {
          ;(this._y = t), this._onChangeCallback()
        }
        get z() {
          return this._z
        }
        set z(t) {
          ;(this._z = t), this._onChangeCallback()
        }
        get order() {
          return this._order
        }
        set order(t) {
          ;(this._order = t), this._onChangeCallback()
        }
        set(t, e, n, i = this._order) {
          return (
            (this._x = t),
            (this._y = e),
            (this._z = n),
            (this._order = i),
            this._onChangeCallback(),
            this
          )
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order)
        }
        copy(t) {
          return (
            (this._x = t._x),
            (this._y = t._y),
            (this._z = t._z),
            (this._order = t._order),
            this._onChangeCallback(),
            this
          )
        }
        setFromRotationMatrix(t, e = this._order, n = !0) {
          const i = t.elements,
            r = i[0],
            s = i[4],
            o = i[8],
            a = i[1],
            l = i[5],
            c = i[9],
            u = i[2],
            h = i[6],
            d = i[10]
          switch (e) {
            case 'XYZ':
              ;(this._y = Math.asin(sl(o, -1, 1))),
                Math.abs(o) < 0.9999999
                  ? ((this._x = Math.atan2(-c, d)),
                    (this._z = Math.atan2(-s, r)))
                  : ((this._x = Math.atan2(h, l)), (this._z = 0))
              break
            case 'YXZ':
              ;(this._x = Math.asin(-sl(c, -1, 1))),
                Math.abs(c) < 0.9999999
                  ? ((this._y = Math.atan2(o, d)), (this._z = Math.atan2(a, l)))
                  : ((this._y = Math.atan2(-u, r)), (this._z = 0))
              break
            case 'ZXY':
              ;(this._x = Math.asin(sl(h, -1, 1))),
                Math.abs(h) < 0.9999999
                  ? ((this._y = Math.atan2(-u, d)),
                    (this._z = Math.atan2(-s, l)))
                  : ((this._y = 0), (this._z = Math.atan2(a, r)))
              break
            case 'ZYX':
              ;(this._y = Math.asin(-sl(u, -1, 1))),
                Math.abs(u) < 0.9999999
                  ? ((this._x = Math.atan2(h, d)), (this._z = Math.atan2(a, r)))
                  : ((this._x = 0), (this._z = Math.atan2(-s, l)))
              break
            case 'YZX':
              ;(this._z = Math.asin(sl(a, -1, 1))),
                Math.abs(a) < 0.9999999
                  ? ((this._x = Math.atan2(-c, l)),
                    (this._y = Math.atan2(-u, r)))
                  : ((this._x = 0), (this._y = Math.atan2(o, d)))
              break
            case 'XZY':
              ;(this._z = Math.asin(-sl(s, -1, 1))),
                Math.abs(s) < 0.9999999
                  ? ((this._x = Math.atan2(h, l)), (this._y = Math.atan2(o, r)))
                  : ((this._x = Math.atan2(-c, d)), (this._y = 0))
              break
            default:
              console.warn(
                'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' +
                  e,
              )
          }
          return (this._order = e), !0 === n && this._onChangeCallback(), this
        }
        setFromQuaternion(t, e, n) {
          return (
            uc.makeRotationFromQuaternion(t),
            this.setFromRotationMatrix(uc, e, n)
          )
        }
        setFromVector3(t, e = this._order) {
          return this.set(t.x, t.y, t.z, e)
        }
        reorder(t) {
          return hc.setFromEuler(this), this.setFromQuaternion(hc, t)
        }
        equals(t) {
          return (
            t._x === this._x &&
            t._y === this._y &&
            t._z === this._z &&
            t._order === this._order
          )
        }
        fromArray(t) {
          return (
            (this._x = t[0]),
            (this._y = t[1]),
            (this._z = t[2]),
            void 0 !== t[3] && (this._order = t[3]),
            this._onChangeCallback(),
            this
          )
        }
        toArray(t = [], e = 0) {
          return (
            (t[e] = this._x),
            (t[e + 1] = this._y),
            (t[e + 2] = this._z),
            (t[e + 3] = this._order),
            t
          )
        }
        toVector3(t) {
          return t
            ? t.set(this._x, this._y, this._z)
            : new Tl(this._x, this._y, this._z)
        }
        _onChange(t) {
          return (this._onChangeCallback = t), this
        }
        _onChangeCallback() {}
      }
      ;(dc.prototype.isEuler = !0),
        (dc.DefaultOrder = 'XYZ'),
        (dc.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'])
      class pc {
        constructor() {
          this.mask = 1
        }
        set(t) {
          this.mask = (1 << t) | 0
        }
        enable(t) {
          this.mask |= (1 << t) | 0
        }
        enableAll() {
          this.mask = -1
        }
        toggle(t) {
          this.mask ^= (1 << t) | 0
        }
        disable(t) {
          this.mask &= ~((1 << t) | 0)
        }
        disableAll() {
          this.mask = 0
        }
        test(t) {
          return 0 != (this.mask & t.mask)
        }
      }
      let fc = 0
      const mc = new Tl(),
        gc = new Sl(),
        vc = new nc(),
        _c = new Tl(),
        yc = new Tl(),
        xc = new Tl(),
        bc = new Sl(),
        wc = new Tl(1, 0, 0),
        Mc = new Tl(0, 1, 0),
        Sc = new Tl(0, 0, 1),
        Tc = { type: 'added' },
        Ec = { type: 'removed' }
      class Dc extends Qa {
        constructor() {
          super(),
            Object.defineProperty(this, 'id', { value: fc++ }),
            (this.uuid = rl()),
            (this.name = ''),
            (this.type = 'Object3D'),
            (this.parent = null),
            (this.children = []),
            (this.up = Dc.DefaultUp.clone())
          const t = new Tl(),
            e = new dc(),
            n = new Sl(),
            i = new Tl(1, 1, 1)
          e._onChange(function () {
            n.setFromEuler(e, !1)
          }),
            n._onChange(function () {
              e.setFromQuaternion(n, void 0, !1)
            }),
            Object.defineProperties(this, {
              position: { configurable: !0, enumerable: !0, value: t },
              rotation: { configurable: !0, enumerable: !0, value: e },
              quaternion: { configurable: !0, enumerable: !0, value: n },
              scale: { configurable: !0, enumerable: !0, value: i },
              modelViewMatrix: { value: new nc() },
              normalMatrix: { value: new pl() },
            }),
            (this.matrix = new nc()),
            (this.matrixWorld = new nc()),
            (this.matrixAutoUpdate = Dc.DefaultMatrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = !1),
            (this.layers = new pc()),
            (this.visible = !0),
            (this.castShadow = !1),
            (this.receiveShadow = !1),
            (this.frustumCulled = !0),
            (this.renderOrder = 0),
            (this.animations = []),
            (this.userData = {})
        }
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(t) {
          this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(t),
            this.matrix.decompose(this.position, this.quaternion, this.scale)
        }
        applyQuaternion(t) {
          return this.quaternion.premultiply(t), this
        }
        setRotationFromAxisAngle(t, e) {
          this.quaternion.setFromAxisAngle(t, e)
        }
        setRotationFromEuler(t) {
          this.quaternion.setFromEuler(t, !0)
        }
        setRotationFromMatrix(t) {
          this.quaternion.setFromRotationMatrix(t)
        }
        setRotationFromQuaternion(t) {
          this.quaternion.copy(t)
        }
        rotateOnAxis(t, e) {
          return gc.setFromAxisAngle(t, e), this.quaternion.multiply(gc), this
        }
        rotateOnWorldAxis(t, e) {
          return (
            gc.setFromAxisAngle(t, e), this.quaternion.premultiply(gc), this
          )
        }
        rotateX(t) {
          return this.rotateOnAxis(wc, t)
        }
        rotateY(t) {
          return this.rotateOnAxis(Mc, t)
        }
        rotateZ(t) {
          return this.rotateOnAxis(Sc, t)
        }
        translateOnAxis(t, e) {
          return (
            mc.copy(t).applyQuaternion(this.quaternion),
            this.position.add(mc.multiplyScalar(e)),
            this
          )
        }
        translateX(t) {
          return this.translateOnAxis(wc, t)
        }
        translateY(t) {
          return this.translateOnAxis(Mc, t)
        }
        translateZ(t) {
          return this.translateOnAxis(Sc, t)
        }
        localToWorld(t) {
          return t.applyMatrix4(this.matrixWorld)
        }
        worldToLocal(t) {
          return t.applyMatrix4(vc.copy(this.matrixWorld).invert())
        }
        lookAt(t, e, n) {
          t.isVector3 ? _c.copy(t) : _c.set(t, e, n)
          const i = this.parent
          this.updateWorldMatrix(!0, !1),
            yc.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight
              ? vc.lookAt(yc, _c, this.up)
              : vc.lookAt(_c, yc, this.up),
            this.quaternion.setFromRotationMatrix(vc),
            i &&
              (vc.extractRotation(i.matrixWorld),
              gc.setFromRotationMatrix(vc),
              this.quaternion.premultiply(gc.invert()))
        }
        add(t) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t])
            return this
          }
          return t === this
            ? (console.error(
                "THREE.Object3D.add: object can't be added as a child of itself.",
                t,
              ),
              this)
            : (t && t.isObject3D
                ? (null !== t.parent && t.parent.remove(t),
                  (t.parent = this),
                  this.children.push(t),
                  t.dispatchEvent(Tc))
                : console.error(
                    'THREE.Object3D.add: object not an instance of THREE.Object3D.',
                    t,
                  ),
              this)
        }
        remove(t) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.remove(arguments[t])
            return this
          }
          const e = this.children.indexOf(t)
          return (
            -1 !== e &&
              ((t.parent = null),
              this.children.splice(e, 1),
              t.dispatchEvent(Ec)),
            this
          )
        }
        removeFromParent() {
          const t = this.parent
          return null !== t && t.remove(this), this
        }
        clear() {
          for (let t = 0; t < this.children.length; t++) {
            const e = this.children[t]
            ;(e.parent = null), e.dispatchEvent(Ec)
          }
          return (this.children.length = 0), this
        }
        attach(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            vc.copy(this.matrixWorld).invert(),
            null !== t.parent &&
              (t.parent.updateWorldMatrix(!0, !1),
              vc.multiply(t.parent.matrixWorld)),
            t.applyMatrix4(vc),
            this.add(t),
            t.updateWorldMatrix(!1, !0),
            this
          )
        }
        getObjectById(t) {
          return this.getObjectByProperty('id', t)
        }
        getObjectByName(t) {
          return this.getObjectByProperty('name', t)
        }
        getObjectByProperty(t, e) {
          if (this[t] === e) return this
          for (let n = 0, i = this.children.length; n < i; n++) {
            const i = this.children[n].getObjectByProperty(t, e)
            if (void 0 !== i) return i
          }
        }
        getWorldPosition(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            t.setFromMatrixPosition(this.matrixWorld)
          )
        }
        getWorldQuaternion(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(yc, t, xc),
            t
          )
        }
        getWorldScale(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(yc, bc, t),
            t
          )
        }
        getWorldDirection(t) {
          this.updateWorldMatrix(!0, !1)
          const e = this.matrixWorld.elements
          return t.set(e[8], e[9], e[10]).normalize()
        }
        raycast() {}
        traverse(t) {
          t(this)
          const e = this.children
          for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t)
        }
        traverseVisible(t) {
          if (!1 === this.visible) return
          t(this)
          const e = this.children
          for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t)
        }
        traverseAncestors(t) {
          const e = this.parent
          null !== e && (t(e), e.traverseAncestors(t))
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale),
            (this.matrixWorldNeedsUpdate = !0)
        }
        updateMatrixWorld(t) {
          this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || t) &&
              (null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix,
                  ),
              (this.matrixWorldNeedsUpdate = !1),
              (t = !0))
          const e = this.children
          for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t)
        }
        updateWorldMatrix(t, e) {
          const n = this.parent
          if (
            (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            null === this.parent
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix,
                ),
            !0 === e)
          ) {
            const t = this.children
            for (let e = 0, n = t.length; e < n; e++)
              t[e].updateWorldMatrix(!1, !0)
          }
        }
        toJSON(t) {
          const e = void 0 === t || 'string' == typeof t,
            n = {}
          e &&
            ((t = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {},
            }),
            (n.metadata = {
              version: 4.5,
              type: 'Object',
              generator: 'Object3D.toJSON',
            }))
          const i = {}
          function r(e, n) {
            return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
          }
          if (
            ((i.uuid = this.uuid),
            (i.type = this.type),
            '' !== this.name && (i.name = this.name),
            !0 === this.castShadow && (i.castShadow = !0),
            !0 === this.receiveShadow && (i.receiveShadow = !0),
            !1 === this.visible && (i.visible = !1),
            !1 === this.frustumCulled && (i.frustumCulled = !1),
            0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
            '{}' !== JSON.stringify(this.userData) &&
              (i.userData = this.userData),
            (i.layers = this.layers.mask),
            (i.matrix = this.matrix.toArray()),
            !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
            this.isInstancedMesh &&
              ((i.type = 'InstancedMesh'),
              (i.count = this.count),
              (i.instanceMatrix = this.instanceMatrix.toJSON()),
              null !== this.instanceColor &&
                (i.instanceColor = this.instanceColor.toJSON())),
            this.isScene)
          )
            this.background &&
              (this.background.isColor
                ? (i.background = this.background.toJSON())
                : this.background.isTexture &&
                  (i.background = this.background.toJSON(t).uuid)),
              this.environment &&
                this.environment.isTexture &&
                (i.environment = this.environment.toJSON(t).uuid)
          else if (this.isMesh || this.isLine || this.isPoints) {
            i.geometry = r(t.geometries, this.geometry)
            const e = this.geometry.parameters
            if (void 0 !== e && void 0 !== e.shapes) {
              const n = e.shapes
              if (Array.isArray(n))
                for (let e = 0, i = n.length; e < i; e++) {
                  const i = n[e]
                  r(t.shapes, i)
                }
              else r(t.shapes, n)
            }
          }
          if (
            (this.isSkinnedMesh &&
              ((i.bindMode = this.bindMode),
              (i.bindMatrix = this.bindMatrix.toArray()),
              void 0 !== this.skeleton &&
                (r(t.skeletons, this.skeleton),
                (i.skeleton = this.skeleton.uuid))),
            void 0 !== this.material)
          )
            if (Array.isArray(this.material)) {
              const e = []
              for (let n = 0, i = this.material.length; n < i; n++)
                e.push(r(t.materials, this.material[n]))
              i.material = e
            } else i.material = r(t.materials, this.material)
          if (this.children.length > 0) {
            i.children = []
            for (let e = 0; e < this.children.length; e++)
              i.children.push(this.children[e].toJSON(t).object)
          }
          if (this.animations.length > 0) {
            i.animations = []
            for (let e = 0; e < this.animations.length; e++) {
              const n = this.animations[e]
              i.animations.push(r(t.animations, n))
            }
          }
          if (e) {
            const e = s(t.geometries),
              i = s(t.materials),
              r = s(t.textures),
              o = s(t.images),
              a = s(t.shapes),
              l = s(t.skeletons),
              c = s(t.animations)
            e.length > 0 && (n.geometries = e),
              i.length > 0 && (n.materials = i),
              r.length > 0 && (n.textures = r),
              o.length > 0 && (n.images = o),
              a.length > 0 && (n.shapes = a),
              l.length > 0 && (n.skeletons = l),
              c.length > 0 && (n.animations = c)
          }
          return (n.object = i), n
          function s(t) {
            const e = []
            for (const n in t) {
              const i = t[n]
              delete i.metadata, e.push(i)
            }
            return e
          }
        }
        clone(t) {
          return new this.constructor().copy(this, t)
        }
        copy(t, e = !0) {
          if (
            ((this.name = t.name),
            this.up.copy(t.up),
            this.position.copy(t.position),
            (this.rotation.order = t.rotation.order),
            this.quaternion.copy(t.quaternion),
            this.scale.copy(t.scale),
            this.matrix.copy(t.matrix),
            this.matrixWorld.copy(t.matrixWorld),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
            (this.layers.mask = t.layers.mask),
            (this.visible = t.visible),
            (this.castShadow = t.castShadow),
            (this.receiveShadow = t.receiveShadow),
            (this.frustumCulled = t.frustumCulled),
            (this.renderOrder = t.renderOrder),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            !0 === e)
          )
            for (let e = 0; e < t.children.length; e++) {
              const n = t.children[e]
              this.add(n.clone())
            }
          return this
        }
      }
      ;(Dc.DefaultUp = new Tl(0, 1, 0)),
        (Dc.DefaultMatrixAutoUpdate = !0),
        (Dc.prototype.isObject3D = !0)
      const Ac = new Tl(),
        Cc = new Tl(),
        Lc = new Tl(),
        Rc = new Tl(),
        Pc = new Tl(),
        Fc = new Tl(),
        Ic = new Tl(),
        Oc = new Tl(),
        Nc = new Tl(),
        kc = new Tl()
      class Bc {
        constructor(t = new Tl(), e = new Tl(), n = new Tl()) {
          ;(this.a = t), (this.b = e), (this.c = n)
        }
        static getNormal(t, e, n, i) {
          i.subVectors(n, e), Ac.subVectors(t, e), i.cross(Ac)
          const r = i.lengthSq()
          return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
        }
        static getBarycoord(t, e, n, i, r) {
          Ac.subVectors(i, e), Cc.subVectors(n, e), Lc.subVectors(t, e)
          const s = Ac.dot(Ac),
            o = Ac.dot(Cc),
            a = Ac.dot(Lc),
            l = Cc.dot(Cc),
            c = Cc.dot(Lc),
            u = s * l - o * o
          if (0 === u) return r.set(-2, -1, -1)
          const h = 1 / u,
            d = (l * a - o * c) * h,
            p = (s * c - o * a) * h
          return r.set(1 - d - p, p, d)
        }
        static containsPoint(t, e, n, i) {
          return (
            this.getBarycoord(t, e, n, i, Rc),
            Rc.x >= 0 && Rc.y >= 0 && Rc.x + Rc.y <= 1
          )
        }
        static getUV(t, e, n, i, r, s, o, a) {
          return (
            this.getBarycoord(t, e, n, i, Rc),
            a.set(0, 0),
            a.addScaledVector(r, Rc.x),
            a.addScaledVector(s, Rc.y),
            a.addScaledVector(o, Rc.z),
            a
          )
        }
        static isFrontFacing(t, e, n, i) {
          return (
            Ac.subVectors(n, e), Cc.subVectors(t, e), Ac.cross(Cc).dot(i) < 0
          )
        }
        set(t, e, n) {
          return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
        }
        setFromPointsAndIndices(t, e, n, i) {
          return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
        }
        setFromAttributeAndIndices(t, e, n, i) {
          return (
            this.a.fromBufferAttribute(t, e),
            this.b.fromBufferAttribute(t, n),
            this.c.fromBufferAttribute(t, i),
            this
          )
        }
        clone() {
          return new this.constructor().copy(this)
        }
        copy(t) {
          return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
        }
        getArea() {
          return (
            Ac.subVectors(this.c, this.b),
            Cc.subVectors(this.a, this.b),
            0.5 * Ac.cross(Cc).length()
          )
        }
        getMidpoint(t) {
          return t
            .addVectors(this.a, this.b)
            .add(this.c)
            .multiplyScalar(1 / 3)
        }
        getNormal(t) {
          return Bc.getNormal(this.a, this.b, this.c, t)
        }
        getPlane(t) {
          return t.setFromCoplanarPoints(this.a, this.b, this.c)
        }
        getBarycoord(t, e) {
          return Bc.getBarycoord(t, this.a, this.b, this.c, e)
        }
        getUV(t, e, n, i, r) {
          return Bc.getUV(t, this.a, this.b, this.c, e, n, i, r)
        }
        containsPoint(t) {
          return Bc.containsPoint(t, this.a, this.b, this.c)
        }
        isFrontFacing(t) {
          return Bc.isFrontFacing(this.a, this.b, this.c, t)
        }
        intersectsBox(t) {
          return t.intersectsTriangle(this)
        }
        closestPointToPoint(t, e) {
          const n = this.a,
            i = this.b,
            r = this.c
          let s, o
          Pc.subVectors(i, n), Fc.subVectors(r, n), Oc.subVectors(t, n)
          const a = Pc.dot(Oc),
            l = Fc.dot(Oc)
          if (a <= 0 && l <= 0) return e.copy(n)
          Nc.subVectors(t, i)
          const c = Pc.dot(Nc),
            u = Fc.dot(Nc)
          if (c >= 0 && u <= c) return e.copy(i)
          const h = a * u - c * l
          if (h <= 0 && a >= 0 && c <= 0)
            return (s = a / (a - c)), e.copy(n).addScaledVector(Pc, s)
          kc.subVectors(t, r)
          const d = Pc.dot(kc),
            p = Fc.dot(kc)
          if (p >= 0 && d <= p) return e.copy(r)
          const f = d * l - a * p
          if (f <= 0 && l >= 0 && p <= 0)
            return (o = l / (l - p)), e.copy(n).addScaledVector(Fc, o)
          const m = c * p - d * u
          if (m <= 0 && u - c >= 0 && d - p >= 0)
            return (
              Ic.subVectors(r, i),
              (o = (u - c) / (u - c + (d - p))),
              e.copy(i).addScaledVector(Ic, o)
            )
          const g = 1 / (m + f + h)
          return (
            (s = f * g),
            (o = h * g),
            e.copy(n).addScaledVector(Pc, s).addScaledVector(Fc, o)
          )
        }
        equals(t) {
          return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
        }
      }
      let zc = 0
      class Uc extends Qa {
        constructor() {
          super(),
            Object.defineProperty(this, 'id', { value: zc++ }),
            (this.uuid = rl()),
            (this.name = ''),
            (this.type = 'Material'),
            (this.fog = !0),
            (this.blending = 1),
            (this.side = 0),
            (this.vertexColors = !1),
            (this.opacity = 1),
            (this.format = Oa),
            (this.transparent = !1),
            (this.blendSrc = 204),
            (this.blendDst = 205),
            (this.blendEquation = ga),
            (this.blendSrcAlpha = null),
            (this.blendDstAlpha = null),
            (this.blendEquationAlpha = null),
            (this.depthFunc = 3),
            (this.depthTest = !0),
            (this.depthWrite = !0),
            (this.stencilWriteMask = 255),
            (this.stencilFunc = 519),
            (this.stencilRef = 0),
            (this.stencilFuncMask = 255),
            (this.stencilFail = Ya),
            (this.stencilZFail = Ya),
            (this.stencilZPass = Ya),
            (this.stencilWrite = !1),
            (this.clippingPlanes = null),
            (this.clipIntersection = !1),
            (this.clipShadows = !1),
            (this.shadowSide = null),
            (this.colorWrite = !0),
            (this.precision = null),
            (this.polygonOffset = !1),
            (this.polygonOffsetFactor = 0),
            (this.polygonOffsetUnits = 0),
            (this.dithering = !1),
            (this.alphaToCoverage = !1),
            (this.premultipliedAlpha = !1),
            (this.visible = !0),
            (this.toneMapped = !0),
            (this.userData = {}),
            (this.version = 0),
            (this._alphaTest = 0)
        }
        get alphaTest() {
          return this._alphaTest
        }
        set alphaTest(t) {
          this._alphaTest > 0 != t > 0 && this.version++, (this._alphaTest = t)
        }
        onBuild() {}
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
          return this.onBeforeCompile.toString()
        }
        setValues(t) {
          if (void 0 !== t)
            for (const e in t) {
              const n = t[e]
              if (void 0 === n) {
                console.warn(
                  "THREE.Material: '" + e + "' parameter is undefined.",
                )
                continue
              }
              if ('shading' === e) {
                console.warn(
                  'THREE.' +
                    this.type +
                    ': .shading has been removed. Use the boolean .flatShading instead.',
                ),
                  (this.flatShading = 1 === n)
                continue
              }
              const i = this[e]
              void 0 !== i
                ? i && i.isColor
                  ? i.set(n)
                  : i && i.isVector3 && n && n.isVector3
                  ? i.copy(n)
                  : (this[e] = n)
                : console.warn(
                    'THREE.' +
                      this.type +
                      ": '" +
                      e +
                      "' is not a property of this material.",
                  )
            }
        }
        toJSON(t) {
          const e = void 0 === t || 'string' == typeof t
          e && (t = { textures: {}, images: {} })
          const n = {
            metadata: {
              version: 4.5,
              type: 'Material',
              generator: 'Material.toJSON',
            },
          }
          function i(t) {
            const e = []
            for (const n in t) {
              const i = t[n]
              delete i.metadata, e.push(i)
            }
            return e
          }
          if (
            ((n.uuid = this.uuid),
            (n.type = this.type),
            '' !== this.name && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            void 0 !== this.roughness && (n.roughness = this.roughness),
            void 0 !== this.metalness && (n.metalness = this.metalness),
            void 0 !== this.sheen && (n.sheen = this.sheen),
            this.sheenTint &&
              this.sheenTint.isColor &&
              (n.sheenTint = this.sheenTint.getHex()),
            void 0 !== this.sheenRoughness &&
              (n.sheenRoughness = this.sheenRoughness),
            this.emissive &&
              this.emissive.isColor &&
              (n.emissive = this.emissive.getHex()),
            this.emissiveIntensity &&
              1 !== this.emissiveIntensity &&
              (n.emissiveIntensity = this.emissiveIntensity),
            this.specular &&
              this.specular.isColor &&
              (n.specular = this.specular.getHex()),
            void 0 !== this.specularIntensity &&
              (n.specularIntensity = this.specularIntensity),
            this.specularTint &&
              this.specularTint.isColor &&
              (n.specularTint = this.specularTint.getHex()),
            void 0 !== this.shininess && (n.shininess = this.shininess),
            void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
            void 0 !== this.clearcoatRoughness &&
              (n.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap &&
              this.clearcoatMap.isTexture &&
              (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
            this.clearcoatRoughnessMap &&
              this.clearcoatRoughnessMap.isTexture &&
              (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(
                t,
              ).uuid),
            this.clearcoatNormalMap &&
              this.clearcoatNormalMap.isTexture &&
              ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
              (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
            this.matcap &&
              this.matcap.isTexture &&
              (n.matcap = this.matcap.toJSON(t).uuid),
            this.alphaMap &&
              this.alphaMap.isTexture &&
              (n.alphaMap = this.alphaMap.toJSON(t).uuid),
            this.lightMap &&
              this.lightMap.isTexture &&
              ((n.lightMap = this.lightMap.toJSON(t).uuid),
              (n.lightMapIntensity = this.lightMapIntensity)),
            this.aoMap &&
              this.aoMap.isTexture &&
              ((n.aoMap = this.aoMap.toJSON(t).uuid),
              (n.aoMapIntensity = this.aoMapIntensity)),
            this.bumpMap &&
              this.bumpMap.isTexture &&
              ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
              (n.bumpScale = this.bumpScale)),
            this.normalMap &&
              this.normalMap.isTexture &&
              ((n.normalMap = this.normalMap.toJSON(t).uuid),
              (n.normalMapType = this.normalMapType),
              (n.normalScale = this.normalScale.toArray())),
            this.displacementMap &&
              this.displacementMap.isTexture &&
              ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
              (n.displacementScale = this.displacementScale),
              (n.displacementBias = this.displacementBias)),
            this.roughnessMap &&
              this.roughnessMap.isTexture &&
              (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
            this.metalnessMap &&
              this.metalnessMap.isTexture &&
              (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
            this.emissiveMap &&
              this.emissiveMap.isTexture &&
              (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
            this.specularMap &&
              this.specularMap.isTexture &&
              (n.specularMap = this.specularMap.toJSON(t).uuid),
            this.specularIntensityMap &&
              this.specularIntensityMap.isTexture &&
              (n.specularIntensityMap = this.specularIntensityMap.toJSON(
                t,
              ).uuid),
            this.specularTintMap &&
              this.specularTintMap.isTexture &&
              (n.specularTintMap = this.specularTintMap.toJSON(t).uuid),
            this.envMap &&
              this.envMap.isTexture &&
              ((n.envMap = this.envMap.toJSON(t).uuid),
              void 0 !== this.combine && (n.combine = this.combine)),
            void 0 !== this.envMapIntensity &&
              (n.envMapIntensity = this.envMapIntensity),
            void 0 !== this.reflectivity &&
              (n.reflectivity = this.reflectivity),
            void 0 !== this.refractionRatio &&
              (n.refractionRatio = this.refractionRatio),
            this.gradientMap &&
              this.gradientMap.isTexture &&
              (n.gradientMap = this.gradientMap.toJSON(t).uuid),
            void 0 !== this.transmission &&
              (n.transmission = this.transmission),
            this.transmissionMap &&
              this.transmissionMap.isTexture &&
              (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
            void 0 !== this.thickness && (n.thickness = this.thickness),
            this.thicknessMap &&
              this.thicknessMap.isTexture &&
              (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
            void 0 !== this.attenuationDistance &&
              (n.attenuationDistance = this.attenuationDistance),
            void 0 !== this.attenuationTint &&
              (n.attenuationTint = this.attenuationTint.getHex()),
            void 0 !== this.size && (n.size = this.size),
            null !== this.shadowSide && (n.shadowSide = this.shadowSide),
            void 0 !== this.sizeAttenuation &&
              (n.sizeAttenuation = this.sizeAttenuation),
            1 !== this.blending && (n.blending = this.blending),
            0 !== this.side && (n.side = this.side),
            this.vertexColors && (n.vertexColors = !0),
            this.opacity < 1 && (n.opacity = this.opacity),
            this.format !== Oa && (n.format = this.format),
            !0 === this.transparent && (n.transparent = this.transparent),
            (n.depthFunc = this.depthFunc),
            (n.depthTest = this.depthTest),
            (n.depthWrite = this.depthWrite),
            (n.colorWrite = this.colorWrite),
            (n.stencilWrite = this.stencilWrite),
            (n.stencilWriteMask = this.stencilWriteMask),
            (n.stencilFunc = this.stencilFunc),
            (n.stencilRef = this.stencilRef),
            (n.stencilFuncMask = this.stencilFuncMask),
            (n.stencilFail = this.stencilFail),
            (n.stencilZFail = this.stencilZFail),
            (n.stencilZPass = this.stencilZPass),
            this.rotation &&
              0 !== this.rotation &&
              (n.rotation = this.rotation),
            !0 === this.polygonOffset && (n.polygonOffset = !0),
            0 !== this.polygonOffsetFactor &&
              (n.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits &&
              (n.polygonOffsetUnits = this.polygonOffsetUnits),
            this.linewidth &&
              1 !== this.linewidth &&
              (n.linewidth = this.linewidth),
            void 0 !== this.dashSize && (n.dashSize = this.dashSize),
            void 0 !== this.gapSize && (n.gapSize = this.gapSize),
            void 0 !== this.scale && (n.scale = this.scale),
            !0 === this.dithering && (n.dithering = !0),
            this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
            !0 === this.alphaToCoverage &&
              (n.alphaToCoverage = this.alphaToCoverage),
            !0 === this.premultipliedAlpha &&
              (n.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (n.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 &&
              (n.wireframeLinewidth = this.wireframeLinewidth),
            'round' !== this.wireframeLinecap &&
              (n.wireframeLinecap = this.wireframeLinecap),
            'round' !== this.wireframeLinejoin &&
              (n.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.flatShading && (n.flatShading = this.flatShading),
            !1 === this.visible && (n.visible = !1),
            !1 === this.toneMapped && (n.toneMapped = !1),
            '{}' !== JSON.stringify(this.userData) &&
              (n.userData = this.userData),
            e)
          ) {
            const e = i(t.textures),
              r = i(t.images)
            e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r)
          }
          return n
        }
        clone() {
          return new this.constructor().copy(this)
        }
        copy(t) {
          ;(this.name = t.name),
            (this.fog = t.fog),
            (this.blending = t.blending),
            (this.side = t.side),
            (this.vertexColors = t.vertexColors),
            (this.opacity = t.opacity),
            (this.format = t.format),
            (this.transparent = t.transparent),
            (this.blendSrc = t.blendSrc),
            (this.blendDst = t.blendDst),
            (this.blendEquation = t.blendEquation),
            (this.blendSrcAlpha = t.blendSrcAlpha),
            (this.blendDstAlpha = t.blendDstAlpha),
            (this.blendEquationAlpha = t.blendEquationAlpha),
            (this.depthFunc = t.depthFunc),
            (this.depthTest = t.depthTest),
            (this.depthWrite = t.depthWrite),
            (this.stencilWriteMask = t.stencilWriteMask),
            (this.stencilFunc = t.stencilFunc),
            (this.stencilRef = t.stencilRef),
            (this.stencilFuncMask = t.stencilFuncMask),
            (this.stencilFail = t.stencilFail),
            (this.stencilZFail = t.stencilZFail),
            (this.stencilZPass = t.stencilZPass),
            (this.stencilWrite = t.stencilWrite)
          const e = t.clippingPlanes
          let n = null
          if (null !== e) {
            const t = e.length
            n = new Array(t)
            for (let i = 0; i !== t; ++i) n[i] = e[i].clone()
          }
          return (
            (this.clippingPlanes = n),
            (this.clipIntersection = t.clipIntersection),
            (this.clipShadows = t.clipShadows),
            (this.shadowSide = t.shadowSide),
            (this.colorWrite = t.colorWrite),
            (this.precision = t.precision),
            (this.polygonOffset = t.polygonOffset),
            (this.polygonOffsetFactor = t.polygonOffsetFactor),
            (this.polygonOffsetUnits = t.polygonOffsetUnits),
            (this.dithering = t.dithering),
            (this.alphaTest = t.alphaTest),
            (this.alphaToCoverage = t.alphaToCoverage),
            (this.premultipliedAlpha = t.premultipliedAlpha),
            (this.visible = t.visible),
            (this.toneMapped = t.toneMapped),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            this
          )
        }
        dispose() {
          this.dispatchEvent({ type: 'dispose' })
        }
        set needsUpdate(t) {
          !0 === t && this.version++
        }
      }
      Uc.prototype.isMaterial = !0
      const Hc = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        },
        Gc = { h: 0, s: 0, l: 0 },
        Vc = { h: 0, s: 0, l: 0 }
      function Wc(t, e, n) {
        return (
          n < 0 && (n += 1),
          n > 1 && (n -= 1),
          n < 1 / 6
            ? t + 6 * (e - t) * n
            : n < 0.5
            ? e
            : n < 2 / 3
            ? t + 6 * (e - t) * (2 / 3 - n)
            : t
        )
      }
      function jc(t) {
        return t < 0.04045
          ? 0.0773993808 * t
          : Math.pow(0.9478672986 * t + 0.0521327014, 2.4)
      }
      function qc(t) {
        return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055
      }
      class Xc {
        constructor(t, e, n) {
          return void 0 === e && void 0 === n
            ? this.set(t)
            : this.setRGB(t, e, n)
        }
        set(t) {
          return (
            t && t.isColor
              ? this.copy(t)
              : 'number' == typeof t
              ? this.setHex(t)
              : 'string' == typeof t && this.setStyle(t),
            this
          )
        }
        setScalar(t) {
          return (this.r = t), (this.g = t), (this.b = t), this
        }
        setHex(t) {
          return (
            (t = Math.floor(t)),
            (this.r = ((t >> 16) & 255) / 255),
            (this.g = ((t >> 8) & 255) / 255),
            (this.b = (255 & t) / 255),
            this
          )
        }
        setRGB(t, e, n) {
          return (this.r = t), (this.g = e), (this.b = n), this
        }
        setHSL(t, e, n) {
          if (((t = ol(t, 1)), (e = sl(e, 0, 1)), (n = sl(n, 0, 1)), 0 === e))
            this.r = this.g = this.b = n
          else {
            const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
              r = 2 * n - i
            ;(this.r = Wc(r, i, t + 1 / 3)),
              (this.g = Wc(r, i, t)),
              (this.b = Wc(r, i, t - 1 / 3))
          }
          return this
        }
        setStyle(t) {
          function e(e) {
            void 0 !== e &&
              parseFloat(e) < 1 &&
              console.warn(
                'THREE.Color: Alpha component of ' + t + ' will be ignored.',
              )
          }
          let n
          if ((n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t))) {
            let t
            const i = n[1],
              r = n[2]
            switch (i) {
              case 'rgb':
              case 'rgba':
                if (
                  (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                    r,
                  ))
                )
                  return (
                    (this.r = Math.min(255, parseInt(t[1], 10)) / 255),
                    (this.g = Math.min(255, parseInt(t[2], 10)) / 255),
                    (this.b = Math.min(255, parseInt(t[3], 10)) / 255),
                    e(t[4]),
                    this
                  )
                if (
                  (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                    r,
                  ))
                )
                  return (
                    (this.r = Math.min(100, parseInt(t[1], 10)) / 100),
                    (this.g = Math.min(100, parseInt(t[2], 10)) / 100),
                    (this.b = Math.min(100, parseInt(t[3], 10)) / 100),
                    e(t[4]),
                    this
                  )
                break
              case 'hsl':
              case 'hsla':
                if (
                  (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                    r,
                  ))
                ) {
                  const n = parseFloat(t[1]) / 360,
                    i = parseInt(t[2], 10) / 100,
                    r = parseInt(t[3], 10) / 100
                  return e(t[4]), this.setHSL(n, i, r)
                }
            }
          } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(t))) {
            const t = n[1],
              e = t.length
            if (3 === e)
              return (
                (this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255),
                (this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255),
                (this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255),
                this
              )
            if (6 === e)
              return (
                (this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255),
                (this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255),
                (this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255),
                this
              )
          }
          return t && t.length > 0 ? this.setColorName(t) : this
        }
        setColorName(t) {
          const e = Hc[t.toLowerCase()]
          return (
            void 0 !== e
              ? this.setHex(e)
              : console.warn('THREE.Color: Unknown color ' + t),
            this
          )
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b)
        }
        copy(t) {
          return (this.r = t.r), (this.g = t.g), (this.b = t.b), this
        }
        copyGammaToLinear(t, e = 2) {
          return (
            (this.r = Math.pow(t.r, e)),
            (this.g = Math.pow(t.g, e)),
            (this.b = Math.pow(t.b, e)),
            this
          )
        }
        copyLinearToGamma(t, e = 2) {
          const n = e > 0 ? 1 / e : 1
          return (
            (this.r = Math.pow(t.r, n)),
            (this.g = Math.pow(t.g, n)),
            (this.b = Math.pow(t.b, n)),
            this
          )
        }
        convertGammaToLinear(t) {
          return this.copyGammaToLinear(this, t), this
        }
        convertLinearToGamma(t) {
          return this.copyLinearToGamma(this, t), this
        }
        copySRGBToLinear(t) {
          return (
            (this.r = jc(t.r)), (this.g = jc(t.g)), (this.b = jc(t.b)), this
          )
        }
        copyLinearToSRGB(t) {
          return (
            (this.r = qc(t.r)), (this.g = qc(t.g)), (this.b = qc(t.b)), this
          )
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this
        }
        getHex() {
          return (
            ((255 * this.r) << 16) ^
            ((255 * this.g) << 8) ^
            ((255 * this.b) << 0)
          )
        }
        getHexString() {
          return ('000000' + this.getHex().toString(16)).slice(-6)
        }
        getHSL(t) {
          const e = this.r,
            n = this.g,
            i = this.b,
            r = Math.max(e, n, i),
            s = Math.min(e, n, i)
          let o, a
          const l = (s + r) / 2
          if (s === r) (o = 0), (a = 0)
          else {
            const t = r - s
            switch (((a = l <= 0.5 ? t / (r + s) : t / (2 - r - s)), r)) {
              case e:
                o = (n - i) / t + (n < i ? 6 : 0)
                break
              case n:
                o = (i - e) / t + 2
                break
              case i:
                o = (e - n) / t + 4
            }
            o /= 6
          }
          return (t.h = o), (t.s = a), (t.l = l), t
        }
        getStyle() {
          return (
            'rgb(' +
            ((255 * this.r) | 0) +
            ',' +
            ((255 * this.g) | 0) +
            ',' +
            ((255 * this.b) | 0) +
            ')'
          )
        }
        offsetHSL(t, e, n) {
          return (
            this.getHSL(Gc),
            (Gc.h += t),
            (Gc.s += e),
            (Gc.l += n),
            this.setHSL(Gc.h, Gc.s, Gc.l),
            this
          )
        }
        add(t) {
          return (this.r += t.r), (this.g += t.g), (this.b += t.b), this
        }
        addColors(t, e) {
          return (
            (this.r = t.r + e.r),
            (this.g = t.g + e.g),
            (this.b = t.b + e.b),
            this
          )
        }
        addScalar(t) {
          return (this.r += t), (this.g += t), (this.b += t), this
        }
        sub(t) {
          return (
            (this.r = Math.max(0, this.r - t.r)),
            (this.g = Math.max(0, this.g - t.g)),
            (this.b = Math.max(0, this.b - t.b)),
            this
          )
        }
        multiply(t) {
          return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this
        }
        multiplyScalar(t) {
          return (this.r *= t), (this.g *= t), (this.b *= t), this
        }
        lerp(t, e) {
          return (
            (this.r += (t.r - this.r) * e),
            (this.g += (t.g - this.g) * e),
            (this.b += (t.b - this.b) * e),
            this
          )
        }
        lerpColors(t, e, n) {
          return (
            (this.r = t.r + (e.r - t.r) * n),
            (this.g = t.g + (e.g - t.g) * n),
            (this.b = t.b + (e.b - t.b) * n),
            this
          )
        }
        lerpHSL(t, e) {
          this.getHSL(Gc), t.getHSL(Vc)
          const n = al(Gc.h, Vc.h, e),
            i = al(Gc.s, Vc.s, e),
            r = al(Gc.l, Vc.l, e)
          return this.setHSL(n, i, r), this
        }
        equals(t) {
          return t.r === this.r && t.g === this.g && t.b === this.b
        }
        fromArray(t, e = 0) {
          return (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this
        }
        toArray(t = [], e = 0) {
          return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t
        }
        fromBufferAttribute(t, e) {
          return (
            (this.r = t.getX(e)),
            (this.g = t.getY(e)),
            (this.b = t.getZ(e)),
            !0 === t.normalized &&
              ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
            this
          )
        }
        toJSON() {
          return this.getHex()
        }
      }
      ;(Xc.NAMES = Hc),
        (Xc.prototype.isColor = !0),
        (Xc.prototype.r = 1),
        (Xc.prototype.g = 1),
        (Xc.prototype.b = 1)
      class Yc extends Uc {
        constructor(t) {
          super(),
            (this.type = 'MeshBasicMaterial'),
            (this.color = new Xc(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = 0),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = 'round'),
            (this.wireframeLinejoin = 'round'),
            this.setValues(t)
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            (this.specularMap = t.specularMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            (this.combine = t.combine),
            (this.reflectivity = t.reflectivity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            this
          )
        }
      }
      Yc.prototype.isMeshBasicMaterial = !0
      const Jc = new Tl(),
        Zc = new dl()
      class Kc {
        constructor(t, e, n) {
          if (Array.isArray(t))
            throw new TypeError(
              'THREE.BufferAttribute: array should be a Typed Array.',
            )
          ;(this.name = ''),
            (this.array = t),
            (this.itemSize = e),
            (this.count = void 0 !== t ? t.length / e : 0),
            (this.normalized = !0 === n),
            (this.usage = Ja),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0)
        }
        onUploadCallback() {}
        set needsUpdate(t) {
          !0 === t && this.version++
        }
        setUsage(t) {
          return (this.usage = t), this
        }
        copy(t) {
          return (
            (this.name = t.name),
            (this.array = new t.array.constructor(t.array)),
            (this.itemSize = t.itemSize),
            (this.count = t.count),
            (this.normalized = t.normalized),
            (this.usage = t.usage),
            this
          )
        }
        copyAt(t, e, n) {
          ;(t *= this.itemSize), (n *= e.itemSize)
          for (let i = 0, r = this.itemSize; i < r; i++)
            this.array[t + i] = e.array[n + i]
          return this
        }
        copyArray(t) {
          return this.array.set(t), this
        }
        copyColorsArray(t) {
          const e = this.array
          let n = 0
          for (let i = 0, r = t.length; i < r; i++) {
            let r = t[i]
            void 0 === r &&
              (console.warn(
                'THREE.BufferAttribute.copyColorsArray(): color is undefined',
                i,
              ),
              (r = new Xc())),
              (e[n++] = r.r),
              (e[n++] = r.g),
              (e[n++] = r.b)
          }
          return this
        }
        copyVector2sArray(t) {
          const e = this.array
          let n = 0
          for (let i = 0, r = t.length; i < r; i++) {
            let r = t[i]
            void 0 === r &&
              (console.warn(
                'THREE.BufferAttribute.copyVector2sArray(): vector is undefined',
                i,
              ),
              (r = new dl())),
              (e[n++] = r.x),
              (e[n++] = r.y)
          }
          return this
        }
        copyVector3sArray(t) {
          const e = this.array
          let n = 0
          for (let i = 0, r = t.length; i < r; i++) {
            let r = t[i]
            void 0 === r &&
              (console.warn(
                'THREE.BufferAttribute.copyVector3sArray(): vector is undefined',
                i,
              ),
              (r = new Tl())),
              (e[n++] = r.x),
              (e[n++] = r.y),
              (e[n++] = r.z)
          }
          return this
        }
        copyVector4sArray(t) {
          const e = this.array
          let n = 0
          for (let i = 0, r = t.length; i < r; i++) {
            let r = t[i]
            void 0 === r &&
              (console.warn(
                'THREE.BufferAttribute.copyVector4sArray(): vector is undefined',
                i,
              ),
              (r = new bl())),
              (e[n++] = r.x),
              (e[n++] = r.y),
              (e[n++] = r.z),
              (e[n++] = r.w)
          }
          return this
        }
        applyMatrix3(t) {
          if (2 === this.itemSize)
            for (let e = 0, n = this.count; e < n; e++)
              Zc.fromBufferAttribute(this, e),
                Zc.applyMatrix3(t),
                this.setXY(e, Zc.x, Zc.y)
          else if (3 === this.itemSize)
            for (let e = 0, n = this.count; e < n; e++)
              Jc.fromBufferAttribute(this, e),
                Jc.applyMatrix3(t),
                this.setXYZ(e, Jc.x, Jc.y, Jc.z)
          return this
        }
        applyMatrix4(t) {
          for (let e = 0, n = this.count; e < n; e++)
            (Jc.x = this.getX(e)),
              (Jc.y = this.getY(e)),
              (Jc.z = this.getZ(e)),
              Jc.applyMatrix4(t),
              this.setXYZ(e, Jc.x, Jc.y, Jc.z)
          return this
        }
        applyNormalMatrix(t) {
          for (let e = 0, n = this.count; e < n; e++)
            (Jc.x = this.getX(e)),
              (Jc.y = this.getY(e)),
              (Jc.z = this.getZ(e)),
              Jc.applyNormalMatrix(t),
              this.setXYZ(e, Jc.x, Jc.y, Jc.z)
          return this
        }
        transformDirection(t) {
          for (let e = 0, n = this.count; e < n; e++)
            (Jc.x = this.getX(e)),
              (Jc.y = this.getY(e)),
              (Jc.z = this.getZ(e)),
              Jc.transformDirection(t),
              this.setXYZ(e, Jc.x, Jc.y, Jc.z)
          return this
        }
        set(t, e = 0) {
          return this.array.set(t, e), this
        }
        getX(t) {
          return this.array[t * this.itemSize]
        }
        setX(t, e) {
          return (this.array[t * this.itemSize] = e), this
        }
        getY(t) {
          return this.array[t * this.itemSize + 1]
        }
        setY(t, e) {
          return (this.array[t * this.itemSize + 1] = e), this
        }
        getZ(t) {
          return this.array[t * this.itemSize + 2]
        }
        setZ(t, e) {
          return (this.array[t * this.itemSize + 2] = e), this
        }
        getW(t) {
          return this.array[t * this.itemSize + 3]
        }
        setW(t, e) {
          return (this.array[t * this.itemSize + 3] = e), this
        }
        setXY(t, e, n) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            this
          )
        }
        setXYZ(t, e, n, i) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            (this.array[t + 2] = i),
            this
          )
        }
        setXYZW(t, e, n, i, r) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            (this.array[t + 2] = i),
            (this.array[t + 3] = r),
            this
          )
        }
        onUpload(t) {
          return (this.onUploadCallback = t), this
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this)
        }
        toJSON() {
          const t = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized,
          }
          return (
            '' !== this.name && (t.name = this.name),
            this.usage !== Ja && (t.usage = this.usage),
            (0 === this.updateRange.offset && -1 === this.updateRange.count) ||
              (t.updateRange = this.updateRange),
            t
          )
        }
      }
      Kc.prototype.isBufferAttribute = !0
      class Qc extends Kc {
        constructor(t, e, n) {
          super(new Uint16Array(t), e, n)
        }
      }
      class $c extends Kc {
        constructor(t, e, n) {
          super(new Uint32Array(t), e, n)
        }
      }
      ;(class extends Kc {
        constructor(t, e, n) {
          super(new Uint16Array(t), e, n)
        }
      }.prototype.isFloat16BufferAttribute = !0)
      class tu extends Kc {
        constructor(t, e, n) {
          super(new Float32Array(t), e, n)
        }
      }
      let eu = 0
      const nu = new nc(),
        iu = new Dc(),
        ru = new Tl(),
        su = new Al(),
        ou = new Al(),
        au = new Tl()
      class lu extends Qa {
        constructor() {
          super(),
            Object.defineProperty(this, 'id', { value: eu++ }),
            (this.uuid = rl()),
            (this.name = ''),
            (this.type = 'BufferGeometry'),
            (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.morphTargetsRelative = !1),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.drawRange = { start: 0, count: 1 / 0 }),
            (this.userData = {})
        }
        getIndex() {
          return this.index
        }
        setIndex(t) {
          return (
            Array.isArray(t)
              ? (this.index = new (fl(t) > 65535 ? $c : Qc)(t, 1))
              : (this.index = t),
            this
          )
        }
        getAttribute(t) {
          return this.attributes[t]
        }
        setAttribute(t, e) {
          return (this.attributes[t] = e), this
        }
        deleteAttribute(t) {
          return delete this.attributes[t], this
        }
        hasAttribute(t) {
          return void 0 !== this.attributes[t]
        }
        addGroup(t, e, n = 0) {
          this.groups.push({ start: t, count: e, materialIndex: n })
        }
        clearGroups() {
          this.groups = []
        }
        setDrawRange(t, e) {
          ;(this.drawRange.start = t), (this.drawRange.count = e)
        }
        applyMatrix4(t) {
          const e = this.attributes.position
          void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0))
          const n = this.attributes.normal
          if (void 0 !== n) {
            const e = new pl().getNormalMatrix(t)
            n.applyNormalMatrix(e), (n.needsUpdate = !0)
          }
          const i = this.attributes.tangent
          return (
            void 0 !== i && (i.transformDirection(t), (i.needsUpdate = !0)),
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
          )
        }
        applyQuaternion(t) {
          return nu.makeRotationFromQuaternion(t), this.applyMatrix4(nu), this
        }
        rotateX(t) {
          return nu.makeRotationX(t), this.applyMatrix4(nu), this
        }
        rotateY(t) {
          return nu.makeRotationY(t), this.applyMatrix4(nu), this
        }
        rotateZ(t) {
          return nu.makeRotationZ(t), this.applyMatrix4(nu), this
        }
        translate(t, e, n) {
          return nu.makeTranslation(t, e, n), this.applyMatrix4(nu), this
        }
        scale(t, e, n) {
          return nu.makeScale(t, e, n), this.applyMatrix4(nu), this
        }
        lookAt(t) {
          return (
            iu.lookAt(t), iu.updateMatrix(), this.applyMatrix4(iu.matrix), this
          )
        }
        center() {
          return (
            this.computeBoundingBox(),
            this.boundingBox.getCenter(ru).negate(),
            this.translate(ru.x, ru.y, ru.z),
            this
          )
        }
        setFromPoints(t) {
          const e = []
          for (let n = 0, i = t.length; n < i; n++) {
            const i = t[n]
            e.push(i.x, i.y, i.z || 0)
          }
          return this.setAttribute('position', new tu(e, 3)), this
        }
        computeBoundingBox() {
          null === this.boundingBox && (this.boundingBox = new Al())
          const t = this.attributes.position,
            e = this.morphAttributes.position
          if (t && t.isGLBufferAttribute)
            return (
              console.error(
                'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
                this,
              ),
              void this.boundingBox.set(
                new Tl(-1 / 0, -1 / 0, -1 / 0),
                new Tl(1 / 0, 1 / 0, 1 / 0),
              )
            )
          if (void 0 !== t) {
            if ((this.boundingBox.setFromBufferAttribute(t), e))
              for (let t = 0, n = e.length; t < n; t++) {
                const n = e[t]
                su.setFromBufferAttribute(n),
                  this.morphTargetsRelative
                    ? (au.addVectors(this.boundingBox.min, su.min),
                      this.boundingBox.expandByPoint(au),
                      au.addVectors(this.boundingBox.max, su.max),
                      this.boundingBox.expandByPoint(au))
                    : (this.boundingBox.expandByPoint(su.min),
                      this.boundingBox.expandByPoint(su.max))
              }
          } else this.boundingBox.makeEmpty()
          ;(isNaN(this.boundingBox.min.x) ||
            isNaN(this.boundingBox.min.y) ||
            isNaN(this.boundingBox.min.z)) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
              this,
            )
        }
        computeBoundingSphere() {
          null === this.boundingSphere && (this.boundingSphere = new Xl())
          const t = this.attributes.position,
            e = this.morphAttributes.position
          if (t && t.isGLBufferAttribute)
            return (
              console.error(
                'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
                this,
              ),
              void this.boundingSphere.set(new Tl(), 1 / 0)
            )
          if (t) {
            const n = this.boundingSphere.center
            if ((su.setFromBufferAttribute(t), e))
              for (let t = 0, n = e.length; t < n; t++) {
                const n = e[t]
                ou.setFromBufferAttribute(n),
                  this.morphTargetsRelative
                    ? (au.addVectors(su.min, ou.min),
                      su.expandByPoint(au),
                      au.addVectors(su.max, ou.max),
                      su.expandByPoint(au))
                    : (su.expandByPoint(ou.min), su.expandByPoint(ou.max))
              }
            su.getCenter(n)
            let i = 0
            for (let e = 0, r = t.count; e < r; e++)
              au.fromBufferAttribute(t, e),
                (i = Math.max(i, n.distanceToSquared(au)))
            if (e)
              for (let r = 0, s = e.length; r < s; r++) {
                const s = e[r],
                  o = this.morphTargetsRelative
                for (let e = 0, r = s.count; e < r; e++)
                  au.fromBufferAttribute(s, e),
                    o && (ru.fromBufferAttribute(t, e), au.add(ru)),
                    (i = Math.max(i, n.distanceToSquared(au)))
              }
            ;(this.boundingSphere.radius = Math.sqrt(i)),
              isNaN(this.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this,
                )
          }
        }
        computeTangents() {
          const t = this.index,
            e = this.attributes
          if (
            null === t ||
            void 0 === e.position ||
            void 0 === e.normal ||
            void 0 === e.uv
          )
            return void console.error(
              'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)',
            )
          const n = t.array,
            i = e.position.array,
            r = e.normal.array,
            s = e.uv.array,
            o = i.length / 3
          void 0 === e.tangent &&
            this.setAttribute('tangent', new Kc(new Float32Array(4 * o), 4))
          const a = e.tangent.array,
            l = [],
            c = []
          for (let t = 0; t < o; t++) (l[t] = new Tl()), (c[t] = new Tl())
          const u = new Tl(),
            h = new Tl(),
            d = new Tl(),
            p = new dl(),
            f = new dl(),
            m = new dl(),
            g = new Tl(),
            v = new Tl()
          function _(t, e, n) {
            u.fromArray(i, 3 * t),
              h.fromArray(i, 3 * e),
              d.fromArray(i, 3 * n),
              p.fromArray(s, 2 * t),
              f.fromArray(s, 2 * e),
              m.fromArray(s, 2 * n),
              h.sub(u),
              d.sub(u),
              f.sub(p),
              m.sub(p)
            const r = 1 / (f.x * m.y - m.x * f.y)
            isFinite(r) &&
              (g
                .copy(h)
                .multiplyScalar(m.y)
                .addScaledVector(d, -f.y)
                .multiplyScalar(r),
              v
                .copy(d)
                .multiplyScalar(f.x)
                .addScaledVector(h, -m.x)
                .multiplyScalar(r),
              l[t].add(g),
              l[e].add(g),
              l[n].add(g),
              c[t].add(v),
              c[e].add(v),
              c[n].add(v))
          }
          let y = this.groups
          0 === y.length && (y = [{ start: 0, count: n.length }])
          for (let t = 0, e = y.length; t < e; ++t) {
            const e = y[t],
              i = e.start
            for (let t = i, r = i + e.count; t < r; t += 3)
              _(n[t + 0], n[t + 1], n[t + 2])
          }
          const x = new Tl(),
            b = new Tl(),
            w = new Tl(),
            M = new Tl()
          function S(t) {
            w.fromArray(r, 3 * t), M.copy(w)
            const e = l[t]
            x.copy(e),
              x.sub(w.multiplyScalar(w.dot(e))).normalize(),
              b.crossVectors(M, e)
            const n = b.dot(c[t]) < 0 ? -1 : 1
            ;(a[4 * t] = x.x),
              (a[4 * t + 1] = x.y),
              (a[4 * t + 2] = x.z),
              (a[4 * t + 3] = n)
          }
          for (let t = 0, e = y.length; t < e; ++t) {
            const e = y[t],
              i = e.start
            for (let t = i, r = i + e.count; t < r; t += 3)
              S(n[t + 0]), S(n[t + 1]), S(n[t + 2])
          }
        }
        computeVertexNormals() {
          const t = this.index,
            e = this.getAttribute('position')
          if (void 0 !== e) {
            let n = this.getAttribute('normal')
            if (void 0 === n)
              (n = new Kc(new Float32Array(3 * e.count), 3)),
                this.setAttribute('normal', n)
            else for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0)
            const i = new Tl(),
              r = new Tl(),
              s = new Tl(),
              o = new Tl(),
              a = new Tl(),
              l = new Tl(),
              c = new Tl(),
              u = new Tl()
            if (t)
              for (let h = 0, d = t.count; h < d; h += 3) {
                const d = t.getX(h + 0),
                  p = t.getX(h + 1),
                  f = t.getX(h + 2)
                i.fromBufferAttribute(e, d),
                  r.fromBufferAttribute(e, p),
                  s.fromBufferAttribute(e, f),
                  c.subVectors(s, r),
                  u.subVectors(i, r),
                  c.cross(u),
                  o.fromBufferAttribute(n, d),
                  a.fromBufferAttribute(n, p),
                  l.fromBufferAttribute(n, f),
                  o.add(c),
                  a.add(c),
                  l.add(c),
                  n.setXYZ(d, o.x, o.y, o.z),
                  n.setXYZ(p, a.x, a.y, a.z),
                  n.setXYZ(f, l.x, l.y, l.z)
              }
            else
              for (let t = 0, o = e.count; t < o; t += 3)
                i.fromBufferAttribute(e, t + 0),
                  r.fromBufferAttribute(e, t + 1),
                  s.fromBufferAttribute(e, t + 2),
                  c.subVectors(s, r),
                  u.subVectors(i, r),
                  c.cross(u),
                  n.setXYZ(t + 0, c.x, c.y, c.z),
                  n.setXYZ(t + 1, c.x, c.y, c.z),
                  n.setXYZ(t + 2, c.x, c.y, c.z)
            this.normalizeNormals(), (n.needsUpdate = !0)
          }
        }
        merge(t, e) {
          if (!t || !t.isBufferGeometry)
            return void console.error(
              'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.',
              t,
            )
          void 0 === e &&
            ((e = 0),
            console.warn(
              'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.',
            ))
          const n = this.attributes
          for (const i in n) {
            if (void 0 === t.attributes[i]) continue
            const r = n[i].array,
              s = t.attributes[i],
              o = s.array,
              a = s.itemSize * e,
              l = Math.min(o.length, r.length - a)
            for (let t = 0, e = a; t < l; t++, e++) r[e] = o[t]
          }
          return this
        }
        normalizeNormals() {
          const t = this.attributes.normal
          for (let e = 0, n = t.count; e < n; e++)
            au.fromBufferAttribute(t, e),
              au.normalize(),
              t.setXYZ(e, au.x, au.y, au.z)
        }
        toNonIndexed() {
          function t(t, e) {
            const n = t.array,
              i = t.itemSize,
              r = t.normalized,
              s = new n.constructor(e.length * i)
            let o = 0,
              a = 0
            for (let r = 0, l = e.length; r < l; r++) {
              o = t.isInterleavedBufferAttribute
                ? e[r] * t.data.stride + t.offset
                : e[r] * i
              for (let t = 0; t < i; t++) s[a++] = n[o++]
            }
            return new Kc(s, i, r)
          }
          if (null === this.index)
            return (
              console.warn(
                'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.',
              ),
              this
            )
          const e = new lu(),
            n = this.index.array,
            i = this.attributes
          for (const r in i) {
            const s = t(i[r], n)
            e.setAttribute(r, s)
          }
          const r = this.morphAttributes
          for (const i in r) {
            const s = [],
              o = r[i]
            for (let e = 0, i = o.length; e < i; e++) {
              const i = t(o[e], n)
              s.push(i)
            }
            e.morphAttributes[i] = s
          }
          e.morphTargetsRelative = this.morphTargetsRelative
          const s = this.groups
          for (let t = 0, n = s.length; t < n; t++) {
            const n = s[t]
            e.addGroup(n.start, n.count, n.materialIndex)
          }
          return e
        }
        toJSON() {
          const t = {
            metadata: {
              version: 4.5,
              type: 'BufferGeometry',
              generator: 'BufferGeometry.toJSON',
            },
          }
          if (
            ((t.uuid = this.uuid),
            (t.type = this.type),
            '' !== this.name && (t.name = this.name),
            Object.keys(this.userData).length > 0 &&
              (t.userData = this.userData),
            void 0 !== this.parameters)
          ) {
            const e = this.parameters
            for (const n in e) void 0 !== e[n] && (t[n] = e[n])
            return t
          }
          t.data = { attributes: {} }
          const e = this.index
          null !== e &&
            (t.data.index = {
              type: e.array.constructor.name,
              array: Array.prototype.slice.call(e.array),
            })
          const n = this.attributes
          for (const e in n) {
            const i = n[e]
            t.data.attributes[e] = i.toJSON(t.data)
          }
          const i = {}
          let r = !1
          for (const e in this.morphAttributes) {
            const n = this.morphAttributes[e],
              s = []
            for (let e = 0, i = n.length; e < i; e++) {
              const i = n[e]
              s.push(i.toJSON(t.data))
            }
            s.length > 0 && ((i[e] = s), (r = !0))
          }
          r &&
            ((t.data.morphAttributes = i),
            (t.data.morphTargetsRelative = this.morphTargetsRelative))
          const s = this.groups
          s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)))
          const o = this.boundingSphere
          return (
            null !== o &&
              (t.data.boundingSphere = {
                center: o.center.toArray(),
                radius: o.radius,
              }),
            t
          )
        }
        clone() {
          return new this.constructor().copy(this)
        }
        copy(t) {
          ;(this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null)
          const e = {}
          this.name = t.name
          const n = t.index
          null !== n && this.setIndex(n.clone(e))
          const i = t.attributes
          for (const t in i) {
            const n = i[t]
            this.setAttribute(t, n.clone(e))
          }
          const r = t.morphAttributes
          for (const t in r) {
            const n = [],
              i = r[t]
            for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e))
            this.morphAttributes[t] = n
          }
          this.morphTargetsRelative = t.morphTargetsRelative
          const s = t.groups
          for (let t = 0, e = s.length; t < e; t++) {
            const e = s[t]
            this.addGroup(e.start, e.count, e.materialIndex)
          }
          const o = t.boundingBox
          null !== o && (this.boundingBox = o.clone())
          const a = t.boundingSphere
          return (
            null !== a && (this.boundingSphere = a.clone()),
            (this.drawRange.start = t.drawRange.start),
            (this.drawRange.count = t.drawRange.count),
            (this.userData = t.userData),
            void 0 !== t.parameters &&
              (this.parameters = Object.assign({}, t.parameters)),
            this
          )
        }
        dispose() {
          this.dispatchEvent({ type: 'dispose' })
        }
      }
      lu.prototype.isBufferGeometry = !0
      const cu = new nc(),
        uu = new ec(),
        hu = new Xl(),
        du = new Tl(),
        pu = new Tl(),
        fu = new Tl(),
        mu = new Tl(),
        gu = new Tl(),
        vu = new Tl(),
        _u = new Tl(),
        yu = new Tl(),
        xu = new Tl(),
        bu = new dl(),
        wu = new dl(),
        Mu = new dl(),
        Su = new Tl(),
        Tu = new Tl()
      class Eu extends Dc {
        constructor(t = new lu(), e = new Yc()) {
          super(),
            (this.type = 'Mesh'),
            (this.geometry = t),
            (this.material = e),
            this.updateMorphTargets()
        }
        copy(t) {
          return (
            super.copy(t),
            void 0 !== t.morphTargetInfluences &&
              (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
            void 0 !== t.morphTargetDictionary &&
              (this.morphTargetDictionary = Object.assign(
                {},
                t.morphTargetDictionary,
              )),
            (this.material = t.material),
            (this.geometry = t.geometry),
            this
          )
        }
        updateMorphTargets() {
          const t = this.geometry
          if (t.isBufferGeometry) {
            const e = t.morphAttributes,
              n = Object.keys(e)
            if (n.length > 0) {
              const t = e[n[0]]
              if (void 0 !== t) {
                ;(this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {})
                for (let e = 0, n = t.length; e < n; e++) {
                  const n = t[e].name || String(e)
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[n] = e)
                }
              }
            }
          } else {
            const e = t.morphTargets
            void 0 !== e &&
              e.length > 0 &&
              console.error(
                'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',
              )
          }
        }
        raycast(t, e) {
          const n = this.geometry,
            i = this.material,
            r = this.matrixWorld
          if (void 0 === i) return
          if (
            (null === n.boundingSphere && n.computeBoundingSphere(),
            hu.copy(n.boundingSphere),
            hu.applyMatrix4(r),
            !1 === t.ray.intersectsSphere(hu))
          )
            return
          if (
            (cu.copy(r).invert(),
            uu.copy(t.ray).applyMatrix4(cu),
            null !== n.boundingBox && !1 === uu.intersectsBox(n.boundingBox))
          )
            return
          let s
          if (n.isBufferGeometry) {
            const r = n.index,
              o = n.attributes.position,
              a = n.morphAttributes.position,
              l = n.morphTargetsRelative,
              c = n.attributes.uv,
              u = n.attributes.uv2,
              h = n.groups,
              d = n.drawRange
            if (null !== r)
              if (Array.isArray(i))
                for (let n = 0, p = h.length; n < p; n++) {
                  const p = h[n],
                    f = i[p.materialIndex]
                  for (
                    let n = Math.max(p.start, d.start),
                      i = Math.min(
                        r.count,
                        Math.min(p.start + p.count, d.start + d.count),
                      );
                    n < i;
                    n += 3
                  ) {
                    const i = r.getX(n),
                      h = r.getX(n + 1),
                      d = r.getX(n + 2)
                    ;(s = Du(this, f, t, uu, o, a, l, c, u, i, h, d)),
                      s &&
                        ((s.faceIndex = Math.floor(n / 3)),
                        (s.face.materialIndex = p.materialIndex),
                        e.push(s))
                  }
                }
              else
                for (
                  let n = Math.max(0, d.start),
                    h = Math.min(r.count, d.start + d.count);
                  n < h;
                  n += 3
                ) {
                  const h = r.getX(n),
                    d = r.getX(n + 1),
                    p = r.getX(n + 2)
                  ;(s = Du(this, i, t, uu, o, a, l, c, u, h, d, p)),
                    s && ((s.faceIndex = Math.floor(n / 3)), e.push(s))
                }
            else if (void 0 !== o)
              if (Array.isArray(i))
                for (let n = 0, r = h.length; n < r; n++) {
                  const r = h[n],
                    p = i[r.materialIndex]
                  for (
                    let n = Math.max(r.start, d.start),
                      i = Math.min(
                        o.count,
                        Math.min(r.start + r.count, d.start + d.count),
                      );
                    n < i;
                    n += 3
                  )
                    (s = Du(this, p, t, uu, o, a, l, c, u, n, n + 1, n + 2)),
                      s &&
                        ((s.faceIndex = Math.floor(n / 3)),
                        (s.face.materialIndex = r.materialIndex),
                        e.push(s))
                }
              else
                for (
                  let n = Math.max(0, d.start),
                    r = Math.min(o.count, d.start + d.count);
                  n < r;
                  n += 3
                )
                  (s = Du(this, i, t, uu, o, a, l, c, u, n, n + 1, n + 2)),
                    s && ((s.faceIndex = Math.floor(n / 3)), e.push(s))
          } else
            n.isGeometry &&
              console.error(
                'THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',
              )
        }
      }
      function Du(t, e, n, i, r, s, o, a, l, c, u, h) {
        du.fromBufferAttribute(r, c),
          pu.fromBufferAttribute(r, u),
          fu.fromBufferAttribute(r, h)
        const d = t.morphTargetInfluences
        if (s && d) {
          _u.set(0, 0, 0), yu.set(0, 0, 0), xu.set(0, 0, 0)
          for (let t = 0, e = s.length; t < e; t++) {
            const e = d[t],
              n = s[t]
            0 !== e &&
              (mu.fromBufferAttribute(n, c),
              gu.fromBufferAttribute(n, u),
              vu.fromBufferAttribute(n, h),
              o
                ? (_u.addScaledVector(mu, e),
                  yu.addScaledVector(gu, e),
                  xu.addScaledVector(vu, e))
                : (_u.addScaledVector(mu.sub(du), e),
                  yu.addScaledVector(gu.sub(pu), e),
                  xu.addScaledVector(vu.sub(fu), e)))
          }
          du.add(_u), pu.add(yu), fu.add(xu)
        }
        t.isSkinnedMesh &&
          (t.boneTransform(c, du),
          t.boneTransform(u, pu),
          t.boneTransform(h, fu))
        const p = (function (t, e, n, i, r, s, o, a) {
          let l
          if (
            ((l =
              1 === e.side
                ? i.intersectTriangle(o, s, r, !0, a)
                : i.intersectTriangle(r, s, o, 2 !== e.side, a)),
            null === l)
          )
            return null
          Tu.copy(a), Tu.applyMatrix4(t.matrixWorld)
          const c = n.ray.origin.distanceTo(Tu)
          return c < n.near || c > n.far
            ? null
            : { distance: c, point: Tu.clone(), object: t }
        })(t, e, n, i, du, pu, fu, Su)
        if (p) {
          a &&
            (bu.fromBufferAttribute(a, c),
            wu.fromBufferAttribute(a, u),
            Mu.fromBufferAttribute(a, h),
            (p.uv = Bc.getUV(Su, du, pu, fu, bu, wu, Mu, new dl()))),
            l &&
              (bu.fromBufferAttribute(l, c),
              wu.fromBufferAttribute(l, u),
              Mu.fromBufferAttribute(l, h),
              (p.uv2 = Bc.getUV(Su, du, pu, fu, bu, wu, Mu, new dl())))
          const t = { a: c, b: u, c: h, normal: new Tl(), materialIndex: 0 }
          Bc.getNormal(du, pu, fu, t.normal), (p.face = t)
        }
        return p
      }
      Eu.prototype.isMesh = !0
      class Au extends lu {
        constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
          super(),
            (this.type = 'BoxGeometry'),
            (this.parameters = {
              width: t,
              height: e,
              depth: n,
              widthSegments: i,
              heightSegments: r,
              depthSegments: s,
            })
          const o = this
          ;(i = Math.floor(i)), (r = Math.floor(r)), (s = Math.floor(s))
          const a = [],
            l = [],
            c = [],
            u = []
          let h = 0,
            d = 0
          function p(t, e, n, i, r, s, p, f, m, g, v) {
            const _ = s / m,
              y = p / g,
              x = s / 2,
              b = p / 2,
              w = f / 2,
              M = m + 1,
              S = g + 1
            let T = 0,
              E = 0
            const D = new Tl()
            for (let s = 0; s < S; s++) {
              const o = s * y - b
              for (let a = 0; a < M; a++) {
                const h = a * _ - x
                ;(D[t] = h * i),
                  (D[e] = o * r),
                  (D[n] = w),
                  l.push(D.x, D.y, D.z),
                  (D[t] = 0),
                  (D[e] = 0),
                  (D[n] = f > 0 ? 1 : -1),
                  c.push(D.x, D.y, D.z),
                  u.push(a / m),
                  u.push(1 - s / g),
                  (T += 1)
              }
            }
            for (let t = 0; t < g; t++)
              for (let e = 0; e < m; e++) {
                const n = h + e + M * t,
                  i = h + e + M * (t + 1),
                  r = h + (e + 1) + M * (t + 1),
                  s = h + (e + 1) + M * t
                a.push(n, i, s), a.push(i, r, s), (E += 6)
              }
            o.addGroup(d, E, v), (d += E), (h += T)
          }
          p('z', 'y', 'x', -1, -1, n, e, t, s, r, 0),
            p('z', 'y', 'x', 1, -1, n, e, -t, s, r, 1),
            p('x', 'z', 'y', 1, 1, t, n, e, i, s, 2),
            p('x', 'z', 'y', 1, -1, t, n, -e, i, s, 3),
            p('x', 'y', 'z', 1, -1, t, e, n, i, r, 4),
            p('x', 'y', 'z', -1, -1, t, e, -n, i, r, 5),
            this.setIndex(a),
            this.setAttribute('position', new tu(l, 3)),
            this.setAttribute('normal', new tu(c, 3)),
            this.setAttribute('uv', new tu(u, 2))
        }
        static fromJSON(t) {
          return new Au(
            t.width,
            t.height,
            t.depth,
            t.widthSegments,
            t.heightSegments,
            t.depthSegments,
          )
        }
      }
      function Cu(t) {
        const e = {}
        for (const n in t) {
          e[n] = {}
          for (const i in t[n]) {
            const r = t[n][i]
            r &&
            (r.isColor ||
              r.isMatrix3 ||
              r.isMatrix4 ||
              r.isVector2 ||
              r.isVector3 ||
              r.isVector4 ||
              r.isTexture ||
              r.isQuaternion)
              ? (e[n][i] = r.clone())
              : Array.isArray(r)
              ? (e[n][i] = r.slice())
              : (e[n][i] = r)
          }
        }
        return e
      }
      function Lu(t) {
        const e = {}
        for (let n = 0; n < t.length; n++) {
          const i = Cu(t[n])
          for (const t in i) e[t] = i[t]
        }
        return e
      }
      const Ru = { clone: Cu, merge: Lu }
      class Pu extends Uc {
        constructor(t) {
          super(),
            (this.type = 'ShaderMaterial'),
            (this.defines = {}),
            (this.uniforms = {}),
            (this.vertexShader =
              'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}'),
            (this.fragmentShader =
              'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}'),
            (this.linewidth = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.lights = !1),
            (this.clipping = !1),
            (this.extensions = {
              derivatives: !1,
              fragDepth: !1,
              drawBuffers: !1,
              shaderTextureLOD: !1,
            }),
            (this.defaultAttributeValues = {
              color: [1, 1, 1],
              uv: [0, 0],
              uv2: [0, 0],
            }),
            (this.index0AttributeName = void 0),
            (this.uniformsNeedUpdate = !1),
            (this.glslVersion = null),
            void 0 !== t &&
              (void 0 !== t.attributes &&
                console.error(
                  'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.',
                ),
              this.setValues(t))
        }
        copy(t) {
          return (
            super.copy(t),
            (this.fragmentShader = t.fragmentShader),
            (this.vertexShader = t.vertexShader),
            (this.uniforms = Cu(t.uniforms)),
            (this.defines = Object.assign({}, t.defines)),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.lights = t.lights),
            (this.clipping = t.clipping),
            (this.extensions = Object.assign({}, t.extensions)),
            (this.glslVersion = t.glslVersion),
            this
          )
        }
        toJSON(t) {
          const e = super.toJSON(t)
          ;(e.glslVersion = this.glslVersion), (e.uniforms = {})
          for (const n in this.uniforms) {
            const i = this.uniforms[n].value
            i && i.isTexture
              ? (e.uniforms[n] = { type: 't', value: i.toJSON(t).uuid })
              : i && i.isColor
              ? (e.uniforms[n] = { type: 'c', value: i.getHex() })
              : i && i.isVector2
              ? (e.uniforms[n] = { type: 'v2', value: i.toArray() })
              : i && i.isVector3
              ? (e.uniforms[n] = { type: 'v3', value: i.toArray() })
              : i && i.isVector4
              ? (e.uniforms[n] = { type: 'v4', value: i.toArray() })
              : i && i.isMatrix3
              ? (e.uniforms[n] = { type: 'm3', value: i.toArray() })
              : i && i.isMatrix4
              ? (e.uniforms[n] = { type: 'm4', value: i.toArray() })
              : (e.uniforms[n] = { value: i })
          }
          Object.keys(this.defines).length > 0 && (e.defines = this.defines),
            (e.vertexShader = this.vertexShader),
            (e.fragmentShader = this.fragmentShader)
          const n = {}
          for (const t in this.extensions)
            !0 === this.extensions[t] && (n[t] = !0)
          return Object.keys(n).length > 0 && (e.extensions = n), e
        }
      }
      Pu.prototype.isShaderMaterial = !0
      class Fu extends Dc {
        constructor() {
          super(),
            (this.type = 'Camera'),
            (this.matrixWorldInverse = new nc()),
            (this.projectionMatrix = new nc()),
            (this.projectionMatrixInverse = new nc())
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            this.matrixWorldInverse.copy(t.matrixWorldInverse),
            this.projectionMatrix.copy(t.projectionMatrix),
            this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
            this
          )
        }
        getWorldDirection(t) {
          this.updateWorldMatrix(!0, !1)
          const e = this.matrixWorld.elements
          return t.set(-e[8], -e[9], -e[10]).normalize()
        }
        updateMatrixWorld(t) {
          super.updateMatrixWorld(t),
            this.matrixWorldInverse.copy(this.matrixWorld).invert()
        }
        updateWorldMatrix(t, e) {
          super.updateWorldMatrix(t, e),
            this.matrixWorldInverse.copy(this.matrixWorld).invert()
        }
        clone() {
          return new this.constructor().copy(this)
        }
      }
      Fu.prototype.isCamera = !0
      class Iu extends Fu {
        constructor(t = 50, e = 1, n = 0.1, i = 2e3) {
          super(),
            (this.type = 'PerspectiveCamera'),
            (this.fov = t),
            (this.zoom = 1),
            (this.near = n),
            (this.far = i),
            (this.focus = 10),
            (this.aspect = e),
            (this.view = null),
            (this.filmGauge = 35),
            (this.filmOffset = 0),
            this.updateProjectionMatrix()
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            (this.fov = t.fov),
            (this.zoom = t.zoom),
            (this.near = t.near),
            (this.far = t.far),
            (this.focus = t.focus),
            (this.aspect = t.aspect),
            (this.view = null === t.view ? null : Object.assign({}, t.view)),
            (this.filmGauge = t.filmGauge),
            (this.filmOffset = t.filmOffset),
            this
          )
        }
        setFocalLength(t) {
          const e = (0.5 * this.getFilmHeight()) / t
          ;(this.fov = 2 * el * Math.atan(e)), this.updateProjectionMatrix()
        }
        getFocalLength() {
          const t = Math.tan(0.5 * tl * this.fov)
          return (0.5 * this.getFilmHeight()) / t
        }
        getEffectiveFOV() {
          return 2 * el * Math.atan(Math.tan(0.5 * tl * this.fov) / this.zoom)
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1)
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1)
        }
        setViewOffset(t, e, n, i, r, s) {
          ;(this.aspect = t / e),
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
            (this.view.enabled = !0),
            (this.view.fullWidth = t),
            (this.view.fullHeight = e),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = s),
            this.updateProjectionMatrix()
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        }
        updateProjectionMatrix() {
          const t = this.near
          let e = (t * Math.tan(0.5 * tl * this.fov)) / this.zoom,
            n = 2 * e,
            i = this.aspect * n,
            r = -0.5 * i
          const s = this.view
          if (null !== this.view && this.view.enabled) {
            const t = s.fullWidth,
              o = s.fullHeight
            ;(r += (s.offsetX * i) / t),
              (e -= (s.offsetY * n) / o),
              (i *= s.width / t),
              (n *= s.height / o)
          }
          const o = this.filmOffset
          0 !== o && (r += (t * o) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(
              r,
              r + i,
              e,
              e - n,
              t,
              this.far,
            ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        }
        toJSON(t) {
          const e = super.toJSON(t)
          return (
            (e.object.fov = this.fov),
            (e.object.zoom = this.zoom),
            (e.object.near = this.near),
            (e.object.far = this.far),
            (e.object.focus = this.focus),
            (e.object.aspect = this.aspect),
            null !== this.view &&
              (e.object.view = Object.assign({}, this.view)),
            (e.object.filmGauge = this.filmGauge),
            (e.object.filmOffset = this.filmOffset),
            e
          )
        }
      }
      Iu.prototype.isPerspectiveCamera = !0
      const Ou = 90
      class Nu extends Dc {
        constructor(t, e, n) {
          if (
            (super(),
            (this.type = 'CubeCamera'),
            !0 !== n.isWebGLCubeRenderTarget)
          )
            return void console.error(
              'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.',
            )
          this.renderTarget = n
          const i = new Iu(Ou, 1, t, e)
          ;(i.layers = this.layers),
            i.up.set(0, -1, 0),
            i.lookAt(new Tl(1, 0, 0)),
            this.add(i)
          const r = new Iu(Ou, 1, t, e)
          ;(r.layers = this.layers),
            r.up.set(0, -1, 0),
            r.lookAt(new Tl(-1, 0, 0)),
            this.add(r)
          const s = new Iu(Ou, 1, t, e)
          ;(s.layers = this.layers),
            s.up.set(0, 0, 1),
            s.lookAt(new Tl(0, 1, 0)),
            this.add(s)
          const o = new Iu(Ou, 1, t, e)
          ;(o.layers = this.layers),
            o.up.set(0, 0, -1),
            o.lookAt(new Tl(0, -1, 0)),
            this.add(o)
          const a = new Iu(Ou, 1, t, e)
          ;(a.layers = this.layers),
            a.up.set(0, -1, 0),
            a.lookAt(new Tl(0, 0, 1)),
            this.add(a)
          const l = new Iu(Ou, 1, t, e)
          ;(l.layers = this.layers),
            l.up.set(0, -1, 0),
            l.lookAt(new Tl(0, 0, -1)),
            this.add(l)
        }
        update(t, e) {
          null === this.parent && this.updateMatrixWorld()
          const n = this.renderTarget,
            [i, r, s, o, a, l] = this.children,
            c = t.xr.enabled,
            u = t.getRenderTarget()
          t.xr.enabled = !1
          const h = n.texture.generateMipmaps
          ;(n.texture.generateMipmaps = !1),
            t.setRenderTarget(n, 0),
            t.render(e, i),
            t.setRenderTarget(n, 1),
            t.render(e, r),
            t.setRenderTarget(n, 2),
            t.render(e, s),
            t.setRenderTarget(n, 3),
            t.render(e, o),
            t.setRenderTarget(n, 4),
            t.render(e, a),
            (n.texture.generateMipmaps = h),
            t.setRenderTarget(n, 5),
            t.render(e, l),
            t.setRenderTarget(u),
            (t.xr.enabled = c)
        }
      }
      class ku extends yl {
        constructor(t, e, n, i, r, s, o, a, l, c) {
          super(
            (t = void 0 !== t ? t : []),
            (e = void 0 !== e ? e : va),
            n,
            i,
            r,
            s,
            o,
            a,
            l,
            c,
          ),
            (this.flipY = !1)
        }
        get images() {
          return this.image
        }
        set images(t) {
          this.image = t
        }
      }
      ku.prototype.isCubeTexture = !0
      class Bu extends wl {
        constructor(t, e, n) {
          Number.isInteger(e) &&
            (console.warn(
              'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )',
            ),
            (e = n)),
            super(t, t, e),
            (e = e || {}),
            (this.texture = new ku(
              void 0,
              e.mapping,
              e.wrapS,
              e.wrapT,
              e.magFilter,
              e.minFilter,
              e.format,
              e.type,
              e.anisotropy,
              e.encoding,
            )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.generateMipmaps =
              void 0 !== e.generateMipmaps && e.generateMipmaps),
            (this.texture.minFilter =
              void 0 !== e.minFilter ? e.minFilter : Ea),
            (this.texture._needsFlipEnvMap = !1)
        }
        fromEquirectangularTexture(t, e) {
          ;(this.texture.type = e.type),
            (this.texture.format = Oa),
            (this.texture.encoding = e.encoding),
            (this.texture.generateMipmaps = e.generateMipmaps),
            (this.texture.minFilter = e.minFilter),
            (this.texture.magFilter = e.magFilter)
          const n = { tEquirect: { value: null } },
            i =
              '\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t',
            r =
              '\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t',
            s = new Au(5, 5, 5),
            o = new Pu({
              name: 'CubemapFromEquirect',
              uniforms: Cu(n),
              vertexShader: i,
              fragmentShader: r,
              side: 1,
              blending: 0,
            })
          o.uniforms.tEquirect.value = e
          const a = new Eu(s, o),
            l = e.minFilter
          return (
            e.minFilter === Da && (e.minFilter = Ea),
            new Nu(1, 10, this).update(t, a),
            (e.minFilter = l),
            a.geometry.dispose(),
            a.material.dispose(),
            this
          )
        }
        clear(t, e, n, i) {
          const r = t.getRenderTarget()
          for (let r = 0; r < 6; r++)
            t.setRenderTarget(this, r), t.clear(e, n, i)
          t.setRenderTarget(r)
        }
      }
      Bu.prototype.isWebGLCubeRenderTarget = !0
      const zu = new Tl(),
        Uu = new Tl(),
        Hu = new pl()
      class Gu {
        constructor(t = new Tl(1, 0, 0), e = 0) {
          ;(this.normal = t), (this.constant = e)
        }
        set(t, e) {
          return this.normal.copy(t), (this.constant = e), this
        }
        setComponents(t, e, n, i) {
          return this.normal.set(t, e, n), (this.constant = i), this
        }
        setFromNormalAndCoplanarPoint(t, e) {
          return (
            this.normal.copy(t), (this.constant = -e.dot(this.normal)), this
          )
        }
        setFromCoplanarPoints(t, e, n) {
          const i = zu.subVectors(n, e).cross(Uu.subVectors(t, e)).normalize()
          return this.setFromNormalAndCoplanarPoint(i, t), this
        }
        copy(t) {
          return this.normal.copy(t.normal), (this.constant = t.constant), this
        }
        normalize() {
          const t = 1 / this.normal.length()
          return this.normal.multiplyScalar(t), (this.constant *= t), this
        }
        negate() {
          return (this.constant *= -1), this.normal.negate(), this
        }
        distanceToPoint(t) {
          return this.normal.dot(t) + this.constant
        }
        distanceToSphere(t) {
          return this.distanceToPoint(t.center) - t.radius
        }
        projectPoint(t, e) {
          return e
            .copy(this.normal)
            .multiplyScalar(-this.distanceToPoint(t))
            .add(t)
        }
        intersectLine(t, e) {
          const n = t.delta(zu),
            i = this.normal.dot(n)
          if (0 === i)
            return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null
          const r = -(t.start.dot(this.normal) + this.constant) / i
          return r < 0 || r > 1
            ? null
            : e.copy(n).multiplyScalar(r).add(t.start)
        }
        intersectsLine(t) {
          const e = this.distanceToPoint(t.start),
            n = this.distanceToPoint(t.end)
          return (e < 0 && n > 0) || (n < 0 && e > 0)
        }
        intersectsBox(t) {
          return t.intersectsPlane(this)
        }
        intersectsSphere(t) {
          return t.intersectsPlane(this)
        }
        coplanarPoint(t) {
          return t.copy(this.normal).multiplyScalar(-this.constant)
        }
        applyMatrix4(t, e) {
          const n = e || Hu.getNormalMatrix(t),
            i = this.coplanarPoint(zu).applyMatrix4(t),
            r = this.normal.applyMatrix3(n).normalize()
          return (this.constant = -i.dot(r)), this
        }
        translate(t) {
          return (this.constant -= t.dot(this.normal)), this
        }
        equals(t) {
          return t.normal.equals(this.normal) && t.constant === this.constant
        }
        clone() {
          return new this.constructor().copy(this)
        }
      }
      Gu.prototype.isPlane = !0
      const Vu = new Xl(),
        Wu = new Tl()
      class ju {
        constructor(
          t = new Gu(),
          e = new Gu(),
          n = new Gu(),
          i = new Gu(),
          r = new Gu(),
          s = new Gu(),
        ) {
          this.planes = [t, e, n, i, r, s]
        }
        set(t, e, n, i, r, s) {
          const o = this.planes
          return (
            o[0].copy(t),
            o[1].copy(e),
            o[2].copy(n),
            o[3].copy(i),
            o[4].copy(r),
            o[5].copy(s),
            this
          )
        }
        copy(t) {
          const e = this.planes
          for (let n = 0; n < 6; n++) e[n].copy(t.planes[n])
          return this
        }
        setFromProjectionMatrix(t) {
          const e = this.planes,
            n = t.elements,
            i = n[0],
            r = n[1],
            s = n[2],
            o = n[3],
            a = n[4],
            l = n[5],
            c = n[6],
            u = n[7],
            h = n[8],
            d = n[9],
            p = n[10],
            f = n[11],
            m = n[12],
            g = n[13],
            v = n[14],
            _ = n[15]
          return (
            e[0].setComponents(o - i, u - a, f - h, _ - m).normalize(),
            e[1].setComponents(o + i, u + a, f + h, _ + m).normalize(),
            e[2].setComponents(o + r, u + l, f + d, _ + g).normalize(),
            e[3].setComponents(o - r, u - l, f - d, _ - g).normalize(),
            e[4].setComponents(o - s, u - c, f - p, _ - v).normalize(),
            e[5].setComponents(o + s, u + c, f + p, _ + v).normalize(),
            this
          )
        }
        intersectsObject(t) {
          const e = t.geometry
          return (
            null === e.boundingSphere && e.computeBoundingSphere(),
            Vu.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
            this.intersectsSphere(Vu)
          )
        }
        intersectsSprite(t) {
          return (
            Vu.center.set(0, 0, 0),
            (Vu.radius = 0.7071067811865476),
            Vu.applyMatrix4(t.matrixWorld),
            this.intersectsSphere(Vu)
          )
        }
        intersectsSphere(t) {
          const e = this.planes,
            n = t.center,
            i = -t.radius
          for (let t = 0; t < 6; t++) if (e[t].distanceToPoint(n) < i) return !1
          return !0
        }
        intersectsBox(t) {
          const e = this.planes
          for (let n = 0; n < 6; n++) {
            const i = e[n]
            if (
              ((Wu.x = i.normal.x > 0 ? t.max.x : t.min.x),
              (Wu.y = i.normal.y > 0 ? t.max.y : t.min.y),
              (Wu.z = i.normal.z > 0 ? t.max.z : t.min.z),
              i.distanceToPoint(Wu) < 0)
            )
              return !1
          }
          return !0
        }
        containsPoint(t) {
          const e = this.planes
          for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1
          return !0
        }
        clone() {
          return new this.constructor().copy(this)
        }
      }
      function qu() {
        let t = null,
          e = !1,
          n = null,
          i = null
        function r(e, s) {
          n(e, s), (i = t.requestAnimationFrame(r))
        }
        return {
          start: function () {
            !0 !== e &&
              null !== n &&
              ((i = t.requestAnimationFrame(r)), (e = !0))
          },
          stop: function () {
            t.cancelAnimationFrame(i), (e = !1)
          },
          setAnimationLoop: function (t) {
            n = t
          },
          setContext: function (e) {
            t = e
          },
        }
      }
      function Xu(t, e) {
        const n = e.isWebGL2,
          i = new WeakMap()
        return {
          get: function (t) {
            return t.isInterleavedBufferAttribute && (t = t.data), i.get(t)
          },
          remove: function (e) {
            e.isInterleavedBufferAttribute && (e = e.data)
            const n = i.get(e)
            n && (t.deleteBuffer(n.buffer), i.delete(e))
          },
          update: function (e, r) {
            if (e.isGLBufferAttribute) {
              const t = i.get(e)
              return void (
                (!t || t.version < e.version) &&
                i.set(e, {
                  buffer: e.buffer,
                  type: e.type,
                  bytesPerElement: e.elementSize,
                  version: e.version,
                })
              )
            }
            e.isInterleavedBufferAttribute && (e = e.data)
            const s = i.get(e)
            void 0 === s
              ? i.set(
                  e,
                  (function (e, i) {
                    const r = e.array,
                      s = e.usage,
                      o = t.createBuffer()
                    t.bindBuffer(i, o),
                      t.bufferData(i, r, s),
                      e.onUploadCallback()
                    let a = 5126
                    return (
                      r instanceof Float32Array
                        ? (a = 5126)
                        : r instanceof Float64Array
                        ? console.warn(
                            'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.',
                          )
                        : r instanceof Uint16Array
                        ? e.isFloat16BufferAttribute
                          ? n
                            ? (a = 5131)
                            : console.warn(
                                'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.',
                              )
                          : (a = 5123)
                        : r instanceof Int16Array
                        ? (a = 5122)
                        : r instanceof Uint32Array
                        ? (a = 5125)
                        : r instanceof Int32Array
                        ? (a = 5124)
                        : r instanceof Int8Array
                        ? (a = 5120)
                        : (r instanceof Uint8Array ||
                            r instanceof Uint8ClampedArray) &&
                          (a = 5121),
                      {
                        buffer: o,
                        type: a,
                        bytesPerElement: r.BYTES_PER_ELEMENT,
                        version: e.version,
                      }
                    )
                  })(e, r),
                )
              : s.version < e.version &&
                ((function (e, i, r) {
                  const s = i.array,
                    o = i.updateRange
                  t.bindBuffer(r, e),
                    -1 === o.count
                      ? t.bufferSubData(r, 0, s)
                      : (n
                          ? t.bufferSubData(
                              r,
                              o.offset * s.BYTES_PER_ELEMENT,
                              s,
                              o.offset,
                              o.count,
                            )
                          : t.bufferSubData(
                              r,
                              o.offset * s.BYTES_PER_ELEMENT,
                              s.subarray(o.offset, o.offset + o.count),
                            ),
                        (o.count = -1))
                })(s.buffer, e, r),
                (s.version = e.version))
          },
        }
      }
      class Yu extends lu {
        constructor(t = 1, e = 1, n = 1, i = 1) {
          super(),
            (this.type = 'PlaneGeometry'),
            (this.parameters = {
              width: t,
              height: e,
              widthSegments: n,
              heightSegments: i,
            })
          const r = t / 2,
            s = e / 2,
            o = Math.floor(n),
            a = Math.floor(i),
            l = o + 1,
            c = a + 1,
            u = t / o,
            h = e / a,
            d = [],
            p = [],
            f = [],
            m = []
          for (let t = 0; t < c; t++) {
            const e = t * h - s
            for (let n = 0; n < l; n++) {
              const i = n * u - r
              p.push(i, -e, 0),
                f.push(0, 0, 1),
                m.push(n / o),
                m.push(1 - t / a)
            }
          }
          for (let t = 0; t < a; t++)
            for (let e = 0; e < o; e++) {
              const n = e + l * t,
                i = e + l * (t + 1),
                r = e + 1 + l * (t + 1),
                s = e + 1 + l * t
              d.push(n, i, s), d.push(i, r, s)
            }
          this.setIndex(d),
            this.setAttribute('position', new tu(p, 3)),
            this.setAttribute('normal', new tu(f, 3)),
            this.setAttribute('uv', new tu(m, 2))
        }
        static fromJSON(t) {
          return new Yu(t.width, t.height, t.widthSegments, t.heightSegments)
        }
      }
      const Ju = {
          alphamap_fragment:
            '#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif',
          alphamap_pars_fragment:
            '#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
          alphatest_fragment:
            '#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif',
          alphatest_pars_fragment:
            '#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif',
          aomap_fragment:
            '#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif',
          aomap_pars_fragment:
            '#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif',
          begin_vertex: 'vec3 transformed = vec3( position );',
          beginnormal_vertex:
            'vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif',
          bsdfs:
            'vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenTint, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenTint * ( D * V );\n}\n#endif',
          bumpmap_pars_fragment:
            '#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif',
          clipping_planes_fragment:
            '#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif',
          clipping_planes_pars_fragment:
            '#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif',
          clipping_planes_pars_vertex:
            '#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif',
          clipping_planes_vertex:
            '#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif',
          color_fragment:
            '#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif',
          color_pars_fragment:
            '#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif',
          color_pars_vertex:
            '#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif',
          color_vertex:
            '#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif',
          common:
            '#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}',
          cube_uv_reflection_fragment:
            '#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif',
          defaultnormal_vertex:
            'vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif',
          displacementmap_pars_vertex:
            '#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif',
          displacementmap_vertex:
            '#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif',
          emissivemap_fragment:
            '#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif',
          emissivemap_pars_fragment:
            '#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif',
          encodings_fragment:
            'gl_FragColor = linearToOutputTexel( gl_FragColor );',
          encodings_pars_fragment:
            '\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}',
          envmap_fragment:
            '#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif',
          envmap_common_pars_fragment:
            '#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif',
          envmap_pars_fragment:
            '#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif',
          envmap_pars_vertex:
            '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif',
          envmap_physical_pars_fragment:
            '#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif',
          envmap_vertex:
            '#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif',
          fog_vertex: '#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif',
          fog_pars_vertex: '#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif',
          fog_fragment:
            '#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif',
          fog_pars_fragment:
            '#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif',
          gradientmap_pars_fragment:
            '#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}',
          lightmap_fragment:
            '#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif',
          lightmap_pars_fragment:
            '#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif',
          lights_lambert_vertex:
            'vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif',
          lights_pars_begin:
            'uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif',
          lights_toon_fragment:
            'ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;',
          lights_toon_pars_fragment:
            'varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)',
          lights_phong_fragment:
            'BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;',
          lights_phong_pars_fragment:
            'varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)',
          lights_physical_fragment:
            'PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularTintFactor = specularTint;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARTINTMAP\n\t\t\tspecularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularTintFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenTint = sheenTint;\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n#endif',
          lights_physical_pars_fragment:
            'struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenTint;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenTint, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}',
          lights_fragment_begin:
            '\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif',
          lights_fragment_maps:
            '#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif',
          lights_fragment_end:
            '#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif',
          logdepthbuf_fragment:
            '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif',
          logdepthbuf_pars_fragment:
            '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif',
          logdepthbuf_pars_vertex:
            '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif',
          logdepthbuf_vertex:
            '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif',
          map_fragment:
            '#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif',
          map_pars_fragment: '#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif',
          map_particle_fragment:
            '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif',
          map_particle_pars_fragment:
            '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
          metalnessmap_fragment:
            'float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif',
          metalnessmap_pars_fragment:
            '#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif',
          morphnormal_vertex:
            '#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif',
          morphtarget_pars_vertex:
            '#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif',
          morphtarget_vertex:
            '#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif',
          normal_fragment_begin:
            'float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;',
          normal_fragment_maps:
            '#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif',
          normal_pars_fragment:
            '#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif',
          normal_pars_vertex:
            '#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif',
          normal_vertex:
            '#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif',
          normalmap_pars_fragment:
            '#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif',
          clearcoat_normal_fragment_begin:
            '#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif',
          clearcoat_normal_fragment_maps:
            '#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif',
          clearcoat_pars_fragment:
            '#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif',
          output_fragment:
            '#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );',
          packing:
            'vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}',
          premultiplied_alpha_fragment:
            '#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif',
          project_vertex:
            'vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;',
          dithering_fragment:
            '#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif',
          dithering_pars_fragment:
            '#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif',
          roughnessmap_fragment:
            'float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif',
          roughnessmap_pars_fragment:
            '#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif',
          shadowmap_pars_fragment:
            '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif',
          shadowmap_pars_vertex:
            '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif',
          shadowmap_vertex:
            '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif',
          shadowmask_pars_fragment:
            'float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}',
          skinbase_vertex:
            '#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif',
          skinning_pars_vertex:
            '#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif',
          skinning_vertex:
            '#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif',
          skinnormal_vertex:
            '#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif',
          specularmap_fragment:
            'float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif',
          specularmap_pars_fragment:
            '#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif',
          tonemapping_fragment:
            '#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif',
          tonemapping_pars_fragment:
            '#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }',
          transmission_fragment:
            '#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationTint, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif',
          transmission_pars_fragment:
            '#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationTint;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif',
          uv_pars_fragment:
            '#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif',
          uv_pars_vertex:
            '#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif',
          uv_vertex:
            '#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif',
          uv2_pars_fragment:
            '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif',
          uv2_pars_vertex:
            '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif',
          uv2_vertex:
            '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif',
          worldpos_vertex:
            '#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif',
          background_vert:
            'varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}',
          background_frag:
            'uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
          cube_vert:
            'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}',
          cube_frag:
            '#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
          depth_vert:
            '#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}',
          depth_frag:
            '#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}',
          distanceRGBA_vert:
            '#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}',
          distanceRGBA_frag:
            '#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}',
          equirect_vert:
            'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}',
          equirect_frag:
            'uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
          linedashed_vert:
            'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}',
          linedashed_frag:
            'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}',
          meshbasic_vert:
            '#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}',
          meshbasic_frag:
            'uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
          meshlambert_vert:
            '#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
          meshlambert_frag:
            'uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
          meshmatcap_vert:
            '#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}',
          meshmatcap_frag:
            '#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
          meshnormal_vert:
            '#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}',
          meshnormal_frag:
            '#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}',
          meshphong_vert:
            '#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
          meshphong_frag:
            '#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
          meshphysical_vert:
            '#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}',
          meshphysical_frag:
            '#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularTint;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARTINTMAP\n\t\tuniform sampler2D specularTintMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenTint;\n\tuniform float sheenRoughness;\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
          meshtoon_vert:
            '#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
          meshtoon_frag:
            '#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
          points_vert:
            'uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}',
          points_frag:
            'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}',
          shadow_vert:
            '#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
          shadow_frag:
            'uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
          sprite_vert:
            'uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}',
          sprite_frag:
            'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
        },
        Zu = {
          common: {
            diffuse: { value: new Xc(16777215) },
            opacity: { value: 1 },
            map: { value: null },
            uvTransform: { value: new pl() },
            uv2Transform: { value: new pl() },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
          },
          specularmap: { specularMap: { value: null } },
          envmap: {
            envMap: { value: null },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            ior: { value: 1.5 },
            refractionRatio: { value: 0.98 },
            maxMipLevel: { value: 0 },
          },
          aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
          lightmap: {
            lightMap: { value: null },
            lightMapIntensity: { value: 1 },
          },
          emissivemap: { emissiveMap: { value: null } },
          bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
          normalmap: {
            normalMap: { value: null },
            normalScale: { value: new dl(1, 1) },
          },
          displacementmap: {
            displacementMap: { value: null },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
          },
          roughnessmap: { roughnessMap: { value: null } },
          metalnessmap: { metalnessMap: { value: null } },
          gradientmap: { gradientMap: { value: null } },
          fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new Xc(16777215) },
          },
          lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: {
              value: [],
              properties: { direction: {}, color: {} },
            },
            directionalLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
              },
            },
            spotLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            spotShadowMap: { value: [] },
            spotShadowMatrix: { value: [] },
            pointLights: {
              value: [],
              properties: { color: {}, position: {}, decay: {}, distance: {} },
            },
            pointLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {},
              },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
              value: [],
              properties: { direction: {}, skyColor: {}, groundColor: {} },
            },
            rectAreaLights: {
              value: [],
              properties: { color: {}, position: {}, width: {}, height: {} },
            },
            ltc_1: { value: null },
            ltc_2: { value: null },
          },
          points: {
            diffuse: { value: new Xc(16777215) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
            uvTransform: { value: new pl() },
          },
          sprite: {
            diffuse: { value: new Xc(16777215) },
            opacity: { value: 1 },
            center: { value: new dl(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
            uvTransform: { value: new pl() },
          },
        },
        Ku = {
          basic: {
            uniforms: Lu([
              Zu.common,
              Zu.specularmap,
              Zu.envmap,
              Zu.aomap,
              Zu.lightmap,
              Zu.fog,
            ]),
            vertexShader: Ju.meshbasic_vert,
            fragmentShader: Ju.meshbasic_frag,
          },
          lambert: {
            uniforms: Lu([
              Zu.common,
              Zu.specularmap,
              Zu.envmap,
              Zu.aomap,
              Zu.lightmap,
              Zu.emissivemap,
              Zu.fog,
              Zu.lights,
              { emissive: { value: new Xc(0) } },
            ]),
            vertexShader: Ju.meshlambert_vert,
            fragmentShader: Ju.meshlambert_frag,
          },
          phong: {
            uniforms: Lu([
              Zu.common,
              Zu.specularmap,
              Zu.envmap,
              Zu.aomap,
              Zu.lightmap,
              Zu.emissivemap,
              Zu.bumpmap,
              Zu.normalmap,
              Zu.displacementmap,
              Zu.fog,
              Zu.lights,
              {
                emissive: { value: new Xc(0) },
                specular: { value: new Xc(1118481) },
                shininess: { value: 30 },
              },
            ]),
            vertexShader: Ju.meshphong_vert,
            fragmentShader: Ju.meshphong_frag,
          },
          standard: {
            uniforms: Lu([
              Zu.common,
              Zu.envmap,
              Zu.aomap,
              Zu.lightmap,
              Zu.emissivemap,
              Zu.bumpmap,
              Zu.normalmap,
              Zu.displacementmap,
              Zu.roughnessmap,
              Zu.metalnessmap,
              Zu.fog,
              Zu.lights,
              {
                emissive: { value: new Xc(0) },
                roughness: { value: 1 },
                metalness: { value: 0 },
                envMapIntensity: { value: 1 },
              },
            ]),
            vertexShader: Ju.meshphysical_vert,
            fragmentShader: Ju.meshphysical_frag,
          },
          toon: {
            uniforms: Lu([
              Zu.common,
              Zu.aomap,
              Zu.lightmap,
              Zu.emissivemap,
              Zu.bumpmap,
              Zu.normalmap,
              Zu.displacementmap,
              Zu.gradientmap,
              Zu.fog,
              Zu.lights,
              { emissive: { value: new Xc(0) } },
            ]),
            vertexShader: Ju.meshtoon_vert,
            fragmentShader: Ju.meshtoon_frag,
          },
          matcap: {
            uniforms: Lu([
              Zu.common,
              Zu.bumpmap,
              Zu.normalmap,
              Zu.displacementmap,
              Zu.fog,
              { matcap: { value: null } },
            ]),
            vertexShader: Ju.meshmatcap_vert,
            fragmentShader: Ju.meshmatcap_frag,
          },
          points: {
            uniforms: Lu([Zu.points, Zu.fog]),
            vertexShader: Ju.points_vert,
            fragmentShader: Ju.points_frag,
          },
          dashed: {
            uniforms: Lu([
              Zu.common,
              Zu.fog,
              {
                scale: { value: 1 },
                dashSize: { value: 1 },
                totalSize: { value: 2 },
              },
            ]),
            vertexShader: Ju.linedashed_vert,
            fragmentShader: Ju.linedashed_frag,
          },
          depth: {
            uniforms: Lu([Zu.common, Zu.displacementmap]),
            vertexShader: Ju.depth_vert,
            fragmentShader: Ju.depth_frag,
          },
          normal: {
            uniforms: Lu([
              Zu.common,
              Zu.bumpmap,
              Zu.normalmap,
              Zu.displacementmap,
              { opacity: { value: 1 } },
            ]),
            vertexShader: Ju.meshnormal_vert,
            fragmentShader: Ju.meshnormal_frag,
          },
          sprite: {
            uniforms: Lu([Zu.sprite, Zu.fog]),
            vertexShader: Ju.sprite_vert,
            fragmentShader: Ju.sprite_frag,
          },
          background: {
            uniforms: {
              uvTransform: { value: new pl() },
              t2D: { value: null },
            },
            vertexShader: Ju.background_vert,
            fragmentShader: Ju.background_frag,
          },
          cube: {
            uniforms: Lu([Zu.envmap, { opacity: { value: 1 } }]),
            vertexShader: Ju.cube_vert,
            fragmentShader: Ju.cube_frag,
          },
          equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: Ju.equirect_vert,
            fragmentShader: Ju.equirect_frag,
          },
          distanceRGBA: {
            uniforms: Lu([
              Zu.common,
              Zu.displacementmap,
              {
                referencePosition: { value: new Tl() },
                nearDistance: { value: 1 },
                farDistance: { value: 1e3 },
              },
            ]),
            vertexShader: Ju.distanceRGBA_vert,
            fragmentShader: Ju.distanceRGBA_frag,
          },
          shadow: {
            uniforms: Lu([
              Zu.lights,
              Zu.fog,
              { color: { value: new Xc(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: Ju.shadow_vert,
            fragmentShader: Ju.shadow_frag,
          },
        }
      function Qu(t, e, n, i, r) {
        const s = new Xc(0)
        let o,
          a,
          l = 0,
          c = null,
          u = 0,
          h = null
        function d(t, e) {
          n.buffers.color.setClear(t.r, t.g, t.b, e, r)
        }
        return {
          getClearColor: function () {
            return s
          },
          setClearColor: function (t, e = 1) {
            s.set(t), (l = e), d(s, l)
          },
          getClearAlpha: function () {
            return l
          },
          setClearAlpha: function (t) {
            ;(l = t), d(s, l)
          },
          render: function (n, r) {
            let p = !1,
              f = !0 === r.isScene ? r.background : null
            f && f.isTexture && (f = e.get(f))
            const m = t.xr,
              g = m.getSession && m.getSession()
            g && 'additive' === g.environmentBlendMode && (f = null),
              null === f ? d(s, l) : f && f.isColor && (d(f, 1), (p = !0)),
              (t.autoClear || p) &&
                t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
              f && (f.isCubeTexture || f.mapping === ya)
                ? (void 0 === a &&
                    ((a = new Eu(
                      new Au(1, 1, 1),
                      new Pu({
                        name: 'BackgroundCubeMaterial',
                        uniforms: Cu(Ku.cube.uniforms),
                        vertexShader: Ku.cube.vertexShader,
                        fragmentShader: Ku.cube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                      }),
                    )),
                    a.geometry.deleteAttribute('normal'),
                    a.geometry.deleteAttribute('uv'),
                    (a.onBeforeRender = function (t, e, n) {
                      this.matrixWorld.copyPosition(n.matrixWorld)
                    }),
                    Object.defineProperty(a.material, 'envMap', {
                      get: function () {
                        return this.uniforms.envMap.value
                      },
                    }),
                    i.update(a)),
                  (a.material.uniforms.envMap.value = f),
                  (a.material.uniforms.flipEnvMap.value =
                    f.isCubeTexture && !1 === f.isRenderTargetTexture ? -1 : 1),
                  (c === f && u === f.version && h === t.toneMapping) ||
                    ((a.material.needsUpdate = !0),
                    (c = f),
                    (u = f.version),
                    (h = t.toneMapping)),
                  n.unshift(a, a.geometry, a.material, 0, 0, null))
                : f &&
                  f.isTexture &&
                  (void 0 === o &&
                    ((o = new Eu(
                      new Yu(2, 2),
                      new Pu({
                        name: 'BackgroundMaterial',
                        uniforms: Cu(Ku.background.uniforms),
                        vertexShader: Ku.background.vertexShader,
                        fragmentShader: Ku.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                      }),
                    )),
                    o.geometry.deleteAttribute('normal'),
                    Object.defineProperty(o.material, 'map', {
                      get: function () {
                        return this.uniforms.t2D.value
                      },
                    }),
                    i.update(o)),
                  (o.material.uniforms.t2D.value = f),
                  !0 === f.matrixAutoUpdate && f.updateMatrix(),
                  o.material.uniforms.uvTransform.value.copy(f.matrix),
                  (c === f && u === f.version && h === t.toneMapping) ||
                    ((o.material.needsUpdate = !0),
                    (c = f),
                    (u = f.version),
                    (h = t.toneMapping)),
                  n.unshift(o, o.geometry, o.material, 0, 0, null))
          },
        }
      }
      function $u(t, e, n, i) {
        const r = t.getParameter(34921),
          s = i.isWebGL2 ? null : e.get('OES_vertex_array_object'),
          o = i.isWebGL2 || null !== s,
          a = {},
          l = d(null)
        let c = l
        function u(e) {
          return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e)
        }
        function h(e) {
          return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e)
        }
        function d(t) {
          const e = [],
            n = [],
            i = []
          for (let t = 0; t < r; t++) (e[t] = 0), (n[t] = 0), (i[t] = 0)
          return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: e,
            enabledAttributes: n,
            attributeDivisors: i,
            object: t,
            attributes: {},
            index: null,
          }
        }
        function p() {
          const t = c.newAttributes
          for (let e = 0, n = t.length; e < n; e++) t[e] = 0
        }
        function f(t) {
          m(t, 0)
        }
        function m(n, r) {
          const s = c.newAttributes,
            o = c.enabledAttributes,
            a = c.attributeDivisors
          ;(s[n] = 1),
            0 === o[n] && (t.enableVertexAttribArray(n), (o[n] = 1)),
            a[n] !== r &&
              ((i.isWebGL2 ? t : e.get('ANGLE_instanced_arrays'))[
                i.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'
              ](n, r),
              (a[n] = r))
        }
        function g() {
          const e = c.newAttributes,
            n = c.enabledAttributes
          for (let i = 0, r = n.length; i < r; i++)
            n[i] !== e[i] && (t.disableVertexAttribArray(i), (n[i] = 0))
        }
        function v(e, n, r, s, o, a) {
          !0 !== i.isWebGL2 || (5124 !== r && 5125 !== r)
            ? t.vertexAttribPointer(e, n, r, s, o, a)
            : t.vertexAttribIPointer(e, n, r, o, a)
        }
        function _() {
          y(), c !== l && ((c = l), u(c.object))
        }
        function y() {
          ;(l.geometry = null), (l.program = null), (l.wireframe = !1)
        }
        return {
          setup: function (r, l, h, _, y) {
            let x = !1
            if (o) {
              const e = (function (e, n, r) {
                const o = !0 === r.wireframe
                let l = a[e.id]
                void 0 === l && ((l = {}), (a[e.id] = l))
                let c = l[n.id]
                void 0 === c && ((c = {}), (l[n.id] = c))
                let u = c[o]
                return (
                  void 0 === u &&
                    ((u = d(
                      i.isWebGL2
                        ? t.createVertexArray()
                        : s.createVertexArrayOES(),
                    )),
                    (c[o] = u)),
                  u
                )
              })(_, h, l)
              c !== e && ((c = e), u(c.object)),
                (x = (function (t, e) {
                  const n = c.attributes,
                    i = t.attributes
                  let r = 0
                  for (const t in i) {
                    const e = n[t],
                      s = i[t]
                    if (void 0 === e) return !0
                    if (e.attribute !== s) return !0
                    if (e.data !== s.data) return !0
                    r++
                  }
                  return c.attributesNum !== r || c.index !== e
                })(_, y)),
                x &&
                  (function (t, e) {
                    const n = {},
                      i = t.attributes
                    let r = 0
                    for (const t in i) {
                      const e = i[t],
                        s = {}
                      ;(s.attribute = e),
                        e.data && (s.data = e.data),
                        (n[t] = s),
                        r++
                    }
                    ;(c.attributes = n), (c.attributesNum = r), (c.index = e)
                  })(_, y)
            } else {
              const t = !0 === l.wireframe
              ;(c.geometry === _.id &&
                c.program === h.id &&
                c.wireframe === t) ||
                ((c.geometry = _.id),
                (c.program = h.id),
                (c.wireframe = t),
                (x = !0))
            }
            !0 === r.isInstancedMesh && (x = !0),
              null !== y && n.update(y, 34963),
              x &&
                ((function (r, s, o, a) {
                  if (
                    !1 === i.isWebGL2 &&
                    (r.isInstancedMesh || a.isInstancedBufferGeometry) &&
                    null === e.get('ANGLE_instanced_arrays')
                  )
                    return
                  p()
                  const l = a.attributes,
                    c = o.getAttributes(),
                    u = s.defaultAttributeValues
                  for (const e in c) {
                    const i = c[e]
                    if (i.location >= 0) {
                      let s = l[e]
                      if (
                        (void 0 === s &&
                          ('instanceMatrix' === e &&
                            r.instanceMatrix &&
                            (s = r.instanceMatrix),
                          'instanceColor' === e &&
                            r.instanceColor &&
                            (s = r.instanceColor)),
                        void 0 !== s)
                      ) {
                        const e = s.normalized,
                          o = s.itemSize,
                          l = n.get(s)
                        if (void 0 === l) continue
                        const c = l.buffer,
                          u = l.type,
                          h = l.bytesPerElement
                        if (s.isInterleavedBufferAttribute) {
                          const n = s.data,
                            l = n.stride,
                            d = s.offset
                          if (n && n.isInstancedInterleavedBuffer) {
                            for (let t = 0; t < i.locationSize; t++)
                              m(i.location + t, n.meshPerAttribute)
                            !0 !== r.isInstancedMesh &&
                              void 0 === a._maxInstanceCount &&
                              (a._maxInstanceCount =
                                n.meshPerAttribute * n.count)
                          } else
                            for (let t = 0; t < i.locationSize; t++)
                              f(i.location + t)
                          t.bindBuffer(34962, c)
                          for (let t = 0; t < i.locationSize; t++)
                            v(
                              i.location + t,
                              o / i.locationSize,
                              u,
                              e,
                              l * h,
                              (d + (o / i.locationSize) * t) * h,
                            )
                        } else {
                          if (s.isInstancedBufferAttribute) {
                            for (let t = 0; t < i.locationSize; t++)
                              m(i.location + t, s.meshPerAttribute)
                            !0 !== r.isInstancedMesh &&
                              void 0 === a._maxInstanceCount &&
                              (a._maxInstanceCount =
                                s.meshPerAttribute * s.count)
                          } else
                            for (let t = 0; t < i.locationSize; t++)
                              f(i.location + t)
                          t.bindBuffer(34962, c)
                          for (let t = 0; t < i.locationSize; t++)
                            v(
                              i.location + t,
                              o / i.locationSize,
                              u,
                              e,
                              o * h,
                              (o / i.locationSize) * t * h,
                            )
                        }
                      } else if (void 0 !== u) {
                        const n = u[e]
                        if (void 0 !== n)
                          switch (n.length) {
                            case 2:
                              t.vertexAttrib2fv(i.location, n)
                              break
                            case 3:
                              t.vertexAttrib3fv(i.location, n)
                              break
                            case 4:
                              t.vertexAttrib4fv(i.location, n)
                              break
                            default:
                              t.vertexAttrib1fv(i.location, n)
                          }
                      }
                    }
                  }
                  g()
                })(r, l, h, _),
                null !== y && t.bindBuffer(34963, n.get(y).buffer))
          },
          reset: _,
          resetDefaultState: y,
          dispose: function () {
            _()
            for (const t in a) {
              const e = a[t]
              for (const t in e) {
                const n = e[t]
                for (const t in n) h(n[t].object), delete n[t]
                delete e[t]
              }
              delete a[t]
            }
          },
          releaseStatesOfGeometry: function (t) {
            if (void 0 === a[t.id]) return
            const e = a[t.id]
            for (const t in e) {
              const n = e[t]
              for (const t in n) h(n[t].object), delete n[t]
              delete e[t]
            }
            delete a[t.id]
          },
          releaseStatesOfProgram: function (t) {
            for (const e in a) {
              const n = a[e]
              if (void 0 === n[t.id]) continue
              const i = n[t.id]
              for (const t in i) h(i[t].object), delete i[t]
              delete n[t.id]
            }
          },
          initAttributes: p,
          enableAttribute: f,
          disableUnusedAttributes: g,
        }
      }
      function th(t, e, n, i) {
        const r = i.isWebGL2
        let s
        ;(this.setMode = function (t) {
          s = t
        }),
          (this.render = function (e, i) {
            t.drawArrays(s, e, i), n.update(i, s, 1)
          }),
          (this.renderInstances = function (i, o, a) {
            if (0 === a) return
            let l, c
            if (r) (l = t), (c = 'drawArraysInstanced')
            else if (
              ((l = e.get('ANGLE_instanced_arrays')),
              (c = 'drawArraysInstancedANGLE'),
              null === l)
            )
              return void console.error(
                'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.',
              )
            l[c](s, i, o, a), n.update(o, s, a)
          })
      }
      function eh(t, e, n) {
        let i
        function r(e) {
          if ('highp' === e) {
            if (
              t.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
              t.getShaderPrecisionFormat(35632, 36338).precision > 0
            )
              return 'highp'
            e = 'mediump'
          }
          return 'mediump' === e &&
            t.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
            t.getShaderPrecisionFormat(35632, 36337).precision > 0
            ? 'mediump'
            : 'lowp'
        }
        const s =
          ('undefined' != typeof WebGL2RenderingContext &&
            t instanceof WebGL2RenderingContext) ||
          ('undefined' != typeof WebGL2ComputeRenderingContext &&
            t instanceof WebGL2ComputeRenderingContext)
        let o = void 0 !== n.precision ? n.precision : 'highp'
        const a = r(o)
        a !== o &&
          (console.warn(
            'THREE.WebGLRenderer:',
            o,
            'not supported, using',
            a,
            'instead.',
          ),
          (o = a))
        const l = s || e.has('WEBGL_draw_buffers'),
          c = !0 === n.logarithmicDepthBuffer,
          u = t.getParameter(34930),
          h = t.getParameter(35660),
          d = t.getParameter(3379),
          p = t.getParameter(34076),
          f = t.getParameter(34921),
          m = t.getParameter(36347),
          g = t.getParameter(36348),
          v = t.getParameter(36349),
          _ = h > 0,
          y = s || e.has('OES_texture_float')
        return {
          isWebGL2: s,
          drawBuffers: l,
          getMaxAnisotropy: function () {
            if (void 0 !== i) return i
            if (!0 === e.has('EXT_texture_filter_anisotropic')) {
              const n = e.get('EXT_texture_filter_anisotropic')
              i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
            } else i = 0
            return i
          },
          getMaxPrecision: r,
          precision: o,
          logarithmicDepthBuffer: c,
          maxTextures: u,
          maxVertexTextures: h,
          maxTextureSize: d,
          maxCubemapSize: p,
          maxAttributes: f,
          maxVertexUniforms: m,
          maxVaryings: g,
          maxFragmentUniforms: v,
          vertexTextures: _,
          floatFragmentTextures: y,
          floatVertexTextures: _ && y,
          maxSamples: s ? t.getParameter(36183) : 0,
        }
      }
      function nh(t) {
        const e = this
        let n = null,
          i = 0,
          r = !1,
          s = !1
        const o = new Gu(),
          a = new pl(),
          l = { value: null, needsUpdate: !1 }
        function c() {
          l.value !== n && ((l.value = n), (l.needsUpdate = i > 0)),
            (e.numPlanes = i),
            (e.numIntersection = 0)
        }
        function u(t, n, i, r) {
          const s = null !== t ? t.length : 0
          let c = null
          if (0 !== s) {
            if (((c = l.value), !0 !== r || null === c)) {
              const e = i + 4 * s,
                r = n.matrixWorldInverse
              a.getNormalMatrix(r),
                (null === c || c.length < e) && (c = new Float32Array(e))
              for (let e = 0, n = i; e !== s; ++e, n += 4)
                o.copy(t[e]).applyMatrix4(r, a),
                  o.normal.toArray(c, n),
                  (c[n + 3] = o.constant)
            }
            ;(l.value = c), (l.needsUpdate = !0)
          }
          return (e.numPlanes = s), (e.numIntersection = 0), c
        }
        ;(this.uniform = l),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (t, e, s) {
            const o = 0 !== t.length || e || 0 !== i || r
            return (r = e), (n = u(t, s, 0)), (i = t.length), o
          }),
          (this.beginShadows = function () {
            ;(s = !0), u(null)
          }),
          (this.endShadows = function () {
            ;(s = !1), c()
          }),
          (this.setState = function (e, o, a) {
            const h = e.clippingPlanes,
              d = e.clipIntersection,
              p = e.clipShadows,
              f = t.get(e)
            if (!r || null === h || 0 === h.length || (s && !p))
              s ? u(null) : c()
            else {
              const t = s ? 0 : i,
                e = 4 * t
              let r = f.clippingState || null
              ;(l.value = r), (r = u(h, o, e, a))
              for (let t = 0; t !== e; ++t) r[t] = n[t]
              ;(f.clippingState = r),
                (this.numIntersection = d ? this.numPlanes : 0),
                (this.numPlanes += t)
            }
          })
      }
      function ih(t) {
        let e = new WeakMap()
        function n(t, e) {
          return 303 === e ? (t.mapping = va) : 304 === e && (t.mapping = _a), t
        }
        function i(t) {
          const n = t.target
          n.removeEventListener('dispose', i)
          const r = e.get(n)
          void 0 !== r && (e.delete(n), r.dispose())
        }
        return {
          get: function (r) {
            if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
              const s = r.mapping
              if (303 === s || 304 === s) {
                if (e.has(r)) return n(e.get(r).texture, r.mapping)
                {
                  const s = r.image
                  if (s && s.height > 0) {
                    const o = t.getRenderTarget(),
                      a = new Bu(s.height / 2)
                    return (
                      a.fromEquirectangularTexture(t, r),
                      e.set(r, a),
                      t.setRenderTarget(o),
                      r.addEventListener('dispose', i),
                      n(a.texture, r.mapping)
                    )
                  }
                  return null
                }
              }
            }
            return r
          },
          dispose: function () {
            e = new WeakMap()
          },
        }
      }
      Ku.physical = {
        uniforms: Lu([
          Ku.standard.uniforms,
          {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatNormalScale: { value: new dl(1, 1) },
            clearcoatNormalMap: { value: null },
            sheen: { value: 0 },
            sheenTint: { value: new Xc(0) },
            sheenRoughness: { value: 0 },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionSamplerSize: { value: new dl() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            attenuationDistance: { value: 0 },
            attenuationTint: { value: new Xc(0) },
            specularIntensity: { value: 0 },
            specularIntensityMap: { value: null },
            specularTint: { value: new Xc(1, 1, 1) },
            specularTintMap: { value: null },
          },
        ]),
        vertexShader: Ju.meshphysical_vert,
        fragmentShader: Ju.meshphysical_frag,
      }
      class rh extends Fu {
        constructor(t = -1, e = 1, n = 1, i = -1, r = 0.1, s = 2e3) {
          super(),
            (this.type = 'OrthographicCamera'),
            (this.zoom = 1),
            (this.view = null),
            (this.left = t),
            (this.right = e),
            (this.top = n),
            (this.bottom = i),
            (this.near = r),
            (this.far = s),
            this.updateProjectionMatrix()
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            (this.left = t.left),
            (this.right = t.right),
            (this.top = t.top),
            (this.bottom = t.bottom),
            (this.near = t.near),
            (this.far = t.far),
            (this.zoom = t.zoom),
            (this.view = null === t.view ? null : Object.assign({}, t.view)),
            this
          )
        }
        setViewOffset(t, e, n, i, r, s) {
          null === this.view &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
            (this.view.enabled = !0),
            (this.view.fullWidth = t),
            (this.view.fullHeight = e),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = s),
            this.updateProjectionMatrix()
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        }
        updateProjectionMatrix() {
          const t = (this.right - this.left) / (2 * this.zoom),
            e = (this.top - this.bottom) / (2 * this.zoom),
            n = (this.right + this.left) / 2,
            i = (this.top + this.bottom) / 2
          let r = n - t,
            s = n + t,
            o = i + e,
            a = i - e
          if (null !== this.view && this.view.enabled) {
            const t =
                (this.right - this.left) / this.view.fullWidth / this.zoom,
              e = (this.top - this.bottom) / this.view.fullHeight / this.zoom
            ;(r += t * this.view.offsetX),
              (s = r + t * this.view.width),
              (o -= e * this.view.offsetY),
              (a = o - e * this.view.height)
          }
          this.projectionMatrix.makeOrthographic(
            r,
            s,
            o,
            a,
            this.near,
            this.far,
          ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        }
        toJSON(t) {
          const e = super.toJSON(t)
          return (
            (e.object.zoom = this.zoom),
            (e.object.left = this.left),
            (e.object.right = this.right),
            (e.object.top = this.top),
            (e.object.bottom = this.bottom),
            (e.object.near = this.near),
            (e.object.far = this.far),
            null !== this.view &&
              (e.object.view = Object.assign({}, this.view)),
            e
          )
        }
      }
      rh.prototype.isOrthographicCamera = !0
      class sh extends Pu {
        constructor(t) {
          super(t), (this.type = 'RawShaderMaterial')
        }
      }
      sh.prototype.isRawShaderMaterial = !0
      const oh = Math.pow(2, 8),
        ah = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
        lh = 5 + ah.length,
        ch = { [Wa]: 0, [ja]: 1, [Xa]: 2, 3004: 3, 3005: 4, 3006: 5, [qa]: 6 },
        uh = new rh(),
        { _lodPlanes: hh, _sizeLods: dh, _sigmas: ph } = bh(),
        fh = new Xc()
      let mh = null
      const gh = (1 + Math.sqrt(5)) / 2,
        vh = 1 / gh,
        _h = [
          new Tl(1, 1, 1),
          new Tl(-1, 1, 1),
          new Tl(1, 1, -1),
          new Tl(-1, 1, -1),
          new Tl(0, gh, vh),
          new Tl(0, gh, -vh),
          new Tl(vh, 0, gh),
          new Tl(-vh, 0, gh),
          new Tl(gh, vh, 0),
          new Tl(-gh, vh, 0),
        ]
      class yh {
        constructor(t) {
          ;(this._renderer = t),
            (this._pingPongRenderTarget = null),
            (this._blurMaterial = (function (t) {
              const e = new Float32Array(20),
                n = new Tl(0, 1, 0)
              return new sh({
                name: 'SphericalGaussianBlur',
                defines: { n: 20 },
                uniforms: {
                  envMap: { value: null },
                  samples: { value: 1 },
                  weights: { value: e },
                  latitudinal: { value: !1 },
                  dTheta: { value: 0 },
                  mipInt: { value: 0 },
                  poleAxis: { value: n },
                  inputEncoding: { value: ch[3e3] },
                  outputEncoding: { value: ch[3e3] },
                },
                vertexShader:
                  '\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t',
                fragmentShader:
                  "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1,
              })
            })()),
            (this._equirectShader = null),
            (this._cubemapShader = null),
            this._compileMaterial(this._blurMaterial)
        }
        fromScene(t, e = 0, n = 0.1, i = 100) {
          mh = this._renderer.getRenderTarget()
          const r = this._allocateTargets()
          return (
            this._sceneToCubeUV(t, n, i, r),
            e > 0 && this._blur(r, 0, 0, e),
            this._applyPMREM(r),
            this._cleanup(r),
            r
          )
        }
        fromEquirectangular(t) {
          return this._fromTexture(t)
        }
        fromCubemap(t) {
          return this._fromTexture(t)
        }
        compileCubemapShader() {
          null === this._cubemapShader &&
            ((this._cubemapShader = Th()),
            this._compileMaterial(this._cubemapShader))
        }
        compileEquirectangularShader() {
          null === this._equirectShader &&
            ((this._equirectShader = Sh()),
            this._compileMaterial(this._equirectShader))
        }
        dispose() {
          this._blurMaterial.dispose(),
            null !== this._cubemapShader && this._cubemapShader.dispose(),
            null !== this._equirectShader && this._equirectShader.dispose()
          for (let t = 0; t < hh.length; t++) hh[t].dispose()
        }
        _cleanup(t) {
          this._pingPongRenderTarget.dispose(),
            this._renderer.setRenderTarget(mh),
            (t.scissorTest = !1),
            Mh(t, 0, 0, t.width, t.height)
        }
        _fromTexture(t) {
          mh = this._renderer.getRenderTarget()
          const e = this._allocateTargets(t)
          return (
            this._textureToCubeUV(t, e),
            this._applyPMREM(e),
            this._cleanup(e),
            e
          )
        }
        _allocateTargets(t) {
          const e = {
              magFilter: Ma,
              minFilter: Ma,
              generateMipmaps: !1,
              type: Aa,
              format: 1023,
              encoding: xh(t) ? t.encoding : Xa,
              depthBuffer: !1,
            },
            n = wh(e)
          return (n.depthBuffer = !t), (this._pingPongRenderTarget = wh(e)), n
        }
        _compileMaterial(t) {
          const e = new Eu(hh[0], t)
          this._renderer.compile(e, uh)
        }
        _sceneToCubeUV(t, e, n, i) {
          const r = new Iu(90, 1, e, n),
            s = [1, -1, 1, 1, 1, 1],
            o = [1, 1, 1, -1, -1, -1],
            a = this._renderer,
            l = a.autoClear,
            c = a.outputEncoding,
            u = a.toneMapping
          a.getClearColor(fh),
            (a.toneMapping = 0),
            (a.outputEncoding = Wa),
            (a.autoClear = !1)
          const h = new Yc({
              name: 'PMREM.Background',
              side: 1,
              depthWrite: !1,
              depthTest: !1,
            }),
            d = new Eu(new Au(), h)
          let p = !1
          const f = t.background
          f
            ? f.isColor && (h.color.copy(f), (t.background = null), (p = !0))
            : (h.color.copy(fh), (p = !0))
          for (let e = 0; e < 6; e++) {
            const n = e % 3
            0 == n
              ? (r.up.set(0, s[e], 0), r.lookAt(o[e], 0, 0))
              : 1 == n
              ? (r.up.set(0, 0, s[e]), r.lookAt(0, o[e], 0))
              : (r.up.set(0, s[e], 0), r.lookAt(0, 0, o[e])),
              Mh(i, n * oh, e > 2 ? oh : 0, oh, oh),
              a.setRenderTarget(i),
              p && a.render(d, r),
              a.render(t, r)
          }
          d.geometry.dispose(),
            d.material.dispose(),
            (a.toneMapping = u),
            (a.outputEncoding = c),
            (a.autoClear = l),
            (t.background = f)
        }
        _setEncoding(t, e) {
          !0 === this._renderer.capabilities.isWebGL2 &&
          e.format === Oa &&
          e.type === Aa &&
          e.encoding === ja
            ? (t.value = ch[3e3])
            : (t.value = ch[e.encoding])
        }
        _textureToCubeUV(t, e) {
          const n = this._renderer
          t.isCubeTexture
            ? null == this._cubemapShader && (this._cubemapShader = Th())
            : null == this._equirectShader && (this._equirectShader = Sh())
          const i = t.isCubeTexture
              ? this._cubemapShader
              : this._equirectShader,
            r = new Eu(hh[0], i),
            s = i.uniforms
          ;(s.envMap.value = t),
            t.isCubeTexture ||
              s.texelSize.value.set(1 / t.image.width, 1 / t.image.height),
            this._setEncoding(s.inputEncoding, t),
            this._setEncoding(s.outputEncoding, e.texture),
            Mh(e, 0, 0, 3 * oh, 2 * oh),
            n.setRenderTarget(e),
            n.render(r, uh)
        }
        _applyPMREM(t) {
          const e = this._renderer,
            n = e.autoClear
          e.autoClear = !1
          for (let e = 1; e < lh; e++) {
            const n = Math.sqrt(ph[e] * ph[e] - ph[e - 1] * ph[e - 1]),
              i = _h[(e - 1) % _h.length]
            this._blur(t, e - 1, e, n, i)
          }
          e.autoClear = n
        }
        _blur(t, e, n, i, r) {
          const s = this._pingPongRenderTarget
          this._halfBlur(t, s, e, n, i, 'latitudinal', r),
            this._halfBlur(s, t, n, n, i, 'longitudinal', r)
        }
        _halfBlur(t, e, n, i, r, s, o) {
          const a = this._renderer,
            l = this._blurMaterial
          'latitudinal' !== s &&
            'longitudinal' !== s &&
            console.error(
              'blur direction must be either latitudinal or longitudinal!',
            )
          const c = new Eu(hh[i], l),
            u = l.uniforms,
            h = dh[n] - 1,
            d = isFinite(r) ? Math.PI / (2 * h) : (2 * Math.PI) / 39,
            p = r / d,
            f = isFinite(r) ? 1 + Math.floor(3 * p) : 20
          f > 20 &&
            console.warn(
              `sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`,
            )
          const m = []
          let g = 0
          for (let t = 0; t < 20; ++t) {
            const e = t / p,
              n = Math.exp((-e * e) / 2)
            m.push(n), 0 == t ? (g += n) : t < f && (g += 2 * n)
          }
          for (let t = 0; t < m.length; t++) m[t] = m[t] / g
          ;(u.envMap.value = t.texture),
            (u.samples.value = f),
            (u.weights.value = m),
            (u.latitudinal.value = 'latitudinal' === s),
            o && (u.poleAxis.value = o),
            (u.dTheta.value = d),
            (u.mipInt.value = 8 - n),
            this._setEncoding(u.inputEncoding, t.texture),
            this._setEncoding(u.outputEncoding, t.texture)
          const v = dh[i]
          Mh(
            e,
            3 * Math.max(0, oh - 2 * v),
            (0 === i ? 0 : 2 * oh) + 2 * v * (i > 4 ? i - 8 + 4 : 0),
            3 * v,
            2 * v,
          ),
            a.setRenderTarget(e),
            a.render(c, uh)
        }
      }
      function xh(t) {
        return (
          void 0 !== t &&
          t.type === Aa &&
          (t.encoding === Wa || t.encoding === ja || t.encoding === qa)
        )
      }
      function bh() {
        const t = [],
          e = [],
          n = []
        let i = 8
        for (let r = 0; r < lh; r++) {
          const s = Math.pow(2, i)
          e.push(s)
          let o = 1 / s
          r > 4 ? (o = ah[r - 8 + 4 - 1]) : 0 == r && (o = 0), n.push(o)
          const a = 1 / (s - 1),
            l = -a / 2,
            c = 1 + a / 2,
            u = [l, l, c, l, c, c, l, l, c, c, l, c],
            h = 6,
            d = 6,
            p = 3,
            f = 2,
            m = 1,
            g = new Float32Array(p * d * h),
            v = new Float32Array(f * d * h),
            _ = new Float32Array(m * d * h)
          for (let t = 0; t < h; t++) {
            const e = ((t % 3) * 2) / 3 - 1,
              n = t > 2 ? 0 : -1,
              i = [
                e,
                n,
                0,
                e + 2 / 3,
                n,
                0,
                e + 2 / 3,
                n + 1,
                0,
                e,
                n,
                0,
                e + 2 / 3,
                n + 1,
                0,
                e,
                n + 1,
                0,
              ]
            g.set(i, p * d * t), v.set(u, f * d * t)
            const r = [t, t, t, t, t, t]
            _.set(r, m * d * t)
          }
          const y = new lu()
          y.setAttribute('position', new Kc(g, p)),
            y.setAttribute('uv', new Kc(v, f)),
            y.setAttribute('faceIndex', new Kc(_, m)),
            t.push(y),
            i > 4 && i--
        }
        return { _lodPlanes: t, _sizeLods: e, _sigmas: n }
      }
      function wh(t) {
        const e = new wl(3 * oh, 3 * oh, t)
        return (
          (e.texture.mapping = ya),
          (e.texture.name = 'PMREM.cubeUv'),
          (e.scissorTest = !0),
          e
        )
      }
      function Mh(t, e, n, i, r) {
        t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r)
      }
      function Sh() {
        const t = new dl(1, 1)
        return new sh({
          name: 'EquirectangularToCubeUV',
          uniforms: {
            envMap: { value: null },
            texelSize: { value: t },
            inputEncoding: { value: ch[3e3] },
            outputEncoding: { value: ch[3e3] },
          },
          vertexShader:
            '\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t',
          fragmentShader:
            '\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t',
          blending: 0,
          depthTest: !1,
          depthWrite: !1,
        })
      }
      function Th() {
        return new sh({
          name: 'CubemapToCubeUV',
          uniforms: {
            envMap: { value: null },
            inputEncoding: { value: ch[3e3] },
            outputEncoding: { value: ch[3e3] },
          },
          vertexShader:
            '\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t',
          fragmentShader:
            '\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t',
          blending: 0,
          depthTest: !1,
          depthWrite: !1,
        })
      }
      function Eh(t) {
        let e = new WeakMap(),
          n = null
        function i(t) {
          const n = t.target
          n.removeEventListener('dispose', i)
          const r = e.get(n)
          void 0 !== r && (e.delete(n), r.dispose())
        }
        return {
          get: function (r) {
            if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
              const s = r.mapping,
                o = 303 === s || 304 === s,
                a = s === va || s === _a
              if (o || a) {
                if (e.has(r)) return e.get(r).texture
                {
                  const s = r.image
                  if (
                    (o && s && s.height > 0) ||
                    (a &&
                      s &&
                      (function (t) {
                        let e = 0
                        for (let n = 0; n < 6; n++) void 0 !== t[n] && e++
                        return 6 === e
                      })(s))
                  ) {
                    const s = t.getRenderTarget()
                    null === n && (n = new yh(t))
                    const a = o ? n.fromEquirectangular(r) : n.fromCubemap(r)
                    return (
                      e.set(r, a),
                      t.setRenderTarget(s),
                      r.addEventListener('dispose', i),
                      a.texture
                    )
                  }
                  return null
                }
              }
            }
            return r
          },
          dispose: function () {
            ;(e = new WeakMap()), null !== n && (n.dispose(), (n = null))
          },
        }
      }
      function Dh(t) {
        const e = {}
        function n(n) {
          if (void 0 !== e[n]) return e[n]
          let i
          switch (n) {
            case 'WEBGL_depth_texture':
              i =
                t.getExtension('WEBGL_depth_texture') ||
                t.getExtension('MOZ_WEBGL_depth_texture') ||
                t.getExtension('WEBKIT_WEBGL_depth_texture')
              break
            case 'EXT_texture_filter_anisotropic':
              i =
                t.getExtension('EXT_texture_filter_anisotropic') ||
                t.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
                t.getExtension('WEBKIT_EXT_texture_filter_anisotropic')
              break
            case 'WEBGL_compressed_texture_s3tc':
              i =
                t.getExtension('WEBGL_compressed_texture_s3tc') ||
                t.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
                t.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc')
              break
            case 'WEBGL_compressed_texture_pvrtc':
              i =
                t.getExtension('WEBGL_compressed_texture_pvrtc') ||
                t.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc')
              break
            default:
              i = t.getExtension(n)
          }
          return (e[n] = i), i
        }
        return {
          has: function (t) {
            return null !== n(t)
          },
          init: function (t) {
            t.isWebGL2
              ? n('EXT_color_buffer_float')
              : (n('WEBGL_depth_texture'),
                n('OES_texture_float'),
                n('OES_texture_half_float'),
                n('OES_texture_half_float_linear'),
                n('OES_standard_derivatives'),
                n('OES_element_index_uint'),
                n('OES_vertex_array_object'),
                n('ANGLE_instanced_arrays')),
              n('OES_texture_float_linear'),
              n('EXT_color_buffer_half_float')
          },
          get: function (t) {
            const e = n(t)
            return (
              null === e &&
                console.warn(
                  'THREE.WebGLRenderer: ' + t + ' extension not supported.',
                ),
              e
            )
          },
        }
      }
      function Ah(t, e, n, i) {
        const r = {},
          s = new WeakMap()
        function o(t) {
          const a = t.target
          null !== a.index && e.remove(a.index)
          for (const t in a.attributes) e.remove(a.attributes[t])
          a.removeEventListener('dispose', o), delete r[a.id]
          const l = s.get(a)
          l && (e.remove(l), s.delete(a)),
            i.releaseStatesOfGeometry(a),
            !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount,
            n.memory.geometries--
        }
        function a(t) {
          const n = [],
            i = t.index,
            r = t.attributes.position
          let o = 0
          if (null !== i) {
            const t = i.array
            o = i.version
            for (let e = 0, i = t.length; e < i; e += 3) {
              const i = t[e + 0],
                r = t[e + 1],
                s = t[e + 2]
              n.push(i, r, r, s, s, i)
            }
          } else {
            const t = r.array
            o = r.version
            for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
              const t = e + 0,
                i = e + 1,
                r = e + 2
              n.push(t, i, i, r, r, t)
            }
          }
          const a = new (fl(n) > 65535 ? $c : Qc)(n, 1)
          a.version = o
          const l = s.get(t)
          l && e.remove(l), s.set(t, a)
        }
        return {
          get: function (t, e) {
            return (
              !0 === r[e.id] ||
                (e.addEventListener('dispose', o),
                (r[e.id] = !0),
                n.memory.geometries++),
              e
            )
          },
          update: function (t) {
            const n = t.attributes
            for (const t in n) e.update(n[t], 34962)
            const i = t.morphAttributes
            for (const t in i) {
              const n = i[t]
              for (let t = 0, i = n.length; t < i; t++) e.update(n[t], 34962)
            }
          },
          getWireframeAttribute: function (t) {
            const e = s.get(t)
            if (e) {
              const n = t.index
              null !== n && e.version < n.version && a(t)
            } else a(t)
            return s.get(t)
          },
        }
      }
      function Ch(t, e, n, i) {
        const r = i.isWebGL2
        let s, o, a
        ;(this.setMode = function (t) {
          s = t
        }),
          (this.setIndex = function (t) {
            ;(o = t.type), (a = t.bytesPerElement)
          }),
          (this.render = function (e, i) {
            t.drawElements(s, i, o, e * a), n.update(i, s, 1)
          }),
          (this.renderInstances = function (i, l, c) {
            if (0 === c) return
            let u, h
            if (r) (u = t), (h = 'drawElementsInstanced')
            else if (
              ((u = e.get('ANGLE_instanced_arrays')),
              (h = 'drawElementsInstancedANGLE'),
              null === u)
            )
              return void console.error(
                'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.',
              )
            u[h](s, l, o, i * a, c), n.update(l, s, c)
          })
      }
      function Lh(t) {
        const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }
        return {
          memory: { geometries: 0, textures: 0 },
          render: e,
          programs: null,
          autoReset: !0,
          reset: function () {
            e.frame++,
              (e.calls = 0),
              (e.triangles = 0),
              (e.points = 0),
              (e.lines = 0)
          },
          update: function (t, n, i) {
            switch ((e.calls++, n)) {
              case 4:
                e.triangles += i * (t / 3)
                break
              case 1:
                e.lines += i * (t / 2)
                break
              case 3:
                e.lines += i * (t - 1)
                break
              case 2:
                e.lines += i * t
                break
              case 0:
                e.points += i * t
                break
              default:
                console.error('THREE.WebGLInfo: Unknown draw mode:', n)
            }
          },
        }
      }
      class Rh extends yl {
        constructor(t = null, e = 1, n = 1, i = 1) {
          super(null),
            (this.image = { data: t, width: e, height: n, depth: i }),
            (this.magFilter = Ma),
            (this.minFilter = Ma),
            (this.wrapR = ba),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1),
            (this.needsUpdate = !0)
        }
      }
      function Ph(t, e) {
        return t[0] - e[0]
      }
      function Fh(t, e) {
        return Math.abs(e[1]) - Math.abs(t[1])
      }
      function Ih(t, e) {
        let n = 1
        const i = e.isInterleavedBufferAttribute ? e.data.array : e.array
        i instanceof Int8Array
          ? (n = 127)
          : i instanceof Int16Array
          ? (n = 32767)
          : i instanceof Int32Array
          ? (n = 2147483647)
          : console.error(
              'THREE.WebGLMorphtargets: Unsupported morph attribute data type: ',
              i,
            ),
          t.divideScalar(n)
      }
      function Oh(t, e, n) {
        const i = {},
          r = new Float32Array(8),
          s = new WeakMap(),
          o = new Tl(),
          a = []
        for (let t = 0; t < 8; t++) a[t] = [t, 0]
        return {
          update: function (l, c, u, h) {
            const d = l.morphTargetInfluences
            if (!0 === e.isWebGL2) {
              const i = c.morphAttributes.position.length
              let r = s.get(c)
              if (void 0 === r || r.count !== i) {
                void 0 !== r && r.texture.dispose()
                const t = void 0 !== c.morphAttributes.normal,
                  n = c.morphAttributes.position,
                  a = c.morphAttributes.normal || [],
                  l = !0 === t ? 2 : 1
                let u = c.attributes.position.count * l,
                  h = 1
                u > e.maxTextureSize &&
                  ((h = Math.ceil(u / e.maxTextureSize)),
                  (u = e.maxTextureSize))
                const d = new Float32Array(u * h * 4 * i),
                  p = new Rh(d, u, h, i)
                ;(p.format = Oa), (p.type = Ra)
                const f = 4 * l
                for (let e = 0; e < i; e++) {
                  const i = n[e],
                    r = a[e],
                    s = u * h * 4 * e
                  for (let e = 0; e < i.count; e++) {
                    o.fromBufferAttribute(i, e), !0 === i.normalized && Ih(o, i)
                    const n = e * f
                    ;(d[s + n + 0] = o.x),
                      (d[s + n + 1] = o.y),
                      (d[s + n + 2] = o.z),
                      (d[s + n + 3] = 0),
                      !0 === t &&
                        (o.fromBufferAttribute(r, e),
                        !0 === r.normalized && Ih(o, r),
                        (d[s + n + 4] = o.x),
                        (d[s + n + 5] = o.y),
                        (d[s + n + 6] = o.z),
                        (d[s + n + 7] = 0))
                  }
                }
                ;(r = { count: i, texture: p, size: new dl(u, h) }), s.set(c, r)
              }
              let a = 0
              for (let t = 0; t < d.length; t++) a += d[t]
              const l = c.morphTargetsRelative ? 1 : 1 - a
              h.getUniforms().setValue(t, 'morphTargetBaseInfluence', l),
                h.getUniforms().setValue(t, 'morphTargetInfluences', d),
                h
                  .getUniforms()
                  .setValue(t, 'morphTargetsTexture', r.texture, n),
                h.getUniforms().setValue(t, 'morphTargetsTextureSize', r.size)
            } else {
              const e = void 0 === d ? 0 : d.length
              let n = i[c.id]
              if (void 0 === n || n.length !== e) {
                n = []
                for (let t = 0; t < e; t++) n[t] = [t, 0]
                i[c.id] = n
              }
              for (let t = 0; t < e; t++) {
                const e = n[t]
                ;(e[0] = t), (e[1] = d[t])
              }
              n.sort(Fh)
              for (let t = 0; t < 8; t++)
                t < e && n[t][1]
                  ? ((a[t][0] = n[t][0]), (a[t][1] = n[t][1]))
                  : ((a[t][0] = Number.MAX_SAFE_INTEGER), (a[t][1] = 0))
              a.sort(Ph)
              const s = c.morphAttributes.position,
                o = c.morphAttributes.normal
              let l = 0
              for (let t = 0; t < 8; t++) {
                const e = a[t],
                  n = e[0],
                  i = e[1]
                n !== Number.MAX_SAFE_INTEGER && i
                  ? (s &&
                      c.getAttribute('morphTarget' + t) !== s[n] &&
                      c.setAttribute('morphTarget' + t, s[n]),
                    o &&
                      c.getAttribute('morphNormal' + t) !== o[n] &&
                      c.setAttribute('morphNormal' + t, o[n]),
                    (r[t] = i),
                    (l += i))
                  : (s &&
                      !0 === c.hasAttribute('morphTarget' + t) &&
                      c.deleteAttribute('morphTarget' + t),
                    o &&
                      !0 === c.hasAttribute('morphNormal' + t) &&
                      c.deleteAttribute('morphNormal' + t),
                    (r[t] = 0))
              }
              const u = c.morphTargetsRelative ? 1 : 1 - l
              h.getUniforms().setValue(t, 'morphTargetBaseInfluence', u),
                h.getUniforms().setValue(t, 'morphTargetInfluences', r)
            }
          },
        }
      }
      function Nh(t, e, n, i) {
        let r = new WeakMap()
        function s(t) {
          const e = t.target
          e.removeEventListener('dispose', s),
            n.remove(e.instanceMatrix),
            null !== e.instanceColor && n.remove(e.instanceColor)
        }
        return {
          update: function (t) {
            const o = i.render.frame,
              a = t.geometry,
              l = e.get(t, a)
            return (
              r.get(l) !== o && (e.update(l), r.set(l, o)),
              t.isInstancedMesh &&
                (!1 === t.hasEventListener('dispose', s) &&
                  t.addEventListener('dispose', s),
                n.update(t.instanceMatrix, 34962),
                null !== t.instanceColor && n.update(t.instanceColor, 34962)),
              l
            )
          },
          dispose: function () {
            r = new WeakMap()
          },
        }
      }
      Rh.prototype.isDataTexture2DArray = !0
      class kh extends yl {
        constructor(t = null, e = 1, n = 1, i = 1) {
          super(null),
            (this.image = { data: t, width: e, height: n, depth: i }),
            (this.magFilter = Ma),
            (this.minFilter = Ma),
            (this.wrapR = ba),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1),
            (this.needsUpdate = !0)
        }
      }
      kh.prototype.isDataTexture3D = !0
      const Bh = new yl(),
        zh = new Rh(),
        Uh = new kh(),
        Hh = new ku(),
        Gh = [],
        Vh = [],
        Wh = new Float32Array(16),
        jh = new Float32Array(9),
        qh = new Float32Array(4)
      function Xh(t, e, n) {
        const i = t[0]
        if (i <= 0 || i > 0) return t
        const r = e * n
        let s = Gh[r]
        if (
          (void 0 === s && ((s = new Float32Array(r)), (Gh[r] = s)), 0 !== e)
        ) {
          i.toArray(s, 0)
          for (let i = 1, r = 0; i !== e; ++i) (r += n), t[i].toArray(s, r)
        }
        return s
      }
      function Yh(t, e) {
        if (t.length !== e.length) return !1
        for (let n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1
        return !0
      }
      function Jh(t, e) {
        for (let n = 0, i = e.length; n < i; n++) t[n] = e[n]
      }
      function Zh(t, e) {
        let n = Vh[e]
        void 0 === n && ((n = new Int32Array(e)), (Vh[e] = n))
        for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit()
        return n
      }
      function Kh(t, e) {
        const n = this.cache
        n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e))
      }
      function Qh(t, e) {
        const n = this.cache
        if (void 0 !== e.x)
          (n[0] === e.x && n[1] === e.y) ||
            (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y))
        else {
          if (Yh(n, e)) return
          t.uniform2fv(this.addr, e), Jh(n, e)
        }
      }
      function $h(t, e) {
        const n = this.cache
        if (void 0 !== e.x)
          (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
            (t.uniform3f(this.addr, e.x, e.y, e.z),
            (n[0] = e.x),
            (n[1] = e.y),
            (n[2] = e.z))
        else if (void 0 !== e.r)
          (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
            (t.uniform3f(this.addr, e.r, e.g, e.b),
            (n[0] = e.r),
            (n[1] = e.g),
            (n[2] = e.b))
        else {
          if (Yh(n, e)) return
          t.uniform3fv(this.addr, e), Jh(n, e)
        }
      }
      function td(t, e) {
        const n = this.cache
        if (void 0 !== e.x)
          (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
            (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
            (n[0] = e.x),
            (n[1] = e.y),
            (n[2] = e.z),
            (n[3] = e.w))
        else {
          if (Yh(n, e)) return
          t.uniform4fv(this.addr, e), Jh(n, e)
        }
      }
      function ed(t, e) {
        const n = this.cache,
          i = e.elements
        if (void 0 === i) {
          if (Yh(n, e)) return
          t.uniformMatrix2fv(this.addr, !1, e), Jh(n, e)
        } else {
          if (Yh(n, i)) return
          qh.set(i), t.uniformMatrix2fv(this.addr, !1, qh), Jh(n, i)
        }
      }
      function nd(t, e) {
        const n = this.cache,
          i = e.elements
        if (void 0 === i) {
          if (Yh(n, e)) return
          t.uniformMatrix3fv(this.addr, !1, e), Jh(n, e)
        } else {
          if (Yh(n, i)) return
          jh.set(i), t.uniformMatrix3fv(this.addr, !1, jh), Jh(n, i)
        }
      }
      function id(t, e) {
        const n = this.cache,
          i = e.elements
        if (void 0 === i) {
          if (Yh(n, e)) return
          t.uniformMatrix4fv(this.addr, !1, e), Jh(n, e)
        } else {
          if (Yh(n, i)) return
          Wh.set(i), t.uniformMatrix4fv(this.addr, !1, Wh), Jh(n, i)
        }
      }
      function rd(t, e) {
        const n = this.cache
        n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e))
      }
      function sd(t, e) {
        const n = this.cache
        Yh(n, e) || (t.uniform2iv(this.addr, e), Jh(n, e))
      }
      function od(t, e) {
        const n = this.cache
        Yh(n, e) || (t.uniform3iv(this.addr, e), Jh(n, e))
      }
      function ad(t, e) {
        const n = this.cache
        Yh(n, e) || (t.uniform4iv(this.addr, e), Jh(n, e))
      }
      function ld(t, e) {
        const n = this.cache
        n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e))
      }
      function cd(t, e) {
        const n = this.cache
        Yh(n, e) || (t.uniform2uiv(this.addr, e), Jh(n, e))
      }
      function ud(t, e) {
        const n = this.cache
        Yh(n, e) || (t.uniform3uiv(this.addr, e), Jh(n, e))
      }
      function hd(t, e) {
        const n = this.cache
        Yh(n, e) || (t.uniform4uiv(this.addr, e), Jh(n, e))
      }
      function dd(t, e, n) {
        const i = this.cache,
          r = n.allocateTextureUnit()
        i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
          n.safeSetTexture2D(e || Bh, r)
      }
      function pd(t, e, n) {
        const i = this.cache,
          r = n.allocateTextureUnit()
        i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
          n.setTexture3D(e || Uh, r)
      }
      function fd(t, e, n) {
        const i = this.cache,
          r = n.allocateTextureUnit()
        i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
          n.safeSetTextureCube(e || Hh, r)
      }
      function md(t, e, n) {
        const i = this.cache,
          r = n.allocateTextureUnit()
        i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
          n.setTexture2DArray(e || zh, r)
      }
      function gd(t, e) {
        t.uniform1fv(this.addr, e)
      }
      function vd(t, e) {
        const n = Xh(e, this.size, 2)
        t.uniform2fv(this.addr, n)
      }
      function _d(t, e) {
        const n = Xh(e, this.size, 3)
        t.uniform3fv(this.addr, n)
      }
      function yd(t, e) {
        const n = Xh(e, this.size, 4)
        t.uniform4fv(this.addr, n)
      }
      function xd(t, e) {
        const n = Xh(e, this.size, 4)
        t.uniformMatrix2fv(this.addr, !1, n)
      }
      function bd(t, e) {
        const n = Xh(e, this.size, 9)
        t.uniformMatrix3fv(this.addr, !1, n)
      }
      function wd(t, e) {
        const n = Xh(e, this.size, 16)
        t.uniformMatrix4fv(this.addr, !1, n)
      }
      function Md(t, e) {
        t.uniform1iv(this.addr, e)
      }
      function Sd(t, e) {
        t.uniform2iv(this.addr, e)
      }
      function Td(t, e) {
        t.uniform3iv(this.addr, e)
      }
      function Ed(t, e) {
        t.uniform4iv(this.addr, e)
      }
      function Dd(t, e) {
        t.uniform1uiv(this.addr, e)
      }
      function Ad(t, e) {
        t.uniform2uiv(this.addr, e)
      }
      function Cd(t, e) {
        t.uniform3uiv(this.addr, e)
      }
      function Ld(t, e) {
        t.uniform4uiv(this.addr, e)
      }
      function Rd(t, e, n) {
        const i = e.length,
          r = Zh(n, i)
        t.uniform1iv(this.addr, r)
        for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || Bh, r[t])
      }
      function Pd(t, e, n) {
        const i = e.length,
          r = Zh(n, i)
        t.uniform1iv(this.addr, r)
        for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || Hh, r[t])
      }
      function Fd(t, e, n) {
        ;(this.id = t),
          (this.addr = n),
          (this.cache = []),
          (this.setValue = (function (t) {
            switch (t) {
              case 5126:
                return Kh
              case 35664:
                return Qh
              case 35665:
                return $h
              case 35666:
                return td
              case 35674:
                return ed
              case 35675:
                return nd
              case 35676:
                return id
              case 5124:
              case 35670:
                return rd
              case 35667:
              case 35671:
                return sd
              case 35668:
              case 35672:
                return od
              case 35669:
              case 35673:
                return ad
              case 5125:
                return ld
              case 36294:
                return cd
              case 36295:
                return ud
              case 36296:
                return hd
              case 35678:
              case 36198:
              case 36298:
              case 36306:
              case 35682:
                return dd
              case 35679:
              case 36299:
              case 36307:
                return pd
              case 35680:
              case 36300:
              case 36308:
              case 36293:
                return fd
              case 36289:
              case 36303:
              case 36311:
              case 36292:
                return md
            }
          })(e.type))
      }
      function Id(t, e, n) {
        ;(this.id = t),
          (this.addr = n),
          (this.cache = []),
          (this.size = e.size),
          (this.setValue = (function (t) {
            switch (t) {
              case 5126:
                return gd
              case 35664:
                return vd
              case 35665:
                return _d
              case 35666:
                return yd
              case 35674:
                return xd
              case 35675:
                return bd
              case 35676:
                return wd
              case 5124:
              case 35670:
                return Md
              case 35667:
              case 35671:
                return Sd
              case 35668:
              case 35672:
                return Td
              case 35669:
              case 35673:
                return Ed
              case 5125:
                return Dd
              case 36294:
                return Ad
              case 36295:
                return Cd
              case 36296:
                return Ld
              case 35678:
              case 36198:
              case 36298:
              case 36306:
              case 35682:
                return Rd
              case 35680:
              case 36300:
              case 36308:
              case 36293:
                return Pd
            }
          })(e.type))
      }
      function Od(t) {
        ;(this.id = t), (this.seq = []), (this.map = {})
      }
      ;(Id.prototype.updateCache = function (t) {
        const e = this.cache
        t instanceof Float32Array &&
          e.length !== t.length &&
          (this.cache = new Float32Array(t.length)),
          Jh(e, t)
      }),
        (Od.prototype.setValue = function (t, e, n) {
          const i = this.seq
          for (let r = 0, s = i.length; r !== s; ++r) {
            const s = i[r]
            s.setValue(t, e[s.id], n)
          }
        })
      const Nd = /(\w+)(\])?(\[|\.)?/g
      function kd(t, e) {
        t.seq.push(e), (t.map[e.id] = e)
      }
      function Bd(t, e, n) {
        const i = t.name,
          r = i.length
        for (Nd.lastIndex = 0; ; ) {
          const s = Nd.exec(i),
            o = Nd.lastIndex
          let a = s[1]
          const l = ']' === s[2],
            c = s[3]
          if ((l && (a |= 0), void 0 === c || ('[' === c && o + 2 === r))) {
            kd(n, void 0 === c ? new Fd(a, t, e) : new Id(a, t, e))
            break
          }
          {
            let t = n.map[a]
            void 0 === t && ((t = new Od(a)), kd(n, t)), (n = t)
          }
        }
      }
      function zd(t, e) {
        ;(this.seq = []), (this.map = {})
        const n = t.getProgramParameter(e, 35718)
        for (let i = 0; i < n; ++i) {
          const n = t.getActiveUniform(e, i)
          Bd(n, t.getUniformLocation(e, n.name), this)
        }
      }
      function Ud(t, e, n) {
        const i = t.createShader(e)
        return t.shaderSource(i, n), t.compileShader(i), i
      }
      ;(zd.prototype.setValue = function (t, e, n, i) {
        const r = this.map[e]
        void 0 !== r && r.setValue(t, n, i)
      }),
        (zd.prototype.setOptional = function (t, e, n) {
          const i = e[n]
          void 0 !== i && this.setValue(t, n, i)
        }),
        (zd.upload = function (t, e, n, i) {
          for (let r = 0, s = e.length; r !== s; ++r) {
            const s = e[r],
              o = n[s.id]
            !1 !== o.needsUpdate && s.setValue(t, o.value, i)
          }
        }),
        (zd.seqWithValue = function (t, e) {
          const n = []
          for (let i = 0, r = t.length; i !== r; ++i) {
            const r = t[i]
            r.id in e && n.push(r)
          }
          return n
        })
      let Hd = 0
      function Gd(t) {
        switch (t) {
          case Wa:
            return ['Linear', '( value )']
          case ja:
            return ['sRGB', '( value )']
          case Xa:
            return ['RGBE', '( value )']
          case 3004:
            return ['RGBM', '( value, 7.0 )']
          case 3005:
            return ['RGBM', '( value, 16.0 )']
          case 3006:
            return ['RGBD', '( value, 256.0 )']
          case qa:
            return ['Gamma', '( value, float( GAMMA_FACTOR ) )']
          case 3003:
            return ['LogLuv', '( value )']
          default:
            return (
              console.warn('THREE.WebGLProgram: Unsupported encoding:', t),
              ['Linear', '( value )']
            )
        }
      }
      function Vd(t, e, n) {
        const i = t.getShaderParameter(e, 35713),
          r = t.getShaderInfoLog(e).trim()
        return i && '' === r
          ? ''
          : n.toUpperCase() +
              '\n\n' +
              r +
              '\n\n' +
              (function (t) {
                const e = t.split('\n')
                for (let t = 0; t < e.length; t++) e[t] = t + 1 + ': ' + e[t]
                return e.join('\n')
              })(t.getShaderSource(e))
      }
      function Wd(t, e) {
        const n = Gd(e)
        return (
          'vec4 ' +
          t +
          '( vec4 value ) { return ' +
          n[0] +
          'ToLinear' +
          n[1] +
          '; }'
        )
      }
      function jd(t, e) {
        const n = Gd(e)
        return (
          'vec4 ' + t + '( vec4 value ) { return LinearTo' + n[0] + n[1] + '; }'
        )
      }
      function qd(t, e) {
        let n
        switch (e) {
          case 1:
            n = 'Linear'
            break
          case 2:
            n = 'Reinhard'
            break
          case 3:
            n = 'OptimizedCineon'
            break
          case 4:
            n = 'ACESFilmic'
            break
          case 5:
            n = 'Custom'
            break
          default:
            console.warn('THREE.WebGLProgram: Unsupported toneMapping:', e),
              (n = 'Linear')
        }
        return (
          'vec3 ' +
          t +
          '( vec3 color ) { return ' +
          n +
          'ToneMapping( color ); }'
        )
      }
      function Xd(t) {
        return '' !== t
      }
      function Yd(t, e) {
        return t
          .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
          .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
          .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
          .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
          .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
      }
      function Jd(t, e) {
        return t
          .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
          .replace(
            /UNION_CLIPPING_PLANES/g,
            e.numClippingPlanes - e.numClipIntersection,
          )
      }
      const Zd = /^[ \t]*#include +<([\w\d./]+)>/gm
      function Kd(t) {
        return t.replace(Zd, Qd)
      }
      function Qd(t, e) {
        const n = Ju[e]
        if (void 0 === n)
          throw new Error('Can not resolve #include <' + e + '>')
        return Kd(n)
      }
      const $d = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
        tp = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g
      function ep(t) {
        return t.replace(tp, ip).replace($d, np)
      }
      function np(t, e, n, i) {
        return (
          console.warn(
            'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.',
          ),
          ip(0, e, n, i)
        )
      }
      function ip(t, e, n, i) {
        let r = ''
        for (let t = parseInt(e); t < parseInt(n); t++)
          r += i
            .replace(/\[\s*i\s*\]/g, '[ ' + t + ' ]')
            .replace(/UNROLLED_LOOP_INDEX/g, t)
        return r
      }
      function rp(t) {
        let e =
          'precision ' +
          t.precision +
          ' float;\nprecision ' +
          t.precision +
          ' int;'
        return (
          'highp' === t.precision
            ? (e += '\n#define HIGH_PRECISION')
            : 'mediump' === t.precision
            ? (e += '\n#define MEDIUM_PRECISION')
            : 'lowp' === t.precision && (e += '\n#define LOW_PRECISION'),
          e
        )
      }
      function sp(t, e, n, i) {
        const r = t.getContext(),
          s = n.defines
        let o = n.vertexShader,
          a = n.fragmentShader
        const l = (function (t) {
            let e = 'SHADOWMAP_TYPE_BASIC'
            return (
              1 === t.shadowMapType
                ? (e = 'SHADOWMAP_TYPE_PCF')
                : 2 === t.shadowMapType
                ? (e = 'SHADOWMAP_TYPE_PCF_SOFT')
                : 3 === t.shadowMapType && (e = 'SHADOWMAP_TYPE_VSM'),
              e
            )
          })(n),
          c = (function (t) {
            let e = 'ENVMAP_TYPE_CUBE'
            if (t.envMap)
              switch (t.envMapMode) {
                case va:
                case _a:
                  e = 'ENVMAP_TYPE_CUBE'
                  break
                case ya:
                case 307:
                  e = 'ENVMAP_TYPE_CUBE_UV'
              }
            return e
          })(n),
          u = (function (t) {
            let e = 'ENVMAP_MODE_REFLECTION'
            if (t.envMap)
              switch (t.envMapMode) {
                case _a:
                case 307:
                  e = 'ENVMAP_MODE_REFRACTION'
              }
            return e
          })(n),
          h = (function (t) {
            let e = 'ENVMAP_BLENDING_NONE'
            if (t.envMap)
              switch (t.combine) {
                case 0:
                  e = 'ENVMAP_BLENDING_MULTIPLY'
                  break
                case 1:
                  e = 'ENVMAP_BLENDING_MIX'
                  break
                case 2:
                  e = 'ENVMAP_BLENDING_ADD'
              }
            return e
          })(n),
          d = t.gammaFactor > 0 ? t.gammaFactor : 1,
          p = n.isWebGL2
            ? ''
            : (function (t) {
                return [
                  t.extensionDerivatives ||
                  t.envMapCubeUV ||
                  t.bumpMap ||
                  t.tangentSpaceNormalMap ||
                  t.clearcoatNormalMap ||
                  t.flatShading ||
                  'physical' === t.shaderID
                    ? '#extension GL_OES_standard_derivatives : enable'
                    : '',
                  (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
                  t.rendererExtensionFragDepth
                    ? '#extension GL_EXT_frag_depth : enable'
                    : '',
                  t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
                    ? '#extension GL_EXT_draw_buffers : require'
                    : '',
                  (t.extensionShaderTextureLOD || t.envMap || t.transmission) &&
                  t.rendererExtensionShaderTextureLod
                    ? '#extension GL_EXT_shader_texture_lod : enable'
                    : '',
                ]
                  .filter(Xd)
                  .join('\n')
              })(n),
          f = (function (t) {
            const e = []
            for (const n in t) {
              const i = t[n]
              !1 !== i && e.push('#define ' + n + ' ' + i)
            }
            return e.join('\n')
          })(s),
          m = r.createProgram()
        let g,
          v,
          _ = n.glslVersion ? '#version ' + n.glslVersion + '\n' : ''
        n.isRawShaderMaterial
          ? ((g = [f].filter(Xd).join('\n')),
            g.length > 0 && (g += '\n'),
            (v = [p, f].filter(Xd).join('\n')),
            v.length > 0 && (v += '\n'))
          : ((g = [
              rp(n),
              '#define SHADER_NAME ' + n.shaderName,
              f,
              n.instancing ? '#define USE_INSTANCING' : '',
              n.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
              n.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
              '#define GAMMA_FACTOR ' + d,
              '#define MAX_BONES ' + n.maxBones,
              n.useFog && n.fog ? '#define USE_FOG' : '',
              n.useFog && n.fogExp2 ? '#define FOG_EXP2' : '',
              n.map ? '#define USE_MAP' : '',
              n.envMap ? '#define USE_ENVMAP' : '',
              n.envMap ? '#define ' + u : '',
              n.lightMap ? '#define USE_LIGHTMAP' : '',
              n.aoMap ? '#define USE_AOMAP' : '',
              n.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
              n.bumpMap ? '#define USE_BUMPMAP' : '',
              n.normalMap ? '#define USE_NORMALMAP' : '',
              n.normalMap && n.objectSpaceNormalMap
                ? '#define OBJECTSPACE_NORMALMAP'
                : '',
              n.normalMap && n.tangentSpaceNormalMap
                ? '#define TANGENTSPACE_NORMALMAP'
                : '',
              n.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
              n.clearcoatRoughnessMap
                ? '#define USE_CLEARCOAT_ROUGHNESSMAP'
                : '',
              n.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
              n.displacementMap && n.supportsVertexTextures
                ? '#define USE_DISPLACEMENTMAP'
                : '',
              n.specularMap ? '#define USE_SPECULARMAP' : '',
              n.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
              n.specularTintMap ? '#define USE_SPECULARTINTMAP' : '',
              n.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
              n.metalnessMap ? '#define USE_METALNESSMAP' : '',
              n.alphaMap ? '#define USE_ALPHAMAP' : '',
              n.transmission ? '#define USE_TRANSMISSION' : '',
              n.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
              n.thicknessMap ? '#define USE_THICKNESSMAP' : '',
              n.vertexTangents ? '#define USE_TANGENT' : '',
              n.vertexColors ? '#define USE_COLOR' : '',
              n.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
              n.vertexUvs ? '#define USE_UV' : '',
              n.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
              n.flatShading ? '#define FLAT_SHADED' : '',
              n.skinning ? '#define USE_SKINNING' : '',
              n.useVertexTexture ? '#define BONE_TEXTURE' : '',
              n.morphTargets ? '#define USE_MORPHTARGETS' : '',
              n.morphNormals && !1 === n.flatShading
                ? '#define USE_MORPHNORMALS'
                : '',
              n.morphTargets && n.isWebGL2
                ? '#define MORPHTARGETS_TEXTURE'
                : '',
              n.morphTargets && n.isWebGL2
                ? '#define MORPHTARGETS_COUNT ' + n.morphTargetsCount
                : '',
              n.doubleSided ? '#define DOUBLE_SIDED' : '',
              n.flipSided ? '#define FLIP_SIDED' : '',
              n.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
              n.shadowMapEnabled ? '#define ' + l : '',
              n.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
              n.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
              n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                ? '#define USE_LOGDEPTHBUF_EXT'
                : '',
              'uniform mat4 modelMatrix;',
              'uniform mat4 modelViewMatrix;',
              'uniform mat4 projectionMatrix;',
              'uniform mat4 viewMatrix;',
              'uniform mat3 normalMatrix;',
              'uniform vec3 cameraPosition;',
              'uniform bool isOrthographic;',
              '#ifdef USE_INSTANCING',
              '\tattribute mat4 instanceMatrix;',
              '#endif',
              '#ifdef USE_INSTANCING_COLOR',
              '\tattribute vec3 instanceColor;',
              '#endif',
              'attribute vec3 position;',
              'attribute vec3 normal;',
              'attribute vec2 uv;',
              '#ifdef USE_TANGENT',
              '\tattribute vec4 tangent;',
              '#endif',
              '#if defined( USE_COLOR_ALPHA )',
              '\tattribute vec4 color;',
              '#elif defined( USE_COLOR )',
              '\tattribute vec3 color;',
              '#endif',
              '#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',
              '\tattribute vec3 morphTarget0;',
              '\tattribute vec3 morphTarget1;',
              '\tattribute vec3 morphTarget2;',
              '\tattribute vec3 morphTarget3;',
              '\t#ifdef USE_MORPHNORMALS',
              '\t\tattribute vec3 morphNormal0;',
              '\t\tattribute vec3 morphNormal1;',
              '\t\tattribute vec3 morphNormal2;',
              '\t\tattribute vec3 morphNormal3;',
              '\t#else',
              '\t\tattribute vec3 morphTarget4;',
              '\t\tattribute vec3 morphTarget5;',
              '\t\tattribute vec3 morphTarget6;',
              '\t\tattribute vec3 morphTarget7;',
              '\t#endif',
              '#endif',
              '#ifdef USE_SKINNING',
              '\tattribute vec4 skinIndex;',
              '\tattribute vec4 skinWeight;',
              '#endif',
              '\n',
            ]
              .filter(Xd)
              .join('\n')),
            (v = [
              p,
              rp(n),
              '#define SHADER_NAME ' + n.shaderName,
              f,
              '#define GAMMA_FACTOR ' + d,
              n.useFog && n.fog ? '#define USE_FOG' : '',
              n.useFog && n.fogExp2 ? '#define FOG_EXP2' : '',
              n.map ? '#define USE_MAP' : '',
              n.matcap ? '#define USE_MATCAP' : '',
              n.envMap ? '#define USE_ENVMAP' : '',
              n.envMap ? '#define ' + c : '',
              n.envMap ? '#define ' + u : '',
              n.envMap ? '#define ' + h : '',
              n.lightMap ? '#define USE_LIGHTMAP' : '',
              n.aoMap ? '#define USE_AOMAP' : '',
              n.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
              n.bumpMap ? '#define USE_BUMPMAP' : '',
              n.normalMap ? '#define USE_NORMALMAP' : '',
              n.normalMap && n.objectSpaceNormalMap
                ? '#define OBJECTSPACE_NORMALMAP'
                : '',
              n.normalMap && n.tangentSpaceNormalMap
                ? '#define TANGENTSPACE_NORMALMAP'
                : '',
              n.clearcoat ? '#define USE_CLEARCOAT' : '',
              n.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
              n.clearcoatRoughnessMap
                ? '#define USE_CLEARCOAT_ROUGHNESSMAP'
                : '',
              n.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
              n.specularMap ? '#define USE_SPECULARMAP' : '',
              n.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
              n.specularTintMap ? '#define USE_SPECULARTINTMAP' : '',
              n.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
              n.metalnessMap ? '#define USE_METALNESSMAP' : '',
              n.alphaMap ? '#define USE_ALPHAMAP' : '',
              n.alphaTest ? '#define USE_ALPHATEST' : '',
              n.sheen ? '#define USE_SHEEN' : '',
              n.transmission ? '#define USE_TRANSMISSION' : '',
              n.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
              n.thicknessMap ? '#define USE_THICKNESSMAP' : '',
              n.vertexTangents ? '#define USE_TANGENT' : '',
              n.vertexColors || n.instancingColor ? '#define USE_COLOR' : '',
              n.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
              n.vertexUvs ? '#define USE_UV' : '',
              n.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
              n.gradientMap ? '#define USE_GRADIENTMAP' : '',
              n.flatShading ? '#define FLAT_SHADED' : '',
              n.doubleSided ? '#define DOUBLE_SIDED' : '',
              n.flipSided ? '#define FLIP_SIDED' : '',
              n.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
              n.shadowMapEnabled ? '#define ' + l : '',
              n.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
              n.physicallyCorrectLights
                ? '#define PHYSICALLY_CORRECT_LIGHTS'
                : '',
              n.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
              n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                ? '#define USE_LOGDEPTHBUF_EXT'
                : '',
              (n.extensionShaderTextureLOD || n.envMap) &&
              n.rendererExtensionShaderTextureLod
                ? '#define TEXTURE_LOD_EXT'
                : '',
              'uniform mat4 viewMatrix;',
              'uniform vec3 cameraPosition;',
              'uniform bool isOrthographic;',
              0 !== n.toneMapping ? '#define TONE_MAPPING' : '',
              0 !== n.toneMapping ? Ju.tonemapping_pars_fragment : '',
              0 !== n.toneMapping ? qd('toneMapping', n.toneMapping) : '',
              n.dithering ? '#define DITHERING' : '',
              n.format === Ia ? '#define OPAQUE' : '',
              Ju.encodings_pars_fragment,
              n.map ? Wd('mapTexelToLinear', n.mapEncoding) : '',
              n.matcap ? Wd('matcapTexelToLinear', n.matcapEncoding) : '',
              n.envMap ? Wd('envMapTexelToLinear', n.envMapEncoding) : '',
              n.emissiveMap
                ? Wd('emissiveMapTexelToLinear', n.emissiveMapEncoding)
                : '',
              n.specularTintMap
                ? Wd('specularTintMapTexelToLinear', n.specularTintMapEncoding)
                : '',
              n.lightMap ? Wd('lightMapTexelToLinear', n.lightMapEncoding) : '',
              jd('linearToOutputTexel', n.outputEncoding),
              n.depthPacking ? '#define DEPTH_PACKING ' + n.depthPacking : '',
              '\n',
            ]
              .filter(Xd)
              .join('\n'))),
          (o = Kd(o)),
          (o = Yd(o, n)),
          (o = Jd(o, n)),
          (a = Kd(a)),
          (a = Yd(a, n)),
          (a = Jd(a, n)),
          (o = ep(o)),
          (a = ep(a)),
          n.isWebGL2 &&
            !0 !== n.isRawShaderMaterial &&
            ((_ = '#version 300 es\n'),
            (g =
              [
                'precision mediump sampler2DArray;',
                '#define attribute in',
                '#define varying out',
                '#define texture2D texture',
              ].join('\n') +
              '\n' +
              g),
            (v =
              [
                '#define varying in',
                n.glslVersion === Ka ? '' : 'out highp vec4 pc_fragColor;',
                n.glslVersion === Ka ? '' : '#define gl_FragColor pc_fragColor',
                '#define gl_FragDepthEXT gl_FragDepth',
                '#define texture2D texture',
                '#define textureCube texture',
                '#define texture2DProj textureProj',
                '#define texture2DLodEXT textureLod',
                '#define texture2DProjLodEXT textureProjLod',
                '#define textureCubeLodEXT textureLod',
                '#define texture2DGradEXT textureGrad',
                '#define texture2DProjGradEXT textureProjGrad',
                '#define textureCubeGradEXT textureGrad',
              ].join('\n') +
              '\n' +
              v))
        const y = _ + v + a,
          x = Ud(r, 35633, _ + g + o),
          b = Ud(r, 35632, y)
        if (
          (r.attachShader(m, x),
          r.attachShader(m, b),
          void 0 !== n.index0AttributeName
            ? r.bindAttribLocation(m, 0, n.index0AttributeName)
            : !0 === n.morphTargets && r.bindAttribLocation(m, 0, 'position'),
          r.linkProgram(m),
          t.debug.checkShaderErrors)
        ) {
          const t = r.getProgramInfoLog(m).trim(),
            e = r.getShaderInfoLog(x).trim(),
            n = r.getShaderInfoLog(b).trim()
          let i = !0,
            s = !0
          if (!1 === r.getProgramParameter(m, 35714)) {
            i = !1
            const e = Vd(r, x, 'vertex'),
              n = Vd(r, b, 'fragment')
            console.error(
              'THREE.WebGLProgram: Shader Error ' +
                r.getError() +
                ' - VALIDATE_STATUS ' +
                r.getProgramParameter(m, 35715) +
                '\n\nProgram Info Log: ' +
                t +
                '\n' +
                e +
                '\n' +
                n,
            )
          } else
            '' !== t
              ? console.warn('THREE.WebGLProgram: Program Info Log:', t)
              : ('' !== e && '' !== n) || (s = !1)
          s &&
            (this.diagnostics = {
              runnable: i,
              programLog: t,
              vertexShader: { log: e, prefix: g },
              fragmentShader: { log: n, prefix: v },
            })
        }
        let w, M
        return (
          r.deleteShader(x),
          r.deleteShader(b),
          (this.getUniforms = function () {
            return void 0 === w && (w = new zd(r, m)), w
          }),
          (this.getAttributes = function () {
            return (
              void 0 === M &&
                (M = (function (t, e) {
                  const n = {},
                    i = t.getProgramParameter(e, 35721)
                  for (let r = 0; r < i; r++) {
                    const i = t.getActiveAttrib(e, r),
                      s = i.name
                    let o = 1
                    35674 === i.type && (o = 2),
                      35675 === i.type && (o = 3),
                      35676 === i.type && (o = 4),
                      (n[s] = {
                        type: i.type,
                        location: t.getAttribLocation(e, s),
                        locationSize: o,
                      })
                  }
                  return n
                })(r, m)),
              M
            )
          }),
          (this.destroy = function () {
            i.releaseStatesOfProgram(this),
              r.deleteProgram(m),
              (this.program = void 0)
          }),
          (this.name = n.shaderName),
          (this.id = Hd++),
          (this.cacheKey = e),
          (this.usedTimes = 1),
          (this.program = m),
          (this.vertexShader = x),
          (this.fragmentShader = b),
          this
        )
      }
      function op(t, e, n, i, r, s, o) {
        const a = [],
          l = r.isWebGL2,
          c = r.logarithmicDepthBuffer,
          u = r.floatVertexTextures,
          h = r.maxVertexUniforms,
          d = r.vertexTextures
        let p = r.precision
        const f = {
            MeshDepthMaterial: 'depth',
            MeshDistanceMaterial: 'distanceRGBA',
            MeshNormalMaterial: 'normal',
            MeshBasicMaterial: 'basic',
            MeshLambertMaterial: 'lambert',
            MeshPhongMaterial: 'phong',
            MeshToonMaterial: 'toon',
            MeshStandardMaterial: 'physical',
            MeshPhysicalMaterial: 'physical',
            MeshMatcapMaterial: 'matcap',
            LineBasicMaterial: 'basic',
            LineDashedMaterial: 'dashed',
            PointsMaterial: 'points',
            ShadowMaterial: 'shadow',
            SpriteMaterial: 'sprite',
          },
          m = [
            'precision',
            'isWebGL2',
            'supportsVertexTextures',
            'outputEncoding',
            'instancing',
            'instancingColor',
            'map',
            'mapEncoding',
            'matcap',
            'matcapEncoding',
            'envMap',
            'envMapMode',
            'envMapEncoding',
            'envMapCubeUV',
            'lightMap',
            'lightMapEncoding',
            'aoMap',
            'emissiveMap',
            'emissiveMapEncoding',
            'bumpMap',
            'normalMap',
            'objectSpaceNormalMap',
            'tangentSpaceNormalMap',
            'clearcoat',
            'clearcoatMap',
            'clearcoatRoughnessMap',
            'clearcoatNormalMap',
            'displacementMap',
            'specularMap',
            'specularIntensityMap',
            'specularTintMap',
            'specularTintMapEncoding',
            'roughnessMap',
            'metalnessMap',
            'gradientMap',
            'alphaMap',
            'alphaTest',
            'combine',
            'vertexColors',
            'vertexAlphas',
            'vertexTangents',
            'vertexUvs',
            'uvsVertexOnly',
            'fog',
            'useFog',
            'fogExp2',
            'flatShading',
            'sizeAttenuation',
            'logarithmicDepthBuffer',
            'skinning',
            'maxBones',
            'useVertexTexture',
            'morphTargets',
            'morphNormals',
            'morphTargetsCount',
            'premultipliedAlpha',
            'numDirLights',
            'numPointLights',
            'numSpotLights',
            'numHemiLights',
            'numRectAreaLights',
            'numDirLightShadows',
            'numPointLightShadows',
            'numSpotLightShadows',
            'shadowMapEnabled',
            'shadowMapType',
            'toneMapping',
            'physicallyCorrectLights',
            'doubleSided',
            'flipSided',
            'numClippingPlanes',
            'numClipIntersection',
            'depthPacking',
            'dithering',
            'format',
            'sheen',
            'transmission',
            'transmissionMap',
            'thicknessMap',
          ]
        function g(t) {
          let e
          return (
            t && t.isTexture
              ? (e = t.encoding)
              : t && t.isWebGLRenderTarget
              ? (console.warn(
                  "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.",
                ),
                (e = t.texture.encoding))
              : (e = Wa),
            l &&
              t &&
              t.isTexture &&
              t.format === Oa &&
              t.type === Aa &&
              t.encoding === ja &&
              (e = Wa),
            e
          )
        }
        return {
          getParameters: function (s, a, m, v, _) {
            const y = v.fog,
              x = s.isMeshStandardMaterial ? v.environment : null,
              b = (s.isMeshStandardMaterial ? n : e).get(s.envMap || x),
              w = f[s.type],
              M = _.isSkinnedMesh
                ? (function (t) {
                    const e = t.skeleton.bones
                    if (u) return 1024
                    {
                      const t = h,
                        n = Math.floor((t - 20) / 4),
                        i = Math.min(n, e.length)
                      return i < e.length
                        ? (console.warn(
                            'THREE.WebGLRenderer: Skeleton has ' +
                              e.length +
                              ' bones. This GPU supports ' +
                              i +
                              '.',
                          ),
                          0)
                        : i
                    }
                  })(_)
                : 0
            let S, T
            if (
              (null !== s.precision &&
                ((p = r.getMaxPrecision(s.precision)),
                p !== s.precision &&
                  console.warn(
                    'THREE.WebGLProgram.getParameters:',
                    s.precision,
                    'not supported, using',
                    p,
                    'instead.',
                  )),
              w)
            ) {
              const t = Ku[w]
              ;(S = t.vertexShader), (T = t.fragmentShader)
            } else (S = s.vertexShader), (T = s.fragmentShader)
            const E = t.getRenderTarget(),
              D = s.alphaTest > 0,
              A = s.clearcoat > 0
            return {
              isWebGL2: l,
              shaderID: w,
              shaderName: s.type,
              vertexShader: S,
              fragmentShader: T,
              defines: s.defines,
              isRawShaderMaterial: !0 === s.isRawShaderMaterial,
              glslVersion: s.glslVersion,
              precision: p,
              instancing: !0 === _.isInstancedMesh,
              instancingColor:
                !0 === _.isInstancedMesh && null !== _.instanceColor,
              supportsVertexTextures: d,
              outputEncoding: null !== E ? g(E.texture) : t.outputEncoding,
              map: !!s.map,
              mapEncoding: g(s.map),
              matcap: !!s.matcap,
              matcapEncoding: g(s.matcap),
              envMap: !!b,
              envMapMode: b && b.mapping,
              envMapEncoding: g(b),
              envMapCubeUV: !!b && (b.mapping === ya || 307 === b.mapping),
              lightMap: !!s.lightMap,
              lightMapEncoding: g(s.lightMap),
              aoMap: !!s.aoMap,
              emissiveMap: !!s.emissiveMap,
              emissiveMapEncoding: g(s.emissiveMap),
              bumpMap: !!s.bumpMap,
              normalMap: !!s.normalMap,
              objectSpaceNormalMap: 1 === s.normalMapType,
              tangentSpaceNormalMap: 0 === s.normalMapType,
              clearcoat: A,
              clearcoatMap: A && !!s.clearcoatMap,
              clearcoatRoughnessMap: A && !!s.clearcoatRoughnessMap,
              clearcoatNormalMap: A && !!s.clearcoatNormalMap,
              displacementMap: !!s.displacementMap,
              roughnessMap: !!s.roughnessMap,
              metalnessMap: !!s.metalnessMap,
              specularMap: !!s.specularMap,
              specularIntensityMap: !!s.specularIntensityMap,
              specularTintMap: !!s.specularTintMap,
              specularTintMapEncoding: g(s.specularTintMap),
              alphaMap: !!s.alphaMap,
              alphaTest: D,
              gradientMap: !!s.gradientMap,
              sheen: s.sheen > 0,
              transmission: s.transmission > 0,
              transmissionMap: !!s.transmissionMap,
              thicknessMap: !!s.thicknessMap,
              combine: s.combine,
              vertexTangents:
                !!s.normalMap &&
                !!_.geometry &&
                !!_.geometry.attributes.tangent,
              vertexColors: s.vertexColors,
              vertexAlphas:
                !0 === s.vertexColors &&
                !!_.geometry &&
                !!_.geometry.attributes.color &&
                4 === _.geometry.attributes.color.itemSize,
              vertexUvs: !!(
                s.map ||
                s.bumpMap ||
                s.normalMap ||
                s.specularMap ||
                s.alphaMap ||
                s.emissiveMap ||
                s.roughnessMap ||
                s.metalnessMap ||
                s.clearcoatMap ||
                s.clearcoatRoughnessMap ||
                s.clearcoatNormalMap ||
                s.displacementMap ||
                s.transmissionMap ||
                s.thicknessMap ||
                s.specularIntensityMap ||
                s.specularTintMap
              ),
              uvsVertexOnly: !(
                s.map ||
                s.bumpMap ||
                s.normalMap ||
                s.specularMap ||
                s.alphaMap ||
                s.emissiveMap ||
                s.roughnessMap ||
                s.metalnessMap ||
                s.clearcoatNormalMap ||
                s.transmission > 0 ||
                s.transmissionMap ||
                s.thicknessMap ||
                s.specularIntensityMap ||
                s.specularTintMap ||
                !s.displacementMap
              ),
              fog: !!y,
              useFog: s.fog,
              fogExp2: y && y.isFogExp2,
              flatShading: !!s.flatShading,
              sizeAttenuation: s.sizeAttenuation,
              logarithmicDepthBuffer: c,
              skinning: !0 === _.isSkinnedMesh && M > 0,
              maxBones: M,
              useVertexTexture: u,
              morphTargets:
                !!_.geometry && !!_.geometry.morphAttributes.position,
              morphNormals: !!_.geometry && !!_.geometry.morphAttributes.normal,
              morphTargetsCount:
                _.geometry && _.geometry.morphAttributes.position
                  ? _.geometry.morphAttributes.position.length
                  : 0,
              numDirLights: a.directional.length,
              numPointLights: a.point.length,
              numSpotLights: a.spot.length,
              numRectAreaLights: a.rectArea.length,
              numHemiLights: a.hemi.length,
              numDirLightShadows: a.directionalShadowMap.length,
              numPointLightShadows: a.pointShadowMap.length,
              numSpotLightShadows: a.spotShadowMap.length,
              numClippingPlanes: o.numPlanes,
              numClipIntersection: o.numIntersection,
              format: s.format,
              dithering: s.dithering,
              shadowMapEnabled: t.shadowMap.enabled && m.length > 0,
              shadowMapType: t.shadowMap.type,
              toneMapping: s.toneMapped ? t.toneMapping : 0,
              physicallyCorrectLights: t.physicallyCorrectLights,
              premultipliedAlpha: s.premultipliedAlpha,
              doubleSided: 2 === s.side,
              flipSided: 1 === s.side,
              depthPacking: void 0 !== s.depthPacking && s.depthPacking,
              index0AttributeName: s.index0AttributeName,
              extensionDerivatives: s.extensions && s.extensions.derivatives,
              extensionFragDepth: s.extensions && s.extensions.fragDepth,
              extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
              extensionShaderTextureLOD:
                s.extensions && s.extensions.shaderTextureLOD,
              rendererExtensionFragDepth: l || i.has('EXT_frag_depth'),
              rendererExtensionDrawBuffers: l || i.has('WEBGL_draw_buffers'),
              rendererExtensionShaderTextureLod:
                l || i.has('EXT_shader_texture_lod'),
              customProgramCacheKey: s.customProgramCacheKey(),
            }
          },
          getProgramCacheKey: function (e) {
            const n = []
            if (
              (e.shaderID
                ? n.push(e.shaderID)
                : (n.push(e.fragmentShader), n.push(e.vertexShader)),
              void 0 !== e.defines)
            )
              for (const t in e.defines) n.push(t), n.push(e.defines[t])
            if (!1 === e.isRawShaderMaterial) {
              for (let t = 0; t < m.length; t++) n.push(e[m[t]])
              n.push(t.outputEncoding), n.push(t.gammaFactor)
            }
            return n.push(e.customProgramCacheKey), n.join()
          },
          getUniforms: function (t) {
            const e = f[t.type]
            let n
            if (e) {
              const t = Ku[e]
              n = Ru.clone(t.uniforms)
            } else n = t.uniforms
            return n
          },
          acquireProgram: function (e, n) {
            let i
            for (let t = 0, e = a.length; t < e; t++) {
              const e = a[t]
              if (e.cacheKey === n) {
                ;(i = e), ++i.usedTimes
                break
              }
            }
            return void 0 === i && ((i = new sp(t, n, e, s)), a.push(i)), i
          },
          releaseProgram: function (t) {
            if (0 == --t.usedTimes) {
              const e = a.indexOf(t)
              ;(a[e] = a[a.length - 1]), a.pop(), t.destroy()
            }
          },
          programs: a,
        }
      }
      function ap() {
        let t = new WeakMap()
        return {
          get: function (e) {
            let n = t.get(e)
            return void 0 === n && ((n = {}), t.set(e, n)), n
          },
          remove: function (e) {
            t.delete(e)
          },
          update: function (e, n, i) {
            t.get(e)[n] = i
          },
          dispose: function () {
            t = new WeakMap()
          },
        }
      }
      function lp(t, e) {
        return t.groupOrder !== e.groupOrder
          ? t.groupOrder - e.groupOrder
          : t.renderOrder !== e.renderOrder
          ? t.renderOrder - e.renderOrder
          : t.program !== e.program
          ? t.program.id - e.program.id
          : t.material.id !== e.material.id
          ? t.material.id - e.material.id
          : t.z !== e.z
          ? t.z - e.z
          : t.id - e.id
      }
      function cp(t, e) {
        return t.groupOrder !== e.groupOrder
          ? t.groupOrder - e.groupOrder
          : t.renderOrder !== e.renderOrder
          ? t.renderOrder - e.renderOrder
          : t.z !== e.z
          ? e.z - t.z
          : t.id - e.id
      }
      function up(t) {
        const e = []
        let n = 0
        const i = [],
          r = [],
          s = [],
          o = { id: -1 }
        function a(i, r, s, a, l, c) {
          let u = e[n]
          const h = t.get(s)
          return (
            void 0 === u
              ? ((u = {
                  id: i.id,
                  object: i,
                  geometry: r,
                  material: s,
                  program: h.program || o,
                  groupOrder: a,
                  renderOrder: i.renderOrder,
                  z: l,
                  group: c,
                }),
                (e[n] = u))
              : ((u.id = i.id),
                (u.object = i),
                (u.geometry = r),
                (u.material = s),
                (u.program = h.program || o),
                (u.groupOrder = a),
                (u.renderOrder = i.renderOrder),
                (u.z = l),
                (u.group = c)),
            n++,
            u
          )
        }
        return {
          opaque: i,
          transmissive: r,
          transparent: s,
          init: function () {
            ;(n = 0), (i.length = 0), (r.length = 0), (s.length = 0)
          },
          push: function (t, e, n, o, l, c) {
            const u = a(t, e, n, o, l, c)
            n.transmission > 0
              ? r.push(u)
              : !0 === n.transparent
              ? s.push(u)
              : i.push(u)
          },
          unshift: function (t, e, n, o, l, c) {
            const u = a(t, e, n, o, l, c)
            n.transmission > 0
              ? r.unshift(u)
              : !0 === n.transparent
              ? s.unshift(u)
              : i.unshift(u)
          },
          finish: function () {
            for (let t = n, i = e.length; t < i; t++) {
              const n = e[t]
              if (null === n.id) break
              ;(n.id = null),
                (n.object = null),
                (n.geometry = null),
                (n.material = null),
                (n.program = null),
                (n.group = null)
            }
          },
          sort: function (t, e) {
            i.length > 1 && i.sort(t || lp),
              r.length > 1 && r.sort(e || cp),
              s.length > 1 && s.sort(e || cp)
          },
        }
      }
      function hp(t) {
        let e = new WeakMap()
        return {
          get: function (n, i) {
            let r
            return (
              !1 === e.has(n)
                ? ((r = new up(t)), e.set(n, [r]))
                : i >= e.get(n).length
                ? ((r = new up(t)), e.get(n).push(r))
                : (r = e.get(n)[i]),
              r
            )
          },
          dispose: function () {
            e = new WeakMap()
          },
        }
      }
      function dp() {
        const t = {}
        return {
          get: function (e) {
            if (void 0 !== t[e.id]) return t[e.id]
            let n
            switch (e.type) {
              case 'DirectionalLight':
                n = { direction: new Tl(), color: new Xc() }
                break
              case 'SpotLight':
                n = {
                  position: new Tl(),
                  direction: new Tl(),
                  color: new Xc(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0,
                }
                break
              case 'PointLight':
                n = {
                  position: new Tl(),
                  color: new Xc(),
                  distance: 0,
                  decay: 0,
                }
                break
              case 'HemisphereLight':
                n = {
                  direction: new Tl(),
                  skyColor: new Xc(),
                  groundColor: new Xc(),
                }
                break
              case 'RectAreaLight':
                n = {
                  color: new Xc(),
                  position: new Tl(),
                  halfWidth: new Tl(),
                  halfHeight: new Tl(),
                }
            }
            return (t[e.id] = n), n
          },
        }
      }
      let pp = 0
      function fp(t, e) {
        return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
      }
      function mp(t, e) {
        const n = new dp(),
          i = (function () {
            const t = {}
            return {
              get: function (e) {
                if (void 0 !== t[e.id]) return t[e.id]
                let n
                switch (e.type) {
                  case 'DirectionalLight':
                  case 'SpotLight':
                    n = {
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new dl(),
                    }
                    break
                  case 'PointLight':
                    n = {
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new dl(),
                      shadowCameraNear: 1,
                      shadowCameraFar: 1e3,
                    }
                }
                return (t[e.id] = n), n
              },
            }
          })(),
          r = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadow: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
          }
        for (let t = 0; t < 9; t++) r.probe.push(new Tl())
        const s = new Tl(),
          o = new nc(),
          a = new nc()
        return {
          setup: function (s, o) {
            let a = 0,
              l = 0,
              c = 0
            for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0)
            let u = 0,
              h = 0,
              d = 0,
              p = 0,
              f = 0,
              m = 0,
              g = 0,
              v = 0
            s.sort(fp)
            const _ = !0 !== o ? Math.PI : 1
            for (let t = 0, e = s.length; t < e; t++) {
              const e = s[t],
                o = e.color,
                y = e.intensity,
                x = e.distance,
                b = e.shadow && e.shadow.map ? e.shadow.map.texture : null
              if (e.isAmbientLight)
                (a += o.r * y * _), (l += o.g * y * _), (c += o.b * y * _)
              else if (e.isLightProbe)
                for (let t = 0; t < 9; t++)
                  r.probe[t].addScaledVector(e.sh.coefficients[t], y)
              else if (e.isDirectionalLight) {
                const t = n.get(e)
                if (
                  (t.color.copy(e.color).multiplyScalar(e.intensity * _),
                  e.castShadow)
                ) {
                  const t = e.shadow,
                    n = i.get(e)
                  ;(n.shadowBias = t.bias),
                    (n.shadowNormalBias = t.normalBias),
                    (n.shadowRadius = t.radius),
                    (n.shadowMapSize = t.mapSize),
                    (r.directionalShadow[u] = n),
                    (r.directionalShadowMap[u] = b),
                    (r.directionalShadowMatrix[u] = e.shadow.matrix),
                    m++
                }
                ;(r.directional[u] = t), u++
              } else if (e.isSpotLight) {
                const t = n.get(e)
                if (
                  (t.position.setFromMatrixPosition(e.matrixWorld),
                  t.color.copy(o).multiplyScalar(y * _),
                  (t.distance = x),
                  (t.coneCos = Math.cos(e.angle)),
                  (t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra))),
                  (t.decay = e.decay),
                  e.castShadow)
                ) {
                  const t = e.shadow,
                    n = i.get(e)
                  ;(n.shadowBias = t.bias),
                    (n.shadowNormalBias = t.normalBias),
                    (n.shadowRadius = t.radius),
                    (n.shadowMapSize = t.mapSize),
                    (r.spotShadow[d] = n),
                    (r.spotShadowMap[d] = b),
                    (r.spotShadowMatrix[d] = e.shadow.matrix),
                    v++
                }
                ;(r.spot[d] = t), d++
              } else if (e.isRectAreaLight) {
                const t = n.get(e)
                t.color.copy(o).multiplyScalar(y),
                  t.halfWidth.set(0.5 * e.width, 0, 0),
                  t.halfHeight.set(0, 0.5 * e.height, 0),
                  (r.rectArea[p] = t),
                  p++
              } else if (e.isPointLight) {
                const t = n.get(e)
                if (
                  (t.color.copy(e.color).multiplyScalar(e.intensity * _),
                  (t.distance = e.distance),
                  (t.decay = e.decay),
                  e.castShadow)
                ) {
                  const t = e.shadow,
                    n = i.get(e)
                  ;(n.shadowBias = t.bias),
                    (n.shadowNormalBias = t.normalBias),
                    (n.shadowRadius = t.radius),
                    (n.shadowMapSize = t.mapSize),
                    (n.shadowCameraNear = t.camera.near),
                    (n.shadowCameraFar = t.camera.far),
                    (r.pointShadow[h] = n),
                    (r.pointShadowMap[h] = b),
                    (r.pointShadowMatrix[h] = e.shadow.matrix),
                    g++
                }
                ;(r.point[h] = t), h++
              } else if (e.isHemisphereLight) {
                const t = n.get(e)
                t.skyColor.copy(e.color).multiplyScalar(y * _),
                  t.groundColor.copy(e.groundColor).multiplyScalar(y * _),
                  (r.hemi[f] = t),
                  f++
              }
            }
            p > 0 &&
              (e.isWebGL2 || !0 === t.has('OES_texture_float_linear')
                ? ((r.rectAreaLTC1 = Zu.LTC_FLOAT_1),
                  (r.rectAreaLTC2 = Zu.LTC_FLOAT_2))
                : !0 === t.has('OES_texture_half_float_linear')
                ? ((r.rectAreaLTC1 = Zu.LTC_HALF_1),
                  (r.rectAreaLTC2 = Zu.LTC_HALF_2))
                : console.error(
                    'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.',
                  )),
              (r.ambient[0] = a),
              (r.ambient[1] = l),
              (r.ambient[2] = c)
            const y = r.hash
            ;(y.directionalLength === u &&
              y.pointLength === h &&
              y.spotLength === d &&
              y.rectAreaLength === p &&
              y.hemiLength === f &&
              y.numDirectionalShadows === m &&
              y.numPointShadows === g &&
              y.numSpotShadows === v) ||
              ((r.directional.length = u),
              (r.spot.length = d),
              (r.rectArea.length = p),
              (r.point.length = h),
              (r.hemi.length = f),
              (r.directionalShadow.length = m),
              (r.directionalShadowMap.length = m),
              (r.pointShadow.length = g),
              (r.pointShadowMap.length = g),
              (r.spotShadow.length = v),
              (r.spotShadowMap.length = v),
              (r.directionalShadowMatrix.length = m),
              (r.pointShadowMatrix.length = g),
              (r.spotShadowMatrix.length = v),
              (y.directionalLength = u),
              (y.pointLength = h),
              (y.spotLength = d),
              (y.rectAreaLength = p),
              (y.hemiLength = f),
              (y.numDirectionalShadows = m),
              (y.numPointShadows = g),
              (y.numSpotShadows = v),
              (r.version = pp++))
          },
          setupView: function (t, e) {
            let n = 0,
              i = 0,
              l = 0,
              c = 0,
              u = 0
            const h = e.matrixWorldInverse
            for (let e = 0, d = t.length; e < d; e++) {
              const d = t[e]
              if (d.isDirectionalLight) {
                const t = r.directional[n]
                t.direction.setFromMatrixPosition(d.matrixWorld),
                  s.setFromMatrixPosition(d.target.matrixWorld),
                  t.direction.sub(s),
                  t.direction.transformDirection(h),
                  n++
              } else if (d.isSpotLight) {
                const t = r.spot[l]
                t.position.setFromMatrixPosition(d.matrixWorld),
                  t.position.applyMatrix4(h),
                  t.direction.setFromMatrixPosition(d.matrixWorld),
                  s.setFromMatrixPosition(d.target.matrixWorld),
                  t.direction.sub(s),
                  t.direction.transformDirection(h),
                  l++
              } else if (d.isRectAreaLight) {
                const t = r.rectArea[c]
                t.position.setFromMatrixPosition(d.matrixWorld),
                  t.position.applyMatrix4(h),
                  a.identity(),
                  o.copy(d.matrixWorld),
                  o.premultiply(h),
                  a.extractRotation(o),
                  t.halfWidth.set(0.5 * d.width, 0, 0),
                  t.halfHeight.set(0, 0.5 * d.height, 0),
                  t.halfWidth.applyMatrix4(a),
                  t.halfHeight.applyMatrix4(a),
                  c++
              } else if (d.isPointLight) {
                const t = r.point[i]
                t.position.setFromMatrixPosition(d.matrixWorld),
                  t.position.applyMatrix4(h),
                  i++
              } else if (d.isHemisphereLight) {
                const t = r.hemi[u]
                t.direction.setFromMatrixPosition(d.matrixWorld),
                  t.direction.transformDirection(h),
                  t.direction.normalize(),
                  u++
              }
            }
          },
          state: r,
        }
      }
      function gp(t, e) {
        const n = new mp(t, e),
          i = [],
          r = []
        return {
          init: function () {
            ;(i.length = 0), (r.length = 0)
          },
          state: { lightsArray: i, shadowsArray: r, lights: n },
          setupLights: function (t) {
            n.setup(i, t)
          },
          setupLightsView: function (t) {
            n.setupView(i, t)
          },
          pushLight: function (t) {
            i.push(t)
          },
          pushShadow: function (t) {
            r.push(t)
          },
        }
      }
      function vp(t, e) {
        let n = new WeakMap()
        return {
          get: function (i, r = 0) {
            let s
            return (
              !1 === n.has(i)
                ? ((s = new gp(t, e)), n.set(i, [s]))
                : r >= n.get(i).length
                ? ((s = new gp(t, e)), n.get(i).push(s))
                : (s = n.get(i)[r]),
              s
            )
          },
          dispose: function () {
            n = new WeakMap()
          },
        }
      }
      class _p extends Uc {
        constructor(t) {
          super(),
            (this.type = 'MeshDepthMaterial'),
            (this.depthPacking = 3200),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            this.setValues(t)
        }
        copy(t) {
          return (
            super.copy(t),
            (this.depthPacking = t.depthPacking),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            this
          )
        }
      }
      _p.prototype.isMeshDepthMaterial = !0
      class yp extends Uc {
        constructor(t) {
          super(),
            (this.type = 'MeshDistanceMaterial'),
            (this.referencePosition = new Tl()),
            (this.nearDistance = 1),
            (this.farDistance = 1e3),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.fog = !1),
            this.setValues(t)
        }
        copy(t) {
          return (
            super.copy(t),
            this.referencePosition.copy(t.referencePosition),
            (this.nearDistance = t.nearDistance),
            (this.farDistance = t.farDistance),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            this
          )
        }
      }
      function xp(t, e, n) {
        let i = new ju()
        const r = new dl(),
          s = new dl(),
          o = new bl(),
          a = new _p({ depthPacking: 3201 }),
          l = new yp(),
          c = {},
          u = n.maxTextureSize,
          h = { 0: 1, 1: 0, 2: 2 },
          d = new Pu({
            uniforms: {
              shadow_pass: { value: null },
              resolution: { value: new dl() },
              radius: { value: 4 },
              samples: { value: 8 },
            },
            vertexShader:
              'void main() {\n\tgl_Position = vec4( position, 1.0 );\n}',
            fragmentShader:
              'uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\nuniform float samples;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}',
          }),
          p = d.clone()
        p.defines.HORIZONTAL_PASS = 1
        const f = new lu()
        f.setAttribute(
          'position',
          new Kc(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3),
        )
        const m = new Eu(f, d),
          g = this
        function v(n, i) {
          const r = e.update(m)
          ;(d.uniforms.shadow_pass.value = n.map.texture),
            (d.uniforms.resolution.value = n.mapSize),
            (d.uniforms.radius.value = n.radius),
            (d.uniforms.samples.value = n.blurSamples),
            t.setRenderTarget(n.mapPass),
            t.clear(),
            t.renderBufferDirect(i, null, r, d, m, null),
            (p.uniforms.shadow_pass.value = n.mapPass.texture),
            (p.uniforms.resolution.value = n.mapSize),
            (p.uniforms.radius.value = n.radius),
            (p.uniforms.samples.value = n.blurSamples),
            t.setRenderTarget(n.map),
            t.clear(),
            t.renderBufferDirect(i, null, r, p, m, null)
        }
        function _(e, n, i, r, s, o, u) {
          let d = null
          const p =
            !0 === r.isPointLight
              ? e.customDistanceMaterial
              : e.customDepthMaterial
          if (
            ((d = void 0 !== p ? p : !0 === r.isPointLight ? l : a),
            (t.localClippingEnabled &&
              !0 === i.clipShadows &&
              0 !== i.clippingPlanes.length) ||
              (i.displacementMap && 0 !== i.displacementScale) ||
              (i.alphaMap && i.alphaTest > 0))
          ) {
            const t = d.uuid,
              e = i.uuid
            let n = c[t]
            void 0 === n && ((n = {}), (c[t] = n))
            let r = n[e]
            void 0 === r && ((r = d.clone()), (n[e] = r)), (d = r)
          }
          return (
            (d.visible = i.visible),
            (d.wireframe = i.wireframe),
            (d.side =
              3 === u
                ? null !== i.shadowSide
                  ? i.shadowSide
                  : i.side
                : null !== i.shadowSide
                ? i.shadowSide
                : h[i.side]),
            (d.alphaMap = i.alphaMap),
            (d.alphaTest = i.alphaTest),
            (d.clipShadows = i.clipShadows),
            (d.clippingPlanes = i.clippingPlanes),
            (d.clipIntersection = i.clipIntersection),
            (d.displacementMap = i.displacementMap),
            (d.displacementScale = i.displacementScale),
            (d.displacementBias = i.displacementBias),
            (d.wireframeLinewidth = i.wireframeLinewidth),
            (d.linewidth = i.linewidth),
            !0 === r.isPointLight &&
              !0 === d.isMeshDistanceMaterial &&
              (d.referencePosition.setFromMatrixPosition(r.matrixWorld),
              (d.nearDistance = s),
              (d.farDistance = o)),
            d
          )
        }
        function y(n, r, s, o, a) {
          if (!1 === n.visible) return
          if (
            n.layers.test(r.layers) &&
            (n.isMesh || n.isLine || n.isPoints) &&
            (n.castShadow || (n.receiveShadow && 3 === a)) &&
            (!n.frustumCulled || i.intersectsObject(n))
          ) {
            n.modelViewMatrix.multiplyMatrices(
              s.matrixWorldInverse,
              n.matrixWorld,
            )
            const i = e.update(n),
              r = n.material
            if (Array.isArray(r)) {
              const e = i.groups
              for (let l = 0, c = e.length; l < c; l++) {
                const c = e[l],
                  u = r[c.materialIndex]
                if (u && u.visible) {
                  const e = _(n, 0, u, o, s.near, s.far, a)
                  t.renderBufferDirect(s, null, i, e, n, c)
                }
              }
            } else if (r.visible) {
              const e = _(n, 0, r, o, s.near, s.far, a)
              t.renderBufferDirect(s, null, i, e, n, null)
            }
          }
          const l = n.children
          for (let t = 0, e = l.length; t < e; t++) y(l[t], r, s, o, a)
        }
        ;(this.enabled = !1),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this.type = 1),
          (this.render = function (e, n, a) {
            if (!1 === g.enabled) return
            if (!1 === g.autoUpdate && !1 === g.needsUpdate) return
            if (0 === e.length) return
            const l = t.getRenderTarget(),
              c = t.getActiveCubeFace(),
              h = t.getActiveMipmapLevel(),
              d = t.state
            d.setBlending(0),
              d.buffers.color.setClear(1, 1, 1, 1),
              d.buffers.depth.setTest(!0),
              d.setScissorTest(!1)
            for (let l = 0, c = e.length; l < c; l++) {
              const c = e[l],
                h = c.shadow
              if (void 0 === h) {
                console.warn('THREE.WebGLShadowMap:', c, 'has no shadow.')
                continue
              }
              if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue
              r.copy(h.mapSize)
              const p = h.getFrameExtents()
              if (
                (r.multiply(p),
                s.copy(h.mapSize),
                (r.x > u || r.y > u) &&
                  (r.x > u &&
                    ((s.x = Math.floor(u / p.x)),
                    (r.x = s.x * p.x),
                    (h.mapSize.x = s.x)),
                  r.y > u &&
                    ((s.y = Math.floor(u / p.y)),
                    (r.y = s.y * p.y),
                    (h.mapSize.y = s.y))),
                null === h.map && !h.isPointLightShadow && 3 === this.type)
              ) {
                const t = { minFilter: Ea, magFilter: Ea, format: Oa }
                ;(h.map = new wl(r.x, r.y, t)),
                  (h.map.texture.name = c.name + '.shadowMap'),
                  (h.mapPass = new wl(r.x, r.y, t)),
                  h.camera.updateProjectionMatrix()
              }
              if (null === h.map) {
                const t = { minFilter: Ma, magFilter: Ma, format: Oa }
                ;(h.map = new wl(r.x, r.y, t)),
                  (h.map.texture.name = c.name + '.shadowMap'),
                  h.camera.updateProjectionMatrix()
              }
              t.setRenderTarget(h.map), t.clear()
              const f = h.getViewportCount()
              for (let t = 0; t < f; t++) {
                const e = h.getViewport(t)
                o.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w),
                  d.viewport(o),
                  h.updateMatrices(c, t),
                  (i = h.getFrustum()),
                  y(n, a, h.camera, c, this.type)
              }
              h.isPointLightShadow || 3 !== this.type || v(h, a),
                (h.needsUpdate = !1)
            }
            ;(g.needsUpdate = !1), t.setRenderTarget(l, c, h)
          })
      }
      function bp(t, e, n) {
        const i = n.isWebGL2,
          r = new (function () {
            let e = !1
            const n = new bl()
            let i = null
            const r = new bl(0, 0, 0, 0)
            return {
              setMask: function (n) {
                i === n || e || (t.colorMask(n, n, n, n), (i = n))
              },
              setLocked: function (t) {
                e = t
              },
              setClear: function (e, i, s, o, a) {
                !0 === a && ((e *= o), (i *= o), (s *= o)),
                  n.set(e, i, s, o),
                  !1 === r.equals(n) && (t.clearColor(e, i, s, o), r.copy(n))
              },
              reset: function () {
                ;(e = !1), (i = null), r.set(-1, 0, 0, 0)
              },
            }
          })(),
          s = new (function () {
            let e = !1,
              n = null,
              i = null,
              r = null
            return {
              setTest: function (t) {
                t ? k(2929) : B(2929)
              },
              setMask: function (i) {
                n === i || e || (t.depthMask(i), (n = i))
              },
              setFunc: function (e) {
                if (i !== e) {
                  if (e)
                    switch (e) {
                      case 0:
                        t.depthFunc(512)
                        break
                      case 1:
                        t.depthFunc(519)
                        break
                      case 2:
                        t.depthFunc(513)
                        break
                      case 3:
                      default:
                        t.depthFunc(515)
                        break
                      case 4:
                        t.depthFunc(514)
                        break
                      case 5:
                        t.depthFunc(518)
                        break
                      case 6:
                        t.depthFunc(516)
                        break
                      case 7:
                        t.depthFunc(517)
                    }
                  else t.depthFunc(515)
                  i = e
                }
              },
              setLocked: function (t) {
                e = t
              },
              setClear: function (e) {
                r !== e && (t.clearDepth(e), (r = e))
              },
              reset: function () {
                ;(e = !1), (n = null), (i = null), (r = null)
              },
            }
          })(),
          o = new (function () {
            let e = !1,
              n = null,
              i = null,
              r = null,
              s = null,
              o = null,
              a = null,
              l = null,
              c = null
            return {
              setTest: function (t) {
                e || (t ? k(2960) : B(2960))
              },
              setMask: function (i) {
                n === i || e || (t.stencilMask(i), (n = i))
              },
              setFunc: function (e, n, o) {
                ;(i === e && r === n && s === o) ||
                  (t.stencilFunc(e, n, o), (i = e), (r = n), (s = o))
              },
              setOp: function (e, n, i) {
                ;(o === e && a === n && l === i) ||
                  (t.stencilOp(e, n, i), (o = e), (a = n), (l = i))
              },
              setLocked: function (t) {
                e = t
              },
              setClear: function (e) {
                c !== e && (t.clearStencil(e), (c = e))
              },
              reset: function () {
                ;(e = !1),
                  (n = null),
                  (i = null),
                  (r = null),
                  (s = null),
                  (o = null),
                  (a = null),
                  (l = null),
                  (c = null)
              },
            }
          })()
        let a = {},
          l = null,
          c = {},
          u = null,
          h = !1,
          d = null,
          p = null,
          f = null,
          m = null,
          g = null,
          v = null,
          _ = null,
          y = !1,
          x = null,
          b = null,
          w = null,
          M = null,
          S = null
        const T = t.getParameter(35661)
        let E = !1,
          D = 0
        const A = t.getParameter(7938)
        ;-1 !== A.indexOf('WebGL')
          ? ((D = parseFloat(/^WebGL (\d)/.exec(A)[1])), (E = D >= 1))
          : -1 !== A.indexOf('OpenGL ES') &&
            ((D = parseFloat(/^OpenGL ES (\d)/.exec(A)[1])), (E = D >= 2))
        let C = null,
          L = {}
        const R = t.getParameter(3088),
          P = t.getParameter(2978),
          F = new bl().fromArray(R),
          I = new bl().fromArray(P)
        function O(e, n, i) {
          const r = new Uint8Array(4),
            s = t.createTexture()
          t.bindTexture(e, s),
            t.texParameteri(e, 10241, 9728),
            t.texParameteri(e, 10240, 9728)
          for (let e = 0; e < i; e++)
            t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r)
          return s
        }
        const N = {}
        function k(e) {
          !0 !== a[e] && (t.enable(e), (a[e] = !0))
        }
        function B(e) {
          !1 !== a[e] && (t.disable(e), (a[e] = !1))
        }
        ;(N[3553] = O(3553, 3553, 1)),
          (N[34067] = O(34067, 34069, 6)),
          r.setClear(0, 0, 0, 1),
          s.setClear(1),
          o.setClear(0),
          k(2929),
          s.setFunc(3),
          G(!1),
          V(1),
          k(2884),
          H(0)
        const z = { [ga]: 32774, 101: 32778, 102: 32779 }
        if (i) (z[103] = 32775), (z[104] = 32776)
        else {
          const t = e.get('EXT_blend_minmax')
          null !== t && ((z[103] = t.MIN_EXT), (z[104] = t.MAX_EXT))
        }
        const U = {
          200: 0,
          201: 1,
          202: 768,
          204: 770,
          210: 776,
          208: 774,
          206: 772,
          203: 769,
          205: 771,
          209: 775,
          207: 773,
        }
        function H(e, n, i, r, s, o, a, l) {
          if (0 !== e) {
            if ((!1 === h && (k(3042), (h = !0)), 5 === e))
              (s = s || n),
                (o = o || i),
                (a = a || r),
                (n === p && s === g) ||
                  (t.blendEquationSeparate(z[n], z[s]), (p = n), (g = s)),
                (i === f && r === m && o === v && a === _) ||
                  (t.blendFuncSeparate(U[i], U[r], U[o], U[a]),
                  (f = i),
                  (m = r),
                  (v = o),
                  (_ = a)),
                (d = e),
                (y = null)
            else if (e !== d || l !== y) {
              if (
                ((p === ga && g === ga) ||
                  (t.blendEquation(32774), (p = ga), (g = ga)),
                l)
              )
                switch (e) {
                  case 1:
                    t.blendFuncSeparate(1, 771, 1, 771)
                    break
                  case 2:
                    t.blendFunc(1, 1)
                    break
                  case 3:
                    t.blendFuncSeparate(0, 0, 769, 771)
                    break
                  case 4:
                    t.blendFuncSeparate(0, 768, 0, 770)
                    break
                  default:
                    console.error('THREE.WebGLState: Invalid blending: ', e)
                }
              else
                switch (e) {
                  case 1:
                    t.blendFuncSeparate(770, 771, 1, 771)
                    break
                  case 2:
                    t.blendFunc(770, 1)
                    break
                  case 3:
                    t.blendFunc(0, 769)
                    break
                  case 4:
                    t.blendFunc(0, 768)
                    break
                  default:
                    console.error('THREE.WebGLState: Invalid blending: ', e)
                }
              ;(f = null), (m = null), (v = null), (_ = null), (d = e), (y = l)
            }
          } else !0 === h && (B(3042), (h = !1))
        }
        function G(e) {
          x !== e && (e ? t.frontFace(2304) : t.frontFace(2305), (x = e))
        }
        function V(e) {
          0 !== e
            ? (k(2884),
              e !== b &&
                (1 === e
                  ? t.cullFace(1029)
                  : 2 === e
                  ? t.cullFace(1028)
                  : t.cullFace(1032)))
            : B(2884),
            (b = e)
        }
        function W(e, n, i) {
          e
            ? (k(32823),
              (M === n && S === i) || (t.polygonOffset(n, i), (M = n), (S = i)))
            : B(32823)
        }
        function j(e) {
          void 0 === e && (e = 33984 + T - 1),
            C !== e && (t.activeTexture(e), (C = e))
        }
        return {
          buffers: { color: r, depth: s, stencil: o },
          enable: k,
          disable: B,
          bindFramebuffer: function (e, n) {
            return (
              null === n && null !== l && (n = l),
              c[e] !== n &&
                (t.bindFramebuffer(e, n),
                (c[e] = n),
                i &&
                  (36009 === e && (c[36160] = n),
                  36160 === e && (c[36009] = n)),
                !0)
            )
          },
          bindXRFramebuffer: function (e) {
            e !== l && (t.bindFramebuffer(36160, e), (l = e))
          },
          useProgram: function (e) {
            return u !== e && (t.useProgram(e), (u = e), !0)
          },
          setBlending: H,
          setMaterial: function (t, e) {
            2 === t.side ? B(2884) : k(2884)
            let n = 1 === t.side
            e && (n = !n),
              G(n),
              1 === t.blending && !1 === t.transparent
                ? H(0)
                : H(
                    t.blending,
                    t.blendEquation,
                    t.blendSrc,
                    t.blendDst,
                    t.blendEquationAlpha,
                    t.blendSrcAlpha,
                    t.blendDstAlpha,
                    t.premultipliedAlpha,
                  ),
              s.setFunc(t.depthFunc),
              s.setTest(t.depthTest),
              s.setMask(t.depthWrite),
              r.setMask(t.colorWrite)
            const i = t.stencilWrite
            o.setTest(i),
              i &&
                (o.setMask(t.stencilWriteMask),
                o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
              W(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
              !0 === t.alphaToCoverage ? k(32926) : B(32926)
          },
          setFlipSided: G,
          setCullFace: V,
          setLineWidth: function (e) {
            e !== w && (E && t.lineWidth(e), (w = e))
          },
          setPolygonOffset: W,
          setScissorTest: function (t) {
            t ? k(3089) : B(3089)
          },
          activeTexture: j,
          bindTexture: function (e, n) {
            null === C && j()
            let i = L[C]
            void 0 === i &&
              ((i = { type: void 0, texture: void 0 }), (L[C] = i)),
              (i.type === e && i.texture === n) ||
                (t.bindTexture(e, n || N[e]), (i.type = e), (i.texture = n))
          },
          unbindTexture: function () {
            const e = L[C]
            void 0 !== e &&
              void 0 !== e.type &&
              (t.bindTexture(e.type, null),
              (e.type = void 0),
              (e.texture = void 0))
          },
          compressedTexImage2D: function () {
            try {
              t.compressedTexImage2D.apply(t, arguments)
            } catch (t) {
              console.error('THREE.WebGLState:', t)
            }
          },
          texImage2D: function () {
            try {
              t.texImage2D.apply(t, arguments)
            } catch (t) {
              console.error('THREE.WebGLState:', t)
            }
          },
          texImage3D: function () {
            try {
              t.texImage3D.apply(t, arguments)
            } catch (t) {
              console.error('THREE.WebGLState:', t)
            }
          },
          scissor: function (e) {
            !1 === F.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), F.copy(e))
          },
          viewport: function (e) {
            !1 === I.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), I.copy(e))
          },
          reset: function () {
            t.disable(3042),
              t.disable(2884),
              t.disable(2929),
              t.disable(32823),
              t.disable(3089),
              t.disable(2960),
              t.disable(32926),
              t.blendEquation(32774),
              t.blendFunc(1, 0),
              t.blendFuncSeparate(1, 0, 1, 0),
              t.colorMask(!0, !0, !0, !0),
              t.clearColor(0, 0, 0, 0),
              t.depthMask(!0),
              t.depthFunc(513),
              t.clearDepth(1),
              t.stencilMask(4294967295),
              t.stencilFunc(519, 0, 4294967295),
              t.stencilOp(7680, 7680, 7680),
              t.clearStencil(0),
              t.cullFace(1029),
              t.frontFace(2305),
              t.polygonOffset(0, 0),
              t.activeTexture(33984),
              t.bindFramebuffer(36160, null),
              !0 === i &&
                (t.bindFramebuffer(36009, null),
                t.bindFramebuffer(36008, null)),
              t.useProgram(null),
              t.lineWidth(1),
              t.scissor(0, 0, t.canvas.width, t.canvas.height),
              t.viewport(0, 0, t.canvas.width, t.canvas.height),
              (a = {}),
              (C = null),
              (L = {}),
              (l = null),
              (c = {}),
              (u = null),
              (h = !1),
              (d = null),
              (p = null),
              (f = null),
              (m = null),
              (g = null),
              (v = null),
              (_ = null),
              (y = !1),
              (x = null),
              (b = null),
              (w = null),
              (M = null),
              (S = null),
              F.set(0, 0, t.canvas.width, t.canvas.height),
              I.set(0, 0, t.canvas.width, t.canvas.height),
              r.reset(),
              s.reset(),
              o.reset()
          },
        }
      }
      function wp(t, e, n, i, r, s, o) {
        const a = r.isWebGL2,
          l = r.maxTextures,
          c = r.maxCubemapSize,
          u = r.maxTextureSize,
          h = r.maxSamples,
          d = new WeakMap()
        let p,
          f = !1
        try {
          f =
            'undefined' != typeof OffscreenCanvas &&
            null !== new OffscreenCanvas(1, 1).getContext('2d')
        } catch (t) {}
        function m(t, e) {
          return f ? new OffscreenCanvas(t, e) : ml('canvas')
        }
        function g(t, e, n, i) {
          let r = 1
          if (
            ((t.width > i || t.height > i) &&
              (r = i / Math.max(t.width, t.height)),
            r < 1 || !0 === e)
          ) {
            if (
              ('undefined' != typeof HTMLImageElement &&
                t instanceof HTMLImageElement) ||
              ('undefined' != typeof HTMLCanvasElement &&
                t instanceof HTMLCanvasElement) ||
              ('undefined' != typeof ImageBitmap && t instanceof ImageBitmap)
            ) {
              const i = e ? ul : Math.floor,
                s = i(r * t.width),
                o = i(r * t.height)
              void 0 === p && (p = m(s, o))
              const a = n ? m(s, o) : p
              return (
                (a.width = s),
                (a.height = o),
                a.getContext('2d').drawImage(t, 0, 0, s, o),
                console.warn(
                  'THREE.WebGLRenderer: Texture has been resized from (' +
                    t.width +
                    'x' +
                    t.height +
                    ') to (' +
                    s +
                    'x' +
                    o +
                    ').',
                ),
                a
              )
            }
            return (
              'data' in t &&
                console.warn(
                  'THREE.WebGLRenderer: Image in DataTexture is too big (' +
                    t.width +
                    'x' +
                    t.height +
                    ').',
                ),
              t
            )
          }
          return t
        }
        function v(t) {
          return ll(t.width) && ll(t.height)
        }
        function _(t, e) {
          return (
            t.generateMipmaps && e && t.minFilter !== Ma && t.minFilter !== Ea
          )
        }
        function y(e, n, r, s, o = 1) {
          t.generateMipmap(e),
            (i.get(n).__maxMipLevel = Math.log2(Math.max(r, s, o)))
        }
        function x(n, i, r, s) {
          if (!1 === a) return i
          if (null !== n) {
            if (void 0 !== t[n]) return t[n]
            console.warn(
              "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                n +
                "'",
            )
          }
          let o = i
          return (
            6403 === i &&
              (5126 === r && (o = 33326),
              5131 === r && (o = 33325),
              5121 === r && (o = 33321)),
            6407 === i &&
              (5126 === r && (o = 34837),
              5131 === r && (o = 34843),
              5121 === r && (o = 32849)),
            6408 === i &&
              (5126 === r && (o = 34836),
              5131 === r && (o = 34842),
              5121 === r && (o = s === ja ? 35907 : 32856)),
            (33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o) ||
              e.get('EXT_color_buffer_float'),
            o
          )
        }
        function b(t) {
          return t === Ma || t === Sa || t === Ta ? 9728 : 9729
        }
        function w(e) {
          const n = e.target
          n.removeEventListener('dispose', w),
            (function (e) {
              const n = i.get(e)
              void 0 !== n.__webglInit &&
                (t.deleteTexture(n.__webglTexture), i.remove(e))
            })(n),
            n.isVideoTexture && d.delete(n),
            o.memory.textures--
        }
        function M(e) {
          const n = e.target
          n.removeEventListener('dispose', M),
            (function (e) {
              const n = e.texture,
                r = i.get(e),
                s = i.get(n)
              if (e) {
                if (
                  (void 0 !== s.__webglTexture &&
                    (t.deleteTexture(s.__webglTexture), o.memory.textures--),
                  e.depthTexture && e.depthTexture.dispose(),
                  e.isWebGLCubeRenderTarget)
                )
                  for (let e = 0; e < 6; e++)
                    t.deleteFramebuffer(r.__webglFramebuffer[e]),
                      r.__webglDepthbuffer &&
                        t.deleteRenderbuffer(r.__webglDepthbuffer[e])
                else
                  t.deleteFramebuffer(r.__webglFramebuffer),
                    r.__webglDepthbuffer &&
                      t.deleteRenderbuffer(r.__webglDepthbuffer),
                    r.__webglMultisampledFramebuffer &&
                      t.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                    r.__webglColorRenderbuffer &&
                      t.deleteRenderbuffer(r.__webglColorRenderbuffer),
                    r.__webglDepthRenderbuffer &&
                      t.deleteRenderbuffer(r.__webglDepthRenderbuffer)
                if (e.isWebGLMultipleRenderTargets)
                  for (let e = 0, r = n.length; e < r; e++) {
                    const r = i.get(n[e])
                    r.__webglTexture &&
                      (t.deleteTexture(r.__webglTexture), o.memory.textures--),
                      i.remove(n[e])
                  }
                i.remove(n), i.remove(e)
              }
            })(n)
        }
        let S = 0
        function T(t, e) {
          const r = i.get(t)
          if (
            (t.isVideoTexture &&
              (function (t) {
                const e = o.render.frame
                d.get(t) !== e && (d.set(t, e), t.update())
              })(t),
            t.version > 0 && r.__version !== t.version)
          ) {
            const n = t.image
            if (void 0 === n)
              console.warn(
                'THREE.WebGLRenderer: Texture marked for update but image is undefined',
              )
            else {
              if (!1 !== n.complete) return void R(r, t, e)
              console.warn(
                'THREE.WebGLRenderer: Texture marked for update but image is incomplete',
              )
            }
          }
          n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture)
        }
        function E(e, r) {
          const o = i.get(e)
          e.version > 0 && o.__version !== e.version
            ? (function (e, i, r) {
                if (6 !== i.image.length) return
                L(e, i),
                  n.activeTexture(33984 + r),
                  n.bindTexture(34067, e.__webglTexture),
                  t.pixelStorei(37440, i.flipY),
                  t.pixelStorei(37441, i.premultiplyAlpha),
                  t.pixelStorei(3317, i.unpackAlignment),
                  t.pixelStorei(37443, 0)
                const o =
                    i &&
                    (i.isCompressedTexture || i.image[0].isCompressedTexture),
                  l = i.image[0] && i.image[0].isDataTexture,
                  u = []
                for (let t = 0; t < 6; t++)
                  u[t] =
                    o || l
                      ? l
                        ? i.image[t].image
                        : i.image[t]
                      : g(i.image[t], !1, !0, c)
                const h = u[0],
                  d = v(h) || a,
                  p = s.convert(i.format),
                  f = s.convert(i.type),
                  m = x(i.internalFormat, p, f, i.encoding)
                let b
                if ((C(34067, i, d), o)) {
                  for (let t = 0; t < 6; t++) {
                    b = u[t].mipmaps
                    for (let e = 0; e < b.length; e++) {
                      const r = b[e]
                      i.format !== Oa && i.format !== Ia
                        ? null !== p
                          ? n.compressedTexImage2D(
                              34069 + t,
                              e,
                              m,
                              r.width,
                              r.height,
                              0,
                              r.data,
                            )
                          : console.warn(
                              'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()',
                            )
                        : n.texImage2D(
                            34069 + t,
                            e,
                            m,
                            r.width,
                            r.height,
                            0,
                            p,
                            f,
                            r.data,
                          )
                    }
                  }
                  e.__maxMipLevel = b.length - 1
                } else {
                  b = i.mipmaps
                  for (let t = 0; t < 6; t++)
                    if (l) {
                      n.texImage2D(
                        34069 + t,
                        0,
                        m,
                        u[t].width,
                        u[t].height,
                        0,
                        p,
                        f,
                        u[t].data,
                      )
                      for (let e = 0; e < b.length; e++) {
                        const i = b[e].image[t].image
                        n.texImage2D(
                          34069 + t,
                          e + 1,
                          m,
                          i.width,
                          i.height,
                          0,
                          p,
                          f,
                          i.data,
                        )
                      }
                    } else {
                      n.texImage2D(34069 + t, 0, m, p, f, u[t])
                      for (let e = 0; e < b.length; e++) {
                        const i = b[e]
                        n.texImage2D(34069 + t, e + 1, m, p, f, i.image[t])
                      }
                    }
                  e.__maxMipLevel = b.length
                }
                _(i, d) && y(34067, i, h.width, h.height),
                  (e.__version = i.version),
                  i.onUpdate && i.onUpdate(i)
              })(o, e, r)
            : (n.activeTexture(33984 + r),
              n.bindTexture(34067, o.__webglTexture))
        }
        const D = { [xa]: 10497, [ba]: 33071, [wa]: 33648 },
          A = {
            [Ma]: 9728,
            [Sa]: 9984,
            [Ta]: 9986,
            [Ea]: 9729,
            1007: 9985,
            [Da]: 9987,
          }
        function C(n, s, o) {
          if (
            (o
              ? (t.texParameteri(n, 10242, D[s.wrapS]),
                t.texParameteri(n, 10243, D[s.wrapT]),
                (32879 !== n && 35866 !== n) ||
                  t.texParameteri(n, 32882, D[s.wrapR]),
                t.texParameteri(n, 10240, A[s.magFilter]),
                t.texParameteri(n, 10241, A[s.minFilter]))
              : (t.texParameteri(n, 10242, 33071),
                t.texParameteri(n, 10243, 33071),
                (32879 !== n && 35866 !== n) ||
                  t.texParameteri(n, 32882, 33071),
                (s.wrapS === ba && s.wrapT === ba) ||
                  console.warn(
                    'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.',
                  ),
                t.texParameteri(n, 10240, b(s.magFilter)),
                t.texParameteri(n, 10241, b(s.minFilter)),
                s.minFilter !== Ma &&
                  s.minFilter !== Ea &&
                  console.warn(
                    'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.',
                  )),
            !0 === e.has('EXT_texture_filter_anisotropic'))
          ) {
            const o = e.get('EXT_texture_filter_anisotropic')
            if (s.type === Ra && !1 === e.has('OES_texture_float_linear'))
              return
            if (
              !1 === a &&
              s.type === Pa &&
              !1 === e.has('OES_texture_half_float_linear')
            )
              return
            ;(s.anisotropy > 1 || i.get(s).__currentAnisotropy) &&
              (t.texParameterf(
                n,
                o.TEXTURE_MAX_ANISOTROPY_EXT,
                Math.min(s.anisotropy, r.getMaxAnisotropy()),
              ),
              (i.get(s).__currentAnisotropy = s.anisotropy))
          }
        }
        function L(e, n) {
          void 0 === e.__webglInit &&
            ((e.__webglInit = !0),
            n.addEventListener('dispose', w),
            (e.__webglTexture = t.createTexture()),
            o.memory.textures++)
        }
        function R(e, i, r) {
          let o = 3553
          i.isDataTexture2DArray && (o = 35866),
            i.isDataTexture3D && (o = 32879),
            L(e, i),
            n.activeTexture(33984 + r),
            n.bindTexture(o, e.__webglTexture),
            t.pixelStorei(37440, i.flipY),
            t.pixelStorei(37441, i.premultiplyAlpha),
            t.pixelStorei(3317, i.unpackAlignment),
            t.pixelStorei(37443, 0)
          const l =
              (function (t) {
                return (
                  !a &&
                  (t.wrapS !== ba ||
                    t.wrapT !== ba ||
                    (t.minFilter !== Ma && t.minFilter !== Ea))
                )
              })(i) && !1 === v(i.image),
            c = g(i.image, l, !1, u),
            h = v(c) || a,
            d = s.convert(i.format)
          let p,
            f = s.convert(i.type),
            m = x(i.internalFormat, d, f, i.encoding)
          C(o, i, h)
          const b = i.mipmaps
          if (i.isDepthTexture)
            (m = 6402),
              a
                ? (m =
                    i.type === Ra
                      ? 36012
                      : i.type === La
                      ? 33190
                      : i.type === Fa
                      ? 35056
                      : 33189)
                : i.type === Ra &&
                  console.error(
                    'WebGLRenderer: Floating point depth texture requires WebGL2.',
                  ),
              i.format === Na &&
                6402 === m &&
                i.type !== Ca &&
                i.type !== La &&
                (console.warn(
                  'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.',
                ),
                (i.type = Ca),
                (f = s.convert(i.type))),
              i.format === ka &&
                6402 === m &&
                ((m = 34041),
                i.type !== Fa &&
                  (console.warn(
                    'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.',
                  ),
                  (i.type = Fa),
                  (f = s.convert(i.type)))),
              n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, null)
          else if (i.isDataTexture)
            if (b.length > 0 && h) {
              for (let t = 0, e = b.length; t < e; t++)
                (p = b[t]),
                  n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data)
              ;(i.generateMipmaps = !1), (e.__maxMipLevel = b.length - 1)
            } else
              n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, c.data),
                (e.__maxMipLevel = 0)
          else if (i.isCompressedTexture) {
            for (let t = 0, e = b.length; t < e; t++)
              (p = b[t]),
                i.format !== Oa && i.format !== Ia
                  ? null !== d
                    ? n.compressedTexImage2D(
                        3553,
                        t,
                        m,
                        p.width,
                        p.height,
                        0,
                        p.data,
                      )
                    : console.warn(
                        'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()',
                      )
                  : n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data)
            e.__maxMipLevel = b.length - 1
          } else if (i.isDataTexture2DArray)
            n.texImage3D(
              35866,
              0,
              m,
              c.width,
              c.height,
              c.depth,
              0,
              d,
              f,
              c.data,
            ),
              (e.__maxMipLevel = 0)
          else if (i.isDataTexture3D)
            n.texImage3D(
              32879,
              0,
              m,
              c.width,
              c.height,
              c.depth,
              0,
              d,
              f,
              c.data,
            ),
              (e.__maxMipLevel = 0)
          else if (b.length > 0 && h) {
            for (let t = 0, e = b.length; t < e; t++)
              (p = b[t]), n.texImage2D(3553, t, m, d, f, p)
            ;(i.generateMipmaps = !1), (e.__maxMipLevel = b.length - 1)
          } else n.texImage2D(3553, 0, m, d, f, c), (e.__maxMipLevel = 0)
          _(i, h) && y(o, i, c.width, c.height),
            (e.__version = i.version),
            i.onUpdate && i.onUpdate(i)
        }
        function P(e, r, o, a, l) {
          const c = s.convert(o.format),
            u = s.convert(o.type),
            h = x(o.internalFormat, c, u, o.encoding)
          32879 === l || 35866 === l
            ? n.texImage3D(l, 0, h, r.width, r.height, r.depth, 0, c, u, null)
            : n.texImage2D(l, 0, h, r.width, r.height, 0, c, u, null),
            n.bindFramebuffer(36160, e),
            t.framebufferTexture2D(36160, a, l, i.get(o).__webglTexture, 0),
            n.bindFramebuffer(36160, null)
        }
        function F(e, n, i) {
          if (
            (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer)
          ) {
            let r = 33189
            if (i) {
              const e = n.depthTexture
              e &&
                e.isDepthTexture &&
                (e.type === Ra ? (r = 36012) : e.type === La && (r = 33190))
              const i = I(n)
              t.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
            } else t.renderbufferStorage(36161, r, n.width, n.height)
            t.framebufferRenderbuffer(36160, 36096, 36161, e)
          } else if (n.depthBuffer && n.stencilBuffer) {
            if (i) {
              const e = I(n)
              t.renderbufferStorageMultisample(
                36161,
                e,
                35056,
                n.width,
                n.height,
              )
            } else t.renderbufferStorage(36161, 34041, n.width, n.height)
            t.framebufferRenderbuffer(36160, 33306, 36161, e)
          } else {
            const e =
                !0 === n.isWebGLMultipleRenderTargets
                  ? n.texture[0]
                  : n.texture,
              r = s.convert(e.format),
              o = s.convert(e.type),
              a = x(e.internalFormat, r, o, e.encoding)
            if (i) {
              const e = I(n)
              t.renderbufferStorageMultisample(36161, e, a, n.width, n.height)
            } else t.renderbufferStorage(36161, a, n.width, n.height)
          }
          t.bindRenderbuffer(36161, null)
        }
        function I(t) {
          return a && t.isWebGLMultisampleRenderTarget
            ? Math.min(h, t.samples)
            : 0
        }
        let O = !1,
          N = !1
        ;(this.allocateTextureUnit = function () {
          const t = S
          return (
            t >= l &&
              console.warn(
                'THREE.WebGLTextures: Trying to use ' +
                  t +
                  ' texture units while this GPU supports only ' +
                  l,
              ),
            (S += 1),
            t
          )
        }),
          (this.resetTextureUnits = function () {
            S = 0
          }),
          (this.setTexture2D = T),
          (this.setTexture2DArray = function (t, e) {
            const r = i.get(t)
            t.version > 0 && r.__version !== t.version
              ? R(r, t, e)
              : (n.activeTexture(33984 + e),
                n.bindTexture(35866, r.__webglTexture))
          }),
          (this.setTexture3D = function (t, e) {
            const r = i.get(t)
            t.version > 0 && r.__version !== t.version
              ? R(r, t, e)
              : (n.activeTexture(33984 + e),
                n.bindTexture(32879, r.__webglTexture))
          }),
          (this.setTextureCube = E),
          (this.setupRenderTarget = function (e) {
            const l = e.texture,
              c = i.get(e),
              u = i.get(l)
            e.addEventListener('dispose', M),
              !0 !== e.isWebGLMultipleRenderTargets &&
                ((u.__webglTexture = t.createTexture()),
                (u.__version = l.version),
                o.memory.textures++)
            const h = !0 === e.isWebGLCubeRenderTarget,
              d = !0 === e.isWebGLMultipleRenderTargets,
              p = !0 === e.isWebGLMultisampleRenderTarget,
              f = l.isDataTexture3D || l.isDataTexture2DArray,
              m = v(e) || a
            if (
              (!a ||
                l.format !== Ia ||
                (l.type !== Ra && l.type !== Pa) ||
                ((l.format = Oa),
                console.warn(
                  'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.',
                )),
              h)
            ) {
              c.__webglFramebuffer = []
              for (let e = 0; e < 6; e++)
                c.__webglFramebuffer[e] = t.createFramebuffer()
            } else if (((c.__webglFramebuffer = t.createFramebuffer()), d))
              if (r.drawBuffers) {
                const n = e.texture
                for (let e = 0, r = n.length; e < r; e++) {
                  const r = i.get(n[e])
                  void 0 === r.__webglTexture &&
                    ((r.__webglTexture = t.createTexture()),
                    o.memory.textures++)
                }
              } else
                console.warn(
                  'THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.',
                )
            else if (p)
              if (a) {
                ;(c.__webglMultisampledFramebuffer = t.createFramebuffer()),
                  (c.__webglColorRenderbuffer = t.createRenderbuffer()),
                  t.bindRenderbuffer(36161, c.__webglColorRenderbuffer)
                const i = s.convert(l.format),
                  r = s.convert(l.type),
                  o = x(l.internalFormat, i, r, l.encoding),
                  a = I(e)
                t.renderbufferStorageMultisample(
                  36161,
                  a,
                  o,
                  e.width,
                  e.height,
                ),
                  n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer),
                  t.framebufferRenderbuffer(
                    36160,
                    36064,
                    36161,
                    c.__webglColorRenderbuffer,
                  ),
                  t.bindRenderbuffer(36161, null),
                  e.depthBuffer &&
                    ((c.__webglDepthRenderbuffer = t.createRenderbuffer()),
                    F(c.__webglDepthRenderbuffer, e, !0)),
                  n.bindFramebuffer(36160, null)
              } else
                console.warn(
                  'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.',
                )
            if (h) {
              n.bindTexture(34067, u.__webglTexture), C(34067, l, m)
              for (let t = 0; t < 6; t++)
                P(c.__webglFramebuffer[t], e, l, 36064, 34069 + t)
              _(l, m) && y(34067, l, e.width, e.height), n.unbindTexture()
            } else if (d) {
              const t = e.texture
              for (let r = 0, s = t.length; r < s; r++) {
                const s = t[r],
                  o = i.get(s)
                n.bindTexture(3553, o.__webglTexture),
                  C(3553, s, m),
                  P(c.__webglFramebuffer, e, s, 36064 + r, 3553),
                  _(s, m) && y(3553, s, e.width, e.height)
              }
              n.unbindTexture()
            } else {
              let t = 3553
              f &&
                (a
                  ? (t = l.isDataTexture3D ? 32879 : 35866)
                  : console.warn(
                      'THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.',
                    )),
                n.bindTexture(t, u.__webglTexture),
                C(t, l, m),
                P(c.__webglFramebuffer, e, l, 36064, t),
                _(l, m) && y(t, l, e.width, e.height, e.depth),
                n.unbindTexture()
            }
            e.depthBuffer &&
              (function (e) {
                const r = i.get(e),
                  s = !0 === e.isWebGLCubeRenderTarget
                if (e.depthTexture) {
                  if (s)
                    throw new Error(
                      'target.depthTexture not supported in Cube render targets',
                    )
                  !(function (e, r) {
                    if (r && r.isWebGLCubeRenderTarget)
                      throw new Error(
                        'Depth Texture with cube render targets is not supported',
                      )
                    if (
                      (n.bindFramebuffer(36160, e),
                      !r.depthTexture || !r.depthTexture.isDepthTexture)
                    )
                      throw new Error(
                        'renderTarget.depthTexture must be an instance of THREE.DepthTexture',
                      )
                    ;(i.get(r.depthTexture).__webglTexture &&
                      r.depthTexture.image.width === r.width &&
                      r.depthTexture.image.height === r.height) ||
                      ((r.depthTexture.image.width = r.width),
                      (r.depthTexture.image.height = r.height),
                      (r.depthTexture.needsUpdate = !0)),
                      T(r.depthTexture, 0)
                    const s = i.get(r.depthTexture).__webglTexture
                    if (r.depthTexture.format === Na)
                      t.framebufferTexture2D(36160, 36096, 3553, s, 0)
                    else {
                      if (r.depthTexture.format !== ka)
                        throw new Error('Unknown depthTexture format')
                      t.framebufferTexture2D(36160, 33306, 3553, s, 0)
                    }
                  })(r.__webglFramebuffer, e)
                } else if (s) {
                  r.__webglDepthbuffer = []
                  for (let i = 0; i < 6; i++)
                    n.bindFramebuffer(36160, r.__webglFramebuffer[i]),
                      (r.__webglDepthbuffer[i] = t.createRenderbuffer()),
                      F(r.__webglDepthbuffer[i], e, !1)
                } else
                  n.bindFramebuffer(36160, r.__webglFramebuffer),
                    (r.__webglDepthbuffer = t.createRenderbuffer()),
                    F(r.__webglDepthbuffer, e, !1)
                n.bindFramebuffer(36160, null)
              })(e)
          }),
          (this.updateRenderTargetMipmap = function (t) {
            const e = v(t) || a,
              r =
                !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture]
            for (let s = 0, o = r.length; s < o; s++) {
              const o = r[s]
              if (_(o, e)) {
                const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                  r = i.get(o).__webglTexture
                n.bindTexture(e, r),
                  y(e, o, t.width, t.height),
                  n.unbindTexture()
              }
            }
          }),
          (this.updateMultisampleRenderTarget = function (e) {
            if (e.isWebGLMultisampleRenderTarget)
              if (a) {
                const r = e.width,
                  s = e.height
                let o = 16384
                e.depthBuffer && (o |= 256), e.stencilBuffer && (o |= 1024)
                const a = i.get(e)
                n.bindFramebuffer(36008, a.__webglMultisampledFramebuffer),
                  n.bindFramebuffer(36009, a.__webglFramebuffer),
                  t.blitFramebuffer(0, 0, r, s, 0, 0, r, s, o, 9728),
                  n.bindFramebuffer(36008, null),
                  n.bindFramebuffer(36009, a.__webglMultisampledFramebuffer)
              } else
                console.warn(
                  'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.',
                )
          }),
          (this.safeSetTexture2D = function (t, e) {
            t &&
              t.isWebGLRenderTarget &&
              (!1 === O &&
                (console.warn(
                  "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.",
                ),
                (O = !0)),
              (t = t.texture)),
              T(t, e)
          }),
          (this.safeSetTextureCube = function (t, e) {
            t &&
              t.isWebGLCubeRenderTarget &&
              (!1 === N &&
                (console.warn(
                  "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.",
                ),
                (N = !0)),
              (t = t.texture)),
              E(t, e)
          })
      }
      function Mp(t, e, n) {
        const i = n.isWebGL2
        return {
          convert: function (t) {
            let n
            if (t === Aa) return 5121
            if (1017 === t) return 32819
            if (1018 === t) return 32820
            if (1019 === t) return 33635
            if (1010 === t) return 5120
            if (1011 === t) return 5122
            if (t === Ca) return 5123
            if (1013 === t) return 5124
            if (t === La) return 5125
            if (t === Ra) return 5126
            if (t === Pa)
              return i
                ? 5131
                : ((n = e.get('OES_texture_half_float')),
                  null !== n ? n.HALF_FLOAT_OES : null)
            if (1021 === t) return 6406
            if (t === Ia) return 6407
            if (t === Oa) return 6408
            if (1024 === t) return 6409
            if (1025 === t) return 6410
            if (t === Na) return 6402
            if (t === ka) return 34041
            if (1028 === t) return 6403
            if (1029 === t) return 36244
            if (1030 === t) return 33319
            if (1031 === t) return 33320
            if (1032 === t) return 36248
            if (1033 === t) return 36249
            if (33776 === t || 33777 === t || 33778 === t || 33779 === t) {
              if (((n = e.get('WEBGL_compressed_texture_s3tc')), null === n))
                return null
              if (33776 === t) return n.COMPRESSED_RGB_S3TC_DXT1_EXT
              if (33777 === t) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT
              if (33778 === t) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT
              if (33779 === t) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
            }
            if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
              if (((n = e.get('WEBGL_compressed_texture_pvrtc')), null === n))
                return null
              if (35840 === t) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
              if (35841 === t) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG
              if (35842 === t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
              if (35843 === t) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            }
            if (36196 === t)
              return (
                (n = e.get('WEBGL_compressed_texture_etc1')),
                null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null
              )
            if (
              (37492 === t || 37496 === t) &&
              ((n = e.get('WEBGL_compressed_texture_etc')), null !== n)
            ) {
              if (37492 === t) return n.COMPRESSED_RGB8_ETC2
              if (37496 === t) return n.COMPRESSED_RGBA8_ETC2_EAC
            }
            return 37808 === t ||
              37809 === t ||
              37810 === t ||
              37811 === t ||
              37812 === t ||
              37813 === t ||
              37814 === t ||
              37815 === t ||
              37816 === t ||
              37817 === t ||
              37818 === t ||
              37819 === t ||
              37820 === t ||
              37821 === t ||
              37840 === t ||
              37841 === t ||
              37842 === t ||
              37843 === t ||
              37844 === t ||
              37845 === t ||
              37846 === t ||
              37847 === t ||
              37848 === t ||
              37849 === t ||
              37850 === t ||
              37851 === t ||
              37852 === t ||
              37853 === t
              ? ((n = e.get('WEBGL_compressed_texture_astc')),
                null !== n ? t : null)
              : 36492 === t
              ? ((n = e.get('EXT_texture_compression_bptc')),
                null !== n ? t : null)
              : t === Fa
              ? i
                ? 34042
                : ((n = e.get('WEBGL_depth_texture')),
                  null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null)
              : void 0
          },
        }
      }
      yp.prototype.isMeshDistanceMaterial = !0
      class Sp extends Iu {
        constructor(t = []) {
          super(), (this.cameras = t)
        }
      }
      Sp.prototype.isArrayCamera = !0
      class Tp extends Dc {
        constructor() {
          super(), (this.type = 'Group')
        }
      }
      Tp.prototype.isGroup = !0
      const Ep = { type: 'move' }
      class Dp {
        constructor() {
          ;(this._targetRay = null), (this._grip = null), (this._hand = null)
        }
        getHandSpace() {
          return (
            null === this._hand &&
              ((this._hand = new Tp()),
              (this._hand.matrixAutoUpdate = !1),
              (this._hand.visible = !1),
              (this._hand.joints = {}),
              (this._hand.inputState = { pinching: !1 })),
            this._hand
          )
        }
        getTargetRaySpace() {
          return (
            null === this._targetRay &&
              ((this._targetRay = new Tp()),
              (this._targetRay.matrixAutoUpdate = !1),
              (this._targetRay.visible = !1),
              (this._targetRay.hasLinearVelocity = !1),
              (this._targetRay.linearVelocity = new Tl()),
              (this._targetRay.hasAngularVelocity = !1),
              (this._targetRay.angularVelocity = new Tl())),
            this._targetRay
          )
        }
        getGripSpace() {
          return (
            null === this._grip &&
              ((this._grip = new Tp()),
              (this._grip.matrixAutoUpdate = !1),
              (this._grip.visible = !1),
              (this._grip.hasLinearVelocity = !1),
              (this._grip.linearVelocity = new Tl()),
              (this._grip.hasAngularVelocity = !1),
              (this._grip.angularVelocity = new Tl())),
            this._grip
          )
        }
        dispatchEvent(t) {
          return (
            null !== this._targetRay && this._targetRay.dispatchEvent(t),
            null !== this._grip && this._grip.dispatchEvent(t),
            null !== this._hand && this._hand.dispatchEvent(t),
            this
          )
        }
        disconnect(t) {
          return (
            this.dispatchEvent({ type: 'disconnected', data: t }),
            null !== this._targetRay && (this._targetRay.visible = !1),
            null !== this._grip && (this._grip.visible = !1),
            null !== this._hand && (this._hand.visible = !1),
            this
          )
        }
        update(t, e, n) {
          let i = null,
            r = null,
            s = null
          const o = this._targetRay,
            a = this._grip,
            l = this._hand
          if (t && 'visible-blurred' !== e.session.visibilityState)
            if (
              (null !== o &&
                ((i = e.getPose(t.targetRaySpace, n)),
                null !== i &&
                  (o.matrix.fromArray(i.transform.matrix),
                  o.matrix.decompose(o.position, o.rotation, o.scale),
                  i.linearVelocity
                    ? ((o.hasLinearVelocity = !0),
                      o.linearVelocity.copy(i.linearVelocity))
                    : (o.hasLinearVelocity = !1),
                  i.angularVelocity
                    ? ((o.hasAngularVelocity = !0),
                      o.angularVelocity.copy(i.angularVelocity))
                    : (o.hasAngularVelocity = !1),
                  this.dispatchEvent(Ep))),
              l && t.hand)
            ) {
              s = !0
              for (const i of t.hand.values()) {
                const t = e.getJointPose(i, n)
                if (void 0 === l.joints[i.jointName]) {
                  const t = new Tp()
                  ;(t.matrixAutoUpdate = !1),
                    (t.visible = !1),
                    (l.joints[i.jointName] = t),
                    l.add(t)
                }
                const r = l.joints[i.jointName]
                null !== t &&
                  (r.matrix.fromArray(t.transform.matrix),
                  r.matrix.decompose(r.position, r.rotation, r.scale),
                  (r.jointRadius = t.radius)),
                  (r.visible = null !== t)
              }
              const i = l.joints['index-finger-tip'],
                r = l.joints['thumb-tip'],
                o = i.position.distanceTo(r.position),
                a = 0.02,
                c = 0.005
              l.inputState.pinching && o > a + c
                ? ((l.inputState.pinching = !1),
                  this.dispatchEvent({
                    type: 'pinchend',
                    handedness: t.handedness,
                    target: this,
                  }))
                : !l.inputState.pinching &&
                  o <= a - c &&
                  ((l.inputState.pinching = !0),
                  this.dispatchEvent({
                    type: 'pinchstart',
                    handedness: t.handedness,
                    target: this,
                  }))
            } else
              null !== a &&
                t.gripSpace &&
                ((r = e.getPose(t.gripSpace, n)),
                null !== r &&
                  (a.matrix.fromArray(r.transform.matrix),
                  a.matrix.decompose(a.position, a.rotation, a.scale),
                  r.linearVelocity
                    ? ((a.hasLinearVelocity = !0),
                      a.linearVelocity.copy(r.linearVelocity))
                    : (a.hasLinearVelocity = !1),
                  r.angularVelocity
                    ? ((a.hasAngularVelocity = !0),
                      a.angularVelocity.copy(r.angularVelocity))
                    : (a.hasAngularVelocity = !1)))
          return (
            null !== o && (o.visible = null !== i),
            null !== a && (a.visible = null !== r),
            null !== l && (l.visible = null !== s),
            this
          )
        }
      }
      class Ap extends Qa {
        constructor(t, e) {
          super()
          const n = this,
            i = t.state
          let r = null,
            s = 1,
            o = null,
            a = 'local-floor',
            l = null,
            c = null,
            u = null,
            h = null,
            d = null,
            p = !1,
            f = null,
            m = null,
            g = null,
            v = null,
            _ = null,
            y = null
          const x = [],
            b = new Map(),
            w = new Iu()
          w.layers.enable(1), (w.viewport = new bl())
          const M = new Iu()
          M.layers.enable(2), (M.viewport = new bl())
          const S = [w, M],
            T = new Sp()
          T.layers.enable(1), T.layers.enable(2)
          let E = null,
            D = null
          function A(t) {
            const e = b.get(t.inputSource)
            e && e.dispatchEvent({ type: t.type, data: t.inputSource })
          }
          function C() {
            b.forEach(function (t, e) {
              t.disconnect(e)
            }),
              b.clear(),
              (E = null),
              (D = null),
              i.bindXRFramebuffer(null),
              t.setRenderTarget(t.getRenderTarget()),
              u && e.deleteFramebuffer(u),
              f && e.deleteFramebuffer(f),
              m && e.deleteRenderbuffer(m),
              g && e.deleteRenderbuffer(g),
              (u = null),
              (f = null),
              (m = null),
              (g = null),
              (d = null),
              (h = null),
              (c = null),
              (r = null),
              O.stop(),
              (n.isPresenting = !1),
              n.dispatchEvent({ type: 'sessionend' })
          }
          function L(t) {
            const e = r.inputSources
            for (let t = 0; t < x.length; t++) b.set(e[t], x[t])
            for (let e = 0; e < t.removed.length; e++) {
              const n = t.removed[e],
                i = b.get(n)
              i &&
                (i.dispatchEvent({ type: 'disconnected', data: n }),
                b.delete(n))
            }
            for (let e = 0; e < t.added.length; e++) {
              const n = t.added[e],
                i = b.get(n)
              i && i.dispatchEvent({ type: 'connected', data: n })
            }
          }
          ;(this.cameraAutoUpdate = !0),
            (this.enabled = !1),
            (this.isPresenting = !1),
            (this.getController = function (t) {
              let e = x[t]
              return (
                void 0 === e && ((e = new Dp()), (x[t] = e)),
                e.getTargetRaySpace()
              )
            }),
            (this.getControllerGrip = function (t) {
              let e = x[t]
              return (
                void 0 === e && ((e = new Dp()), (x[t] = e)), e.getGripSpace()
              )
            }),
            (this.getHand = function (t) {
              let e = x[t]
              return (
                void 0 === e && ((e = new Dp()), (x[t] = e)), e.getHandSpace()
              )
            }),
            (this.setFramebufferScaleFactor = function (t) {
              ;(s = t),
                !0 === n.isPresenting &&
                  console.warn(
                    'THREE.WebXRManager: Cannot change framebuffer scale while presenting.',
                  )
            }),
            (this.setReferenceSpaceType = function (t) {
              ;(a = t),
                !0 === n.isPresenting &&
                  console.warn(
                    'THREE.WebXRManager: Cannot change reference space type while presenting.',
                  )
            }),
            (this.getReferenceSpace = function () {
              return o
            }),
            (this.getBaseLayer = function () {
              return null !== h ? h : d
            }),
            (this.getBinding = function () {
              return c
            }),
            (this.getFrame = function () {
              return v
            }),
            (this.getSession = function () {
              return r
            }),
            (this.setSession = async function (t) {
              if (((r = t), null !== r)) {
                r.addEventListener('select', A),
                  r.addEventListener('selectstart', A),
                  r.addEventListener('selectend', A),
                  r.addEventListener('squeeze', A),
                  r.addEventListener('squeezestart', A),
                  r.addEventListener('squeezeend', A),
                  r.addEventListener('end', C),
                  r.addEventListener('inputsourceschange', L)
                const t = e.getContextAttributes()
                if (
                  (!0 !== t.xrCompatible && (await e.makeXRCompatible()),
                  void 0 === r.renderState.layers)
                ) {
                  const n = {
                    antialias: t.antialias,
                    alpha: t.alpha,
                    depth: t.depth,
                    stencil: t.stencil,
                    framebufferScaleFactor: s,
                  }
                  ;(d = new XRWebGLLayer(r, e, n)),
                    r.updateRenderState({ baseLayer: d })
                } else if (e instanceof WebGLRenderingContext) {
                  const n = {
                    antialias: !0,
                    alpha: t.alpha,
                    depth: t.depth,
                    stencil: t.stencil,
                    framebufferScaleFactor: s,
                  }
                  ;(d = new XRWebGLLayer(r, e, n)),
                    r.updateRenderState({ layers: [d] })
                } else {
                  p = t.antialias
                  let n = null
                  t.depth &&
                    ((y = 256),
                    t.stencil && (y |= 1024),
                    (_ = t.stencil ? 33306 : 36096),
                    (n = t.stencil ? 35056 : 33190))
                  const o = {
                    colorFormat: t.alpha ? 32856 : 32849,
                    depthFormat: n,
                    scaleFactor: s,
                  }
                  ;(c = new XRWebGLBinding(r, e)),
                    (h = c.createProjectionLayer(o)),
                    (u = e.createFramebuffer()),
                    r.updateRenderState({ layers: [h] }),
                    p &&
                      ((f = e.createFramebuffer()),
                      (m = e.createRenderbuffer()),
                      e.bindRenderbuffer(36161, m),
                      e.renderbufferStorageMultisample(
                        36161,
                        4,
                        32856,
                        h.textureWidth,
                        h.textureHeight,
                      ),
                      i.bindFramebuffer(36160, f),
                      e.framebufferRenderbuffer(36160, 36064, 36161, m),
                      e.bindRenderbuffer(36161, null),
                      null !== n &&
                        ((g = e.createRenderbuffer()),
                        e.bindRenderbuffer(36161, g),
                        e.renderbufferStorageMultisample(
                          36161,
                          4,
                          n,
                          h.textureWidth,
                          h.textureHeight,
                        ),
                        e.framebufferRenderbuffer(36160, _, 36161, g),
                        e.bindRenderbuffer(36161, null)),
                      i.bindFramebuffer(36160, null))
                }
                ;(o = await r.requestReferenceSpace(a)),
                  O.setContext(r),
                  O.start(),
                  (n.isPresenting = !0),
                  n.dispatchEvent({ type: 'sessionstart' })
              }
            })
          const R = new Tl(),
            P = new Tl()
          function F(t, e) {
            null === e
              ? t.matrixWorld.copy(t.matrix)
              : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
              t.matrixWorldInverse.copy(t.matrixWorld).invert()
          }
          ;(this.updateCamera = function (t) {
            if (null === r) return
            ;(T.near = M.near = w.near = t.near),
              (T.far = M.far = w.far = t.far),
              (E === T.near && D === T.far) ||
                (r.updateRenderState({ depthNear: T.near, depthFar: T.far }),
                (E = T.near),
                (D = T.far))
            const e = t.parent,
              n = T.cameras
            F(T, e)
            for (let t = 0; t < n.length; t++) F(n[t], e)
            T.matrixWorld.decompose(T.position, T.quaternion, T.scale),
              t.position.copy(T.position),
              t.quaternion.copy(T.quaternion),
              t.scale.copy(T.scale),
              t.matrix.copy(T.matrix),
              t.matrixWorld.copy(T.matrixWorld)
            const i = t.children
            for (let t = 0, e = i.length; t < e; t++) i[t].updateMatrixWorld(!0)
            2 === n.length
              ? (function (t, e, n) {
                  R.setFromMatrixPosition(e.matrixWorld),
                    P.setFromMatrixPosition(n.matrixWorld)
                  const i = R.distanceTo(P),
                    r = e.projectionMatrix.elements,
                    s = n.projectionMatrix.elements,
                    o = r[14] / (r[10] - 1),
                    a = r[14] / (r[10] + 1),
                    l = (r[9] + 1) / r[5],
                    c = (r[9] - 1) / r[5],
                    u = (r[8] - 1) / r[0],
                    h = (s[8] + 1) / s[0],
                    d = o * u,
                    p = o * h,
                    f = i / (-u + h),
                    m = f * -u
                  e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                    t.translateX(m),
                    t.translateZ(f),
                    t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                    t.matrixWorldInverse.copy(t.matrixWorld).invert()
                  const g = o + f,
                    v = a + f,
                    _ = d - m,
                    y = p + (i - m),
                    x = ((l * a) / v) * g,
                    b = ((c * a) / v) * g
                  t.projectionMatrix.makePerspective(_, y, x, b, g, v)
                })(T, w, M)
              : T.projectionMatrix.copy(w.projectionMatrix)
          }),
            (this.getCamera = function () {
              return T
            }),
            (this.getFoveation = function () {
              return null !== h
                ? h.fixedFoveation
                : null !== d
                ? d.fixedFoveation
                : void 0
            }),
            (this.setFoveation = function (t) {
              null !== h && (h.fixedFoveation = t),
                null !== d &&
                  void 0 !== d.fixedFoveation &&
                  (d.fixedFoveation = t)
            })
          let I = null
          const O = new qu()
          O.setAnimationLoop(function (t, n) {
            if (((l = n.getViewerPose(o)), (v = n), null !== l)) {
              const t = l.views
              null !== d && i.bindXRFramebuffer(d.framebuffer)
              let n = !1
              t.length !== T.cameras.length &&
                ((T.cameras.length = 0), (n = !0))
              for (let r = 0; r < t.length; r++) {
                const s = t[r]
                let o = null
                if (null !== d) o = d.getViewport(s)
                else {
                  const t = c.getViewSubImage(h, s)
                  i.bindXRFramebuffer(u),
                    void 0 !== t.depthStencilTexture &&
                      e.framebufferTexture2D(
                        36160,
                        _,
                        3553,
                        t.depthStencilTexture,
                        0,
                      ),
                    e.framebufferTexture2D(
                      36160,
                      36064,
                      3553,
                      t.colorTexture,
                      0,
                    ),
                    (o = t.viewport)
                }
                const a = S[r]
                a.matrix.fromArray(s.transform.matrix),
                  a.projectionMatrix.fromArray(s.projectionMatrix),
                  a.viewport.set(o.x, o.y, o.width, o.height),
                  0 === r && T.matrix.copy(a.matrix),
                  !0 === n && T.cameras.push(a)
              }
              p && (i.bindXRFramebuffer(f), null !== y && e.clear(y))
            }
            const s = r.inputSources
            for (let t = 0; t < x.length; t++) {
              const e = x[t],
                i = s[t]
              e.update(i, n, o)
            }
            if ((I && I(t, n), p)) {
              const t = h.textureWidth,
                n = h.textureHeight
              i.bindFramebuffer(36008, f),
                i.bindFramebuffer(36009, u),
                e.invalidateFramebuffer(36008, [_]),
                e.invalidateFramebuffer(36009, [_]),
                e.blitFramebuffer(0, 0, t, n, 0, 0, t, n, 16384, 9728),
                e.invalidateFramebuffer(36008, [36064]),
                i.bindFramebuffer(36008, null),
                i.bindFramebuffer(36009, null),
                i.bindFramebuffer(36160, f)
            }
            v = null
          }),
            (this.setAnimationLoop = function (t) {
              I = t
            }),
            (this.dispose = function () {})
        }
      }
      function Cp(t) {
        function e(e, n) {
          ;(e.opacity.value = n.opacity),
            n.color && e.diffuse.value.copy(n.color),
            n.emissive &&
              e.emissive.value
                .copy(n.emissive)
                .multiplyScalar(n.emissiveIntensity),
            n.map && (e.map.value = n.map),
            n.alphaMap && (e.alphaMap.value = n.alphaMap),
            n.specularMap && (e.specularMap.value = n.specularMap),
            n.alphaTest > 0 && (e.alphaTest.value = n.alphaTest)
          const i = t.get(n).envMap
          if (i) {
            ;(e.envMap.value = i),
              (e.flipEnvMap.value =
                i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1),
              (e.reflectivity.value = n.reflectivity),
              (e.ior.value = n.ior),
              (e.refractionRatio.value = n.refractionRatio)
            const r = t.get(i).__maxMipLevel
            void 0 !== r && (e.maxMipLevel.value = r)
          }
          let r, s
          n.lightMap &&
            ((e.lightMap.value = n.lightMap),
            (e.lightMapIntensity.value = n.lightMapIntensity)),
            n.aoMap &&
              ((e.aoMap.value = n.aoMap),
              (e.aoMapIntensity.value = n.aoMapIntensity)),
            n.map
              ? (r = n.map)
              : n.specularMap
              ? (r = n.specularMap)
              : n.displacementMap
              ? (r = n.displacementMap)
              : n.normalMap
              ? (r = n.normalMap)
              : n.bumpMap
              ? (r = n.bumpMap)
              : n.roughnessMap
              ? (r = n.roughnessMap)
              : n.metalnessMap
              ? (r = n.metalnessMap)
              : n.alphaMap
              ? (r = n.alphaMap)
              : n.emissiveMap
              ? (r = n.emissiveMap)
              : n.clearcoatMap
              ? (r = n.clearcoatMap)
              : n.clearcoatNormalMap
              ? (r = n.clearcoatNormalMap)
              : n.clearcoatRoughnessMap
              ? (r = n.clearcoatRoughnessMap)
              : n.specularIntensityMap
              ? (r = n.specularIntensityMap)
              : n.specularTintMap
              ? (r = n.specularTintMap)
              : n.transmissionMap
              ? (r = n.transmissionMap)
              : n.thicknessMap && (r = n.thicknessMap),
            void 0 !== r &&
              (r.isWebGLRenderTarget && (r = r.texture),
              !0 === r.matrixAutoUpdate && r.updateMatrix(),
              e.uvTransform.value.copy(r.matrix)),
            n.aoMap ? (s = n.aoMap) : n.lightMap && (s = n.lightMap),
            void 0 !== s &&
              (s.isWebGLRenderTarget && (s = s.texture),
              !0 === s.matrixAutoUpdate && s.updateMatrix(),
              e.uv2Transform.value.copy(s.matrix))
        }
        function n(e, n) {
          ;(e.roughness.value = n.roughness),
            (e.metalness.value = n.metalness),
            n.roughnessMap && (e.roughnessMap.value = n.roughnessMap),
            n.metalnessMap && (e.metalnessMap.value = n.metalnessMap),
            n.emissiveMap && (e.emissiveMap.value = n.emissiveMap),
            n.bumpMap &&
              ((e.bumpMap.value = n.bumpMap),
              (e.bumpScale.value = n.bumpScale),
              1 === n.side && (e.bumpScale.value *= -1)),
            n.normalMap &&
              ((e.normalMap.value = n.normalMap),
              e.normalScale.value.copy(n.normalScale),
              1 === n.side && e.normalScale.value.negate()),
            n.displacementMap &&
              ((e.displacementMap.value = n.displacementMap),
              (e.displacementScale.value = n.displacementScale),
              (e.displacementBias.value = n.displacementBias)),
            t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
        }
        return {
          refreshFogUniforms: function (t, e) {
            t.fogColor.value.copy(e.color),
              e.isFog
                ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
                : e.isFogExp2 && (t.fogDensity.value = e.density)
          },
          refreshMaterialUniforms: function (t, i, r, s, o) {
            i.isMeshBasicMaterial
              ? e(t, i)
              : i.isMeshLambertMaterial
              ? (e(t, i),
                (function (t, e) {
                  e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                })(t, i))
              : i.isMeshToonMaterial
              ? (e(t, i),
                (function (t, e) {
                  e.gradientMap && (t.gradientMap.value = e.gradientMap),
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                    e.bumpMap &&
                      ((t.bumpMap.value = e.bumpMap),
                      (t.bumpScale.value = e.bumpScale),
                      1 === e.side && (t.bumpScale.value *= -1)),
                    e.normalMap &&
                      ((t.normalMap.value = e.normalMap),
                      t.normalScale.value.copy(e.normalScale),
                      1 === e.side && t.normalScale.value.negate()),
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias))
                })(t, i))
              : i.isMeshPhongMaterial
              ? (e(t, i),
                (function (t, e) {
                  t.specular.value.copy(e.specular),
                    (t.shininess.value = Math.max(e.shininess, 1e-4)),
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                    e.bumpMap &&
                      ((t.bumpMap.value = e.bumpMap),
                      (t.bumpScale.value = e.bumpScale),
                      1 === e.side && (t.bumpScale.value *= -1)),
                    e.normalMap &&
                      ((t.normalMap.value = e.normalMap),
                      t.normalScale.value.copy(e.normalScale),
                      1 === e.side && t.normalScale.value.negate()),
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias))
                })(t, i))
              : i.isMeshStandardMaterial
              ? (e(t, i),
                i.isMeshPhysicalMaterial
                  ? (function (t, e, i) {
                      n(t, e),
                        (t.ior.value = e.ior),
                        e.sheen > 0 &&
                          (t.sheenTint.value
                            .copy(e.sheenTint)
                            .multiplyScalar(e.sheen),
                          (t.sheenRoughness.value = e.sheenRoughness)),
                        e.clearcoat > 0 &&
                          ((t.clearcoat.value = e.clearcoat),
                          (t.clearcoatRoughness.value = e.clearcoatRoughness),
                          e.clearcoatMap &&
                            (t.clearcoatMap.value = e.clearcoatMap),
                          e.clearcoatRoughnessMap &&
                            (t.clearcoatRoughnessMap.value =
                              e.clearcoatRoughnessMap),
                          e.clearcoatNormalMap &&
                            (t.clearcoatNormalScale.value.copy(
                              e.clearcoatNormalScale,
                            ),
                            (t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                            1 === e.side &&
                              t.clearcoatNormalScale.value.negate())),
                        e.transmission > 0 &&
                          ((t.transmission.value = e.transmission),
                          (t.transmissionSamplerMap.value = i.texture),
                          t.transmissionSamplerSize.value.set(
                            i.width,
                            i.height,
                          ),
                          e.transmissionMap &&
                            (t.transmissionMap.value = e.transmissionMap),
                          (t.thickness.value = e.thickness),
                          e.thicknessMap &&
                            (t.thicknessMap.value = e.thicknessMap),
                          (t.attenuationDistance.value = e.attenuationDistance),
                          t.attenuationTint.value.copy(e.attenuationTint)),
                        (t.specularIntensity.value = e.specularIntensity),
                        t.specularTint.value.copy(e.specularTint),
                        e.specularIntensityMap &&
                          (t.specularIntensityMap.value =
                            e.specularIntensityMap),
                        e.specularTintMap &&
                          (t.specularTintMap.value = e.specularTintMap)
                    })(t, i, o)
                  : n(t, i))
              : i.isMeshMatcapMaterial
              ? (e(t, i),
                (function (t, e) {
                  e.matcap && (t.matcap.value = e.matcap),
                    e.bumpMap &&
                      ((t.bumpMap.value = e.bumpMap),
                      (t.bumpScale.value = e.bumpScale),
                      1 === e.side && (t.bumpScale.value *= -1)),
                    e.normalMap &&
                      ((t.normalMap.value = e.normalMap),
                      t.normalScale.value.copy(e.normalScale),
                      1 === e.side && t.normalScale.value.negate()),
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias))
                })(t, i))
              : i.isMeshDepthMaterial
              ? (e(t, i),
                (function (t, e) {
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias))
                })(t, i))
              : i.isMeshDistanceMaterial
              ? (e(t, i),
                (function (t, e) {
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias)),
                    t.referencePosition.value.copy(e.referencePosition),
                    (t.nearDistance.value = e.nearDistance),
                    (t.farDistance.value = e.farDistance)
                })(t, i))
              : i.isMeshNormalMaterial
              ? (e(t, i),
                (function (t, e) {
                  e.bumpMap &&
                    ((t.bumpMap.value = e.bumpMap),
                    (t.bumpScale.value = e.bumpScale),
                    1 === e.side && (t.bumpScale.value *= -1)),
                    e.normalMap &&
                      ((t.normalMap.value = e.normalMap),
                      t.normalScale.value.copy(e.normalScale),
                      1 === e.side && t.normalScale.value.negate()),
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias))
                })(t, i))
              : i.isLineBasicMaterial
              ? ((function (t, e) {
                  t.diffuse.value.copy(e.color), (t.opacity.value = e.opacity)
                })(t, i),
                i.isLineDashedMaterial &&
                  (function (t, e) {
                    ;(t.dashSize.value = e.dashSize),
                      (t.totalSize.value = e.dashSize + e.gapSize),
                      (t.scale.value = e.scale)
                  })(t, i))
              : i.isPointsMaterial
              ? (function (t, e, n, i) {
                  let r
                  t.diffuse.value.copy(e.color),
                    (t.opacity.value = e.opacity),
                    (t.size.value = e.size * n),
                    (t.scale.value = 0.5 * i),
                    e.map && (t.map.value = e.map),
                    e.alphaMap && (t.alphaMap.value = e.alphaMap),
                    e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest),
                    e.map ? (r = e.map) : e.alphaMap && (r = e.alphaMap),
                    void 0 !== r &&
                      (!0 === r.matrixAutoUpdate && r.updateMatrix(),
                      t.uvTransform.value.copy(r.matrix))
                })(t, i, r, s)
              : i.isSpriteMaterial
              ? (function (t, e) {
                  let n
                  t.diffuse.value.copy(e.color),
                    (t.opacity.value = e.opacity),
                    (t.rotation.value = e.rotation),
                    e.map && (t.map.value = e.map),
                    e.alphaMap && (t.alphaMap.value = e.alphaMap),
                    e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest),
                    e.map ? (n = e.map) : e.alphaMap && (n = e.alphaMap),
                    void 0 !== n &&
                      (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                      t.uvTransform.value.copy(n.matrix))
                })(t, i)
              : i.isShadowMaterial
              ? (t.color.value.copy(i.color), (t.opacity.value = i.opacity))
              : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
          },
        }
      }
      function Lp(t = {}) {
        const e =
            void 0 !== t.canvas
              ? t.canvas
              : (function () {
                  const t = ml('canvas')
                  return (t.style.display = 'block'), t
                })(),
          n = void 0 !== t.context ? t.context : null,
          i = void 0 !== t.alpha && t.alpha,
          r = void 0 === t.depth || t.depth,
          s = void 0 === t.stencil || t.stencil,
          o = void 0 !== t.antialias && t.antialias,
          a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
          l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
          c = void 0 !== t.powerPreference ? t.powerPreference : 'default',
          u =
            void 0 !== t.failIfMajorPerformanceCaveat &&
            t.failIfMajorPerformanceCaveat
        let h = null,
          d = null
        const p = [],
          f = []
        ;(this.domElement = e),
          (this.debug = { checkShaderErrors: !0 }),
          (this.autoClear = !0),
          (this.autoClearColor = !0),
          (this.autoClearDepth = !0),
          (this.autoClearStencil = !0),
          (this.sortObjects = !0),
          (this.clippingPlanes = []),
          (this.localClippingEnabled = !1),
          (this.gammaFactor = 2),
          (this.outputEncoding = Wa),
          (this.physicallyCorrectLights = !1),
          (this.toneMapping = 0),
          (this.toneMappingExposure = 1)
        const m = this
        let g = !1,
          v = 0,
          _ = 0,
          y = null,
          x = -1,
          b = null
        const w = new bl(),
          M = new bl()
        let S = null,
          T = e.width,
          E = e.height,
          D = 1,
          A = null,
          C = null
        const L = new bl(0, 0, T, E),
          R = new bl(0, 0, T, E)
        let P = !1
        const F = [],
          I = new ju()
        let O = !1,
          N = !1,
          k = null
        const B = new nc(),
          z = new Tl(),
          U = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0,
          }
        function H() {
          return null === y ? D : 1
        }
        let G,
          V,
          W,
          j,
          q,
          X,
          Y,
          J,
          Z,
          K,
          Q,
          $,
          tt,
          et,
          nt,
          it,
          rt,
          st,
          ot,
          at,
          lt,
          ct,
          ut,
          ht = n
        function dt(t, n) {
          for (let i = 0; i < t.length; i++) {
            const r = t[i],
              s = e.getContext(r, n)
            if (null !== s) return s
          }
          return null
        }
        try {
          const t = {
            alpha: i,
            depth: r,
            stencil: s,
            antialias: o,
            premultipliedAlpha: a,
            preserveDrawingBuffer: l,
            powerPreference: c,
            failIfMajorPerformanceCaveat: u,
          }
          if (
            (e.addEventListener('webglcontextlost', mt, !1),
            e.addEventListener('webglcontextrestored', gt, !1),
            null === ht)
          ) {
            const e = ['webgl2', 'webgl', 'experimental-webgl']
            if (
              (!0 === m.isWebGL1Renderer && e.shift(),
              (ht = dt(e, t)),
              null === ht)
            )
              throw dt(e)
                ? new Error(
                    'Error creating WebGL context with your selected attributes.',
                  )
                : new Error('Error creating WebGL context.')
          }
          void 0 === ht.getShaderPrecisionFormat &&
            (ht.getShaderPrecisionFormat = function () {
              return { rangeMin: 1, rangeMax: 1, precision: 1 }
            })
        } catch (t) {
          throw (console.error('THREE.WebGLRenderer: ' + t.message), t)
        }
        function pt() {
          ;(G = new Dh(ht)),
            (V = new eh(ht, G, t)),
            G.init(V),
            (ct = new Mp(ht, G, V)),
            (W = new bp(ht, G, V)),
            (F[0] = 1029),
            (j = new Lh(ht)),
            (q = new ap()),
            (X = new wp(ht, G, W, q, V, ct, j)),
            (Y = new ih(m)),
            (J = new Eh(m)),
            (Z = new Xu(ht, V)),
            (ut = new $u(ht, G, Z, V)),
            (K = new Ah(ht, Z, j, ut)),
            (Q = new Nh(ht, K, Z, j)),
            (ot = new Oh(ht, V, X)),
            (it = new nh(q)),
            ($ = new op(m, Y, J, G, V, ut, it)),
            (tt = new Cp(q)),
            (et = new hp(q)),
            (nt = new vp(G, V)),
            (st = new Qu(m, Y, W, Q, a)),
            (rt = new xp(m, Q, V)),
            (at = new th(ht, G, j, V)),
            (lt = new Ch(ht, G, j, V)),
            (j.programs = $.programs),
            (m.capabilities = V),
            (m.extensions = G),
            (m.properties = q),
            (m.renderLists = et),
            (m.shadowMap = rt),
            (m.state = W),
            (m.info = j)
        }
        pt()
        const ft = new Ap(m, ht)
        function mt(t) {
          t.preventDefault(),
            console.log('THREE.WebGLRenderer: Context Lost.'),
            (g = !0)
        }
        function gt() {
          console.log('THREE.WebGLRenderer: Context Restored.'), (g = !1)
          const t = j.autoReset,
            e = rt.enabled,
            n = rt.autoUpdate,
            i = rt.needsUpdate,
            r = rt.type
          pt(),
            (j.autoReset = t),
            (rt.enabled = e),
            (rt.autoUpdate = n),
            (rt.needsUpdate = i),
            (rt.type = r)
        }
        function vt(t) {
          const e = t.target
          e.removeEventListener('dispose', vt),
            (function (t) {
              ;(function (t) {
                const e = q.get(t).programs
                void 0 !== e &&
                  e.forEach(function (t) {
                    $.releaseProgram(t)
                  })
              })(t),
                q.remove(t)
            })(e)
        }
        ;(this.xr = ft),
          (this.getContext = function () {
            return ht
          }),
          (this.getContextAttributes = function () {
            return ht.getContextAttributes()
          }),
          (this.forceContextLoss = function () {
            const t = G.get('WEBGL_lose_context')
            t && t.loseContext()
          }),
          (this.forceContextRestore = function () {
            const t = G.get('WEBGL_lose_context')
            t && t.restoreContext()
          }),
          (this.getPixelRatio = function () {
            return D
          }),
          (this.setPixelRatio = function (t) {
            void 0 !== t && ((D = t), this.setSize(T, E, !1))
          }),
          (this.getSize = function (t) {
            return t.set(T, E)
          }),
          (this.setSize = function (t, n, i) {
            ft.isPresenting
              ? console.warn(
                  "THREE.WebGLRenderer: Can't change size while VR device is presenting.",
                )
              : ((T = t),
                (E = n),
                (e.width = Math.floor(t * D)),
                (e.height = Math.floor(n * D)),
                !1 !== i &&
                  ((e.style.width = t + 'px'), (e.style.height = n + 'px')),
                this.setViewport(0, 0, t, n))
          }),
          (this.getDrawingBufferSize = function (t) {
            return t.set(T * D, E * D).floor()
          }),
          (this.setDrawingBufferSize = function (t, n, i) {
            ;(T = t),
              (E = n),
              (D = i),
              (e.width = Math.floor(t * i)),
              (e.height = Math.floor(n * i)),
              this.setViewport(0, 0, t, n)
          }),
          (this.getCurrentViewport = function (t) {
            return t.copy(w)
          }),
          (this.getViewport = function (t) {
            return t.copy(L)
          }),
          (this.setViewport = function (t, e, n, i) {
            t.isVector4 ? L.set(t.x, t.y, t.z, t.w) : L.set(t, e, n, i),
              W.viewport(w.copy(L).multiplyScalar(D).floor())
          }),
          (this.getScissor = function (t) {
            return t.copy(R)
          }),
          (this.setScissor = function (t, e, n, i) {
            t.isVector4 ? R.set(t.x, t.y, t.z, t.w) : R.set(t, e, n, i),
              W.scissor(M.copy(R).multiplyScalar(D).floor())
          }),
          (this.getScissorTest = function () {
            return P
          }),
          (this.setScissorTest = function (t) {
            W.setScissorTest((P = t))
          }),
          (this.setOpaqueSort = function (t) {
            A = t
          }),
          (this.setTransparentSort = function (t) {
            C = t
          }),
          (this.getClearColor = function (t) {
            return t.copy(st.getClearColor())
          }),
          (this.setClearColor = function () {
            st.setClearColor.apply(st, arguments)
          }),
          (this.getClearAlpha = function () {
            return st.getClearAlpha()
          }),
          (this.setClearAlpha = function () {
            st.setClearAlpha.apply(st, arguments)
          }),
          (this.clear = function (t, e, n) {
            let i = 0
            ;(void 0 === t || t) && (i |= 16384),
              (void 0 === e || e) && (i |= 256),
              (void 0 === n || n) && (i |= 1024),
              ht.clear(i)
          }),
          (this.clearColor = function () {
            this.clear(!0, !1, !1)
          }),
          (this.clearDepth = function () {
            this.clear(!1, !0, !1)
          }),
          (this.clearStencil = function () {
            this.clear(!1, !1, !0)
          }),
          (this.dispose = function () {
            e.removeEventListener('webglcontextlost', mt, !1),
              e.removeEventListener('webglcontextrestored', gt, !1),
              et.dispose(),
              nt.dispose(),
              q.dispose(),
              Y.dispose(),
              J.dispose(),
              Q.dispose(),
              ut.dispose(),
              ft.dispose(),
              ft.removeEventListener('sessionstart', yt),
              ft.removeEventListener('sessionend', xt),
              k && (k.dispose(), (k = null)),
              bt.stop()
          }),
          (this.renderBufferImmediate = function (t, e) {
            ut.initAttributes()
            const n = q.get(t)
            t.hasPositions && !n.position && (n.position = ht.createBuffer()),
              t.hasNormals && !n.normal && (n.normal = ht.createBuffer()),
              t.hasUvs && !n.uv && (n.uv = ht.createBuffer()),
              t.hasColors && !n.color && (n.color = ht.createBuffer())
            const i = e.getAttributes()
            t.hasPositions &&
              (ht.bindBuffer(34962, n.position),
              ht.bufferData(34962, t.positionArray, 35048),
              ut.enableAttribute(i.position.location),
              ht.vertexAttribPointer(i.position.location, 3, 5126, !1, 0, 0)),
              t.hasNormals &&
                (ht.bindBuffer(34962, n.normal),
                ht.bufferData(34962, t.normalArray, 35048),
                ut.enableAttribute(i.normal.location),
                ht.vertexAttribPointer(i.normal.location, 3, 5126, !1, 0, 0)),
              t.hasUvs &&
                (ht.bindBuffer(34962, n.uv),
                ht.bufferData(34962, t.uvArray, 35048),
                ut.enableAttribute(i.uv.location),
                ht.vertexAttribPointer(i.uv.location, 2, 5126, !1, 0, 0)),
              t.hasColors &&
                (ht.bindBuffer(34962, n.color),
                ht.bufferData(34962, t.colorArray, 35048),
                ut.enableAttribute(i.color.location),
                ht.vertexAttribPointer(i.color.location, 3, 5126, !1, 0, 0)),
              ut.disableUnusedAttributes(),
              ht.drawArrays(4, 0, t.count),
              (t.count = 0)
          }),
          (this.renderBufferDirect = function (t, e, n, i, r, s) {
            null === e && (e = U)
            const o = r.isMesh && r.matrixWorld.determinant() < 0,
              a = At(t, e, n, i, r)
            W.setMaterial(i, o)
            let l = n.index
            const c = n.attributes.position
            if (null === l) {
              if (void 0 === c || 0 === c.count) return
            } else if (0 === l.count) return
            let u,
              h = 1
            !0 === i.wireframe && ((l = K.getWireframeAttribute(n)), (h = 2)),
              ut.setup(r, i, a, n, l)
            let d = at
            null !== l && ((u = Z.get(l)), (d = lt), d.setIndex(u))
            const p = null !== l ? l.count : c.count,
              f = n.drawRange.start * h,
              m = n.drawRange.count * h,
              g = null !== s ? s.start * h : 0,
              v = null !== s ? s.count * h : 1 / 0,
              _ = Math.max(f, g),
              y = Math.min(p, f + m, g + v) - 1,
              x = Math.max(0, y - _ + 1)
            if (0 !== x) {
              if (r.isMesh)
                !0 === i.wireframe
                  ? (W.setLineWidth(i.wireframeLinewidth * H()), d.setMode(1))
                  : d.setMode(4)
              else if (r.isLine) {
                let t = i.linewidth
                void 0 === t && (t = 1),
                  W.setLineWidth(t * H()),
                  r.isLineSegments
                    ? d.setMode(1)
                    : r.isLineLoop
                    ? d.setMode(2)
                    : d.setMode(3)
              } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4)
              if (r.isInstancedMesh) d.renderInstances(_, x, r.count)
              else if (n.isInstancedBufferGeometry) {
                const t = Math.min(n.instanceCount, n._maxInstanceCount)
                d.renderInstances(_, x, t)
              } else d.render(_, x)
            }
          }),
          (this.compile = function (t, e) {
            ;(d = nt.get(t)),
              d.init(),
              f.push(d),
              t.traverseVisible(function (t) {
                t.isLight &&
                  t.layers.test(e.layers) &&
                  (d.pushLight(t), t.castShadow && d.pushShadow(t))
              }),
              d.setupLights(m.physicallyCorrectLights),
              t.traverse(function (e) {
                const n = e.material
                if (n)
                  if (Array.isArray(n))
                    for (let i = 0; i < n.length; i++) Et(n[i], t, e)
                  else Et(n, t, e)
              }),
              f.pop(),
              (d = null)
          })
        let _t = null
        function yt() {
          bt.stop()
        }
        function xt() {
          bt.start()
        }
        const bt = new qu()
        function wt(t, e, n, i) {
          if (!1 === t.visible) return
          if (t.layers.test(e.layers))
            if (t.isGroup) n = t.renderOrder
            else if (t.isLOD) !0 === t.autoUpdate && t.update(e)
            else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t)
            else if (t.isSprite) {
              if (!t.frustumCulled || I.intersectsSprite(t)) {
                i && z.setFromMatrixPosition(t.matrixWorld).applyMatrix4(B)
                const e = Q.update(t),
                  r = t.material
                r.visible && h.push(t, e, r, n, z.z, null)
              }
            } else if (t.isImmediateRenderObject)
              i && z.setFromMatrixPosition(t.matrixWorld).applyMatrix4(B),
                h.push(t, null, t.material, n, z.z, null)
            else if (
              (t.isMesh || t.isLine || t.isPoints) &&
              (t.isSkinnedMesh &&
                t.skeleton.frame !== j.render.frame &&
                (t.skeleton.update(), (t.skeleton.frame = j.render.frame)),
              !t.frustumCulled || I.intersectsObject(t))
            ) {
              i && z.setFromMatrixPosition(t.matrixWorld).applyMatrix4(B)
              const e = Q.update(t),
                r = t.material
              if (Array.isArray(r)) {
                const i = e.groups
                for (let s = 0, o = i.length; s < o; s++) {
                  const o = i[s],
                    a = r[o.materialIndex]
                  a && a.visible && h.push(t, e, a, n, z.z, o)
                }
              } else r.visible && h.push(t, e, r, n, z.z, null)
            }
          const r = t.children
          for (let t = 0, s = r.length; t < s; t++) wt(r[t], e, n, i)
        }
        function Mt(t, e, n, i) {
          const r = t.opaque,
            s = t.transmissive,
            a = t.transparent
          d.setupLightsView(n),
            s.length > 0 &&
              (function (t, e, n) {
                if (null === k) {
                  const t = !0 === o && !0 === V.isWebGL2
                  k = new (t ? Ml : wl)(1024, 1024, {
                    generateMipmaps: !0,
                    type: null !== ct.convert(Pa) ? Pa : Aa,
                    minFilter: Da,
                    magFilter: Ma,
                    wrapS: ba,
                    wrapT: ba,
                  })
                }
                const i = m.getRenderTarget()
                m.setRenderTarget(k), m.clear()
                const r = m.toneMapping
                ;(m.toneMapping = 0),
                  St(t, e, n),
                  (m.toneMapping = r),
                  X.updateMultisampleRenderTarget(k),
                  X.updateRenderTargetMipmap(k),
                  m.setRenderTarget(i)
              })(r, e, n),
            i && W.viewport(w.copy(i)),
            r.length > 0 && St(r, e, n),
            s.length > 0 && St(s, e, n),
            a.length > 0 && St(a, e, n)
        }
        function St(t, e, n) {
          const i = !0 === e.isScene ? e.overrideMaterial : null
          for (let r = 0, s = t.length; r < s; r++) {
            const s = t[r],
              o = s.object,
              a = s.geometry,
              l = null === i ? s.material : i,
              c = s.group
            o.layers.test(n.layers) && Tt(o, e, n, a, l, c)
          }
        }
        function Tt(t, e, n, i, r, s) {
          if (
            (t.onBeforeRender(m, e, n, i, r, s),
            t.modelViewMatrix.multiplyMatrices(
              n.matrixWorldInverse,
              t.matrixWorld,
            ),
            t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
            r.onBeforeRender(m, e, n, i, t, s),
            t.isImmediateRenderObject)
          ) {
            const s = At(n, e, i, r, t)
            W.setMaterial(r),
              ut.reset(),
              (function (t, e) {
                t.render(function (t) {
                  m.renderBufferImmediate(t, e)
                })
              })(t, s)
          } else
            !0 === r.transparent && 2 === r.side
              ? ((r.side = 1),
                (r.needsUpdate = !0),
                m.renderBufferDirect(n, e, i, r, t, s),
                (r.side = 0),
                (r.needsUpdate = !0),
                m.renderBufferDirect(n, e, i, r, t, s),
                (r.side = 2))
              : m.renderBufferDirect(n, e, i, r, t, s)
          t.onAfterRender(m, e, n, i, r, s)
        }
        function Et(t, e, n) {
          !0 !== e.isScene && (e = U)
          const i = q.get(t),
            r = d.state.lights,
            s = d.state.shadowsArray,
            o = r.state.version,
            a = $.getParameters(t, r.state, s, e, n),
            l = $.getProgramCacheKey(a)
          let c = i.programs
          ;(i.environment = t.isMeshStandardMaterial ? e.environment : null),
            (i.fog = e.fog),
            (i.envMap = (t.isMeshStandardMaterial ? J : Y).get(
              t.envMap || i.environment,
            )),
            void 0 === c &&
              (t.addEventListener('dispose', vt),
              (c = new Map()),
              (i.programs = c))
          let u = c.get(l)
          if (void 0 !== u) {
            if (i.currentProgram === u && i.lightsStateVersion === o)
              return Dt(t, a), u
          } else
            (a.uniforms = $.getUniforms(t)),
              t.onBuild(a, m),
              t.onBeforeCompile(a, m),
              (u = $.acquireProgram(a, l)),
              c.set(l, u),
              (i.uniforms = a.uniforms)
          const h = i.uniforms
          ;((t.isShaderMaterial || t.isRawShaderMaterial) &&
            !0 !== t.clipping) ||
            (h.clippingPlanes = it.uniform),
            Dt(t, a),
            (i.needsLights = (function (t) {
              return (
                t.isMeshLambertMaterial ||
                t.isMeshToonMaterial ||
                t.isMeshPhongMaterial ||
                t.isMeshStandardMaterial ||
                t.isShadowMaterial ||
                (t.isShaderMaterial && !0 === t.lights)
              )
            })(t)),
            (i.lightsStateVersion = o),
            i.needsLights &&
              ((h.ambientLightColor.value = r.state.ambient),
              (h.lightProbe.value = r.state.probe),
              (h.directionalLights.value = r.state.directional),
              (h.directionalLightShadows.value = r.state.directionalShadow),
              (h.spotLights.value = r.state.spot),
              (h.spotLightShadows.value = r.state.spotShadow),
              (h.rectAreaLights.value = r.state.rectArea),
              (h.ltc_1.value = r.state.rectAreaLTC1),
              (h.ltc_2.value = r.state.rectAreaLTC2),
              (h.pointLights.value = r.state.point),
              (h.pointLightShadows.value = r.state.pointShadow),
              (h.hemisphereLights.value = r.state.hemi),
              (h.directionalShadowMap.value = r.state.directionalShadowMap),
              (h.directionalShadowMatrix.value =
                r.state.directionalShadowMatrix),
              (h.spotShadowMap.value = r.state.spotShadowMap),
              (h.spotShadowMatrix.value = r.state.spotShadowMatrix),
              (h.pointShadowMap.value = r.state.pointShadowMap),
              (h.pointShadowMatrix.value = r.state.pointShadowMatrix))
          const p = u.getUniforms(),
            f = zd.seqWithValue(p.seq, h)
          return (i.currentProgram = u), (i.uniformsList = f), u
        }
        function Dt(t, e) {
          const n = q.get(t)
          ;(n.outputEncoding = e.outputEncoding),
            (n.instancing = e.instancing),
            (n.skinning = e.skinning),
            (n.morphTargets = e.morphTargets),
            (n.morphNormals = e.morphNormals),
            (n.morphTargetsCount = e.morphTargetsCount),
            (n.numClippingPlanes = e.numClippingPlanes),
            (n.numIntersection = e.numClipIntersection),
            (n.vertexAlphas = e.vertexAlphas),
            (n.vertexTangents = e.vertexTangents)
        }
        function At(t, e, n, i, r) {
          !0 !== e.isScene && (e = U), X.resetTextureUnits()
          const s = e.fog,
            o = i.isMeshStandardMaterial ? e.environment : null,
            a = null === y ? m.outputEncoding : y.texture.encoding,
            l = (i.isMeshStandardMaterial ? J : Y).get(i.envMap || o),
            c =
              !0 === i.vertexColors &&
              !!n &&
              !!n.attributes.color &&
              4 === n.attributes.color.itemSize,
            u = !!i.normalMap && !!n && !!n.attributes.tangent,
            h = !!n && !!n.morphAttributes.position,
            p = !!n && !!n.morphAttributes.normal,
            f =
              n && n.morphAttributes.position
                ? n.morphAttributes.position.length
                : 0,
            g = q.get(i),
            v = d.state.lights
          if (!0 === O && (!0 === N || t !== b)) {
            const e = t === b && i.id === x
            it.setState(i, t, e)
          }
          let _ = !1
          i.version === g.__version
            ? (g.needsLights && g.lightsStateVersion !== v.state.version) ||
              g.outputEncoding !== a ||
              (r.isInstancedMesh && !1 === g.instancing)
              ? (_ = !0)
              : r.isInstancedMesh || !0 !== g.instancing
              ? r.isSkinnedMesh && !1 === g.skinning
                ? (_ = !0)
                : r.isSkinnedMesh || !0 !== g.skinning
                ? g.envMap !== l || (i.fog && g.fog !== s)
                  ? (_ = !0)
                  : void 0 === g.numClippingPlanes ||
                    (g.numClippingPlanes === it.numPlanes &&
                      g.numIntersection === it.numIntersection)
                  ? (g.vertexAlphas !== c ||
                      g.vertexTangents !== u ||
                      g.morphTargets !== h ||
                      g.morphNormals !== p ||
                      (!0 === V.isWebGL2 && g.morphTargetsCount !== f)) &&
                    (_ = !0)
                  : (_ = !0)
                : (_ = !0)
              : (_ = !0)
            : ((_ = !0), (g.__version = i.version))
          let w = g.currentProgram
          !0 === _ && (w = Et(i, e, r))
          let M = !1,
            S = !1,
            T = !1
          const A = w.getUniforms(),
            C = g.uniforms
          if (
            (W.useProgram(w.program) && ((M = !0), (S = !0), (T = !0)),
            i.id !== x && ((x = i.id), (S = !0)),
            M || b !== t)
          ) {
            if (
              (A.setValue(ht, 'projectionMatrix', t.projectionMatrix),
              V.logarithmicDepthBuffer &&
                A.setValue(
                  ht,
                  'logDepthBufFC',
                  2 / (Math.log(t.far + 1) / Math.LN2),
                ),
              b !== t && ((b = t), (S = !0), (T = !0)),
              i.isShaderMaterial ||
                i.isMeshPhongMaterial ||
                i.isMeshToonMaterial ||
                i.isMeshStandardMaterial ||
                i.envMap)
            ) {
              const e = A.map.cameraPosition
              void 0 !== e &&
                e.setValue(ht, z.setFromMatrixPosition(t.matrixWorld))
            }
            ;(i.isMeshPhongMaterial ||
              i.isMeshToonMaterial ||
              i.isMeshLambertMaterial ||
              i.isMeshBasicMaterial ||
              i.isMeshStandardMaterial ||
              i.isShaderMaterial) &&
              A.setValue(ht, 'isOrthographic', !0 === t.isOrthographicCamera),
              (i.isMeshPhongMaterial ||
                i.isMeshToonMaterial ||
                i.isMeshLambertMaterial ||
                i.isMeshBasicMaterial ||
                i.isMeshStandardMaterial ||
                i.isShaderMaterial ||
                i.isShadowMaterial ||
                r.isSkinnedMesh) &&
                A.setValue(ht, 'viewMatrix', t.matrixWorldInverse)
          }
          if (r.isSkinnedMesh) {
            A.setOptional(ht, r, 'bindMatrix'),
              A.setOptional(ht, r, 'bindMatrixInverse')
            const t = r.skeleton
            t &&
              (V.floatVertexTextures
                ? (null === t.boneTexture && t.computeBoneTexture(),
                  A.setValue(ht, 'boneTexture', t.boneTexture, X),
                  A.setValue(ht, 'boneTextureSize', t.boneTextureSize))
                : A.setOptional(ht, t, 'boneMatrices'))
          }
          var L, R
          return (
            !n ||
              (void 0 === n.morphAttributes.position &&
                void 0 === n.morphAttributes.normal) ||
              ot.update(r, n, i, w),
            (S || g.receiveShadow !== r.receiveShadow) &&
              ((g.receiveShadow = r.receiveShadow),
              A.setValue(ht, 'receiveShadow', r.receiveShadow)),
            S &&
              (A.setValue(ht, 'toneMappingExposure', m.toneMappingExposure),
              g.needsLights &&
                ((R = T),
                ((L = C).ambientLightColor.needsUpdate = R),
                (L.lightProbe.needsUpdate = R),
                (L.directionalLights.needsUpdate = R),
                (L.directionalLightShadows.needsUpdate = R),
                (L.pointLights.needsUpdate = R),
                (L.pointLightShadows.needsUpdate = R),
                (L.spotLights.needsUpdate = R),
                (L.spotLightShadows.needsUpdate = R),
                (L.rectAreaLights.needsUpdate = R),
                (L.hemisphereLights.needsUpdate = R)),
              s && i.fog && tt.refreshFogUniforms(C, s),
              tt.refreshMaterialUniforms(C, i, D, E, k),
              zd.upload(ht, g.uniformsList, C, X)),
            i.isShaderMaterial &&
              !0 === i.uniformsNeedUpdate &&
              (zd.upload(ht, g.uniformsList, C, X),
              (i.uniformsNeedUpdate = !1)),
            i.isSpriteMaterial && A.setValue(ht, 'center', r.center),
            A.setValue(ht, 'modelViewMatrix', r.modelViewMatrix),
            A.setValue(ht, 'normalMatrix', r.normalMatrix),
            A.setValue(ht, 'modelMatrix', r.matrixWorld),
            w
          )
        }
        bt.setAnimationLoop(function (t) {
          _t && _t(t)
        }),
          'undefined' != typeof window && bt.setContext(window),
          (this.setAnimationLoop = function (t) {
            ;(_t = t),
              ft.setAnimationLoop(t),
              null === t ? bt.stop() : bt.start()
          }),
          ft.addEventListener('sessionstart', yt),
          ft.addEventListener('sessionend', xt),
          (this.render = function (t, e) {
            if (void 0 !== e && !0 !== e.isCamera)
              return void console.error(
                'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.',
              )
            if (!0 === g) return
            !0 === t.autoUpdate && t.updateMatrixWorld(),
              null === e.parent && e.updateMatrixWorld(),
              !0 === ft.enabled &&
                !0 === ft.isPresenting &&
                (!0 === ft.cameraAutoUpdate && ft.updateCamera(e),
                (e = ft.getCamera())),
              !0 === t.isScene && t.onBeforeRender(m, t, e, y),
              (d = nt.get(t, f.length)),
              d.init(),
              f.push(d),
              B.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
              I.setFromProjectionMatrix(B),
              (N = this.localClippingEnabled),
              (O = it.init(this.clippingPlanes, N, e)),
              (h = et.get(t, p.length)),
              h.init(),
              p.push(h),
              wt(t, e, 0, m.sortObjects),
              h.finish(),
              !0 === m.sortObjects && h.sort(A, C),
              !0 === O && it.beginShadows()
            const n = d.state.shadowsArray
            if (
              (rt.render(n, t, e),
              !0 === O && it.endShadows(),
              !0 === this.info.autoReset && this.info.reset(),
              st.render(h, t),
              d.setupLights(m.physicallyCorrectLights),
              e.isArrayCamera)
            ) {
              const n = e.cameras
              for (let e = 0, i = n.length; e < i; e++) {
                const i = n[e]
                Mt(h, t, i, i.viewport)
              }
            } else Mt(h, t, e)
            null !== y &&
              (X.updateMultisampleRenderTarget(y),
              X.updateRenderTargetMipmap(y)),
              !0 === t.isScene && t.onAfterRender(m, t, e),
              W.buffers.depth.setTest(!0),
              W.buffers.depth.setMask(!0),
              W.buffers.color.setMask(!0),
              W.setPolygonOffset(!1),
              ut.resetDefaultState(),
              (x = -1),
              (b = null),
              f.pop(),
              (d = f.length > 0 ? f[f.length - 1] : null),
              p.pop(),
              (h = p.length > 0 ? p[p.length - 1] : null)
          }),
          (this.getActiveCubeFace = function () {
            return v
          }),
          (this.getActiveMipmapLevel = function () {
            return _
          }),
          (this.getRenderTarget = function () {
            return y
          }),
          (this.setRenderTarget = function (t, e = 0, n = 0) {
            ;(y = t),
              (v = e),
              (_ = n),
              t &&
                void 0 === q.get(t).__webglFramebuffer &&
                X.setupRenderTarget(t)
            let i = null,
              r = !1,
              s = !1
            if (t) {
              const n = t.texture
              ;(n.isDataTexture3D || n.isDataTexture2DArray) && (s = !0)
              const o = q.get(t).__webglFramebuffer
              t.isWebGLCubeRenderTarget
                ? ((i = o[e]), (r = !0))
                : (i = t.isWebGLMultisampleRenderTarget
                    ? q.get(t).__webglMultisampledFramebuffer
                    : o),
                w.copy(t.viewport),
                M.copy(t.scissor),
                (S = t.scissorTest)
            } else
              w.copy(L).multiplyScalar(D).floor(),
                M.copy(R).multiplyScalar(D).floor(),
                (S = P)
            if (W.bindFramebuffer(36160, i) && V.drawBuffers) {
              let e = !1
              if (t)
                if (t.isWebGLMultipleRenderTargets) {
                  const n = t.texture
                  if (F.length !== n.length || 36064 !== F[0]) {
                    for (let t = 0, e = n.length; t < e; t++) F[t] = 36064 + t
                    ;(F.length = n.length), (e = !0)
                  }
                } else
                  (1 === F.length && 36064 === F[0]) ||
                    ((F[0] = 36064), (F.length = 1), (e = !0))
              else
                (1 === F.length && 1029 === F[0]) ||
                  ((F[0] = 1029), (F.length = 1), (e = !0))
              e &&
                (V.isWebGL2
                  ? ht.drawBuffers(F)
                  : G.get('WEBGL_draw_buffers').drawBuffersWEBGL(F))
            }
            if ((W.viewport(w), W.scissor(M), W.setScissorTest(S), r)) {
              const i = q.get(t.texture)
              ht.framebufferTexture2D(
                36160,
                36064,
                34069 + e,
                i.__webglTexture,
                n,
              )
            } else if (s) {
              const i = q.get(t.texture),
                r = e || 0
              ht.framebufferTextureLayer(
                36160,
                36064,
                i.__webglTexture,
                n || 0,
                r,
              )
            }
            x = -1
          }),
          (this.readRenderTargetPixels = function (t, e, n, i, r, s, o) {
            if (!t || !t.isWebGLRenderTarget)
              return void console.error(
                'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.',
              )
            let a = q.get(t).__webglFramebuffer
            if ((t.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a)) {
              W.bindFramebuffer(36160, a)
              try {
                const o = t.texture,
                  a = o.format,
                  l = o.type
                if (a !== Oa && ct.convert(a) !== ht.getParameter(35739))
                  return void console.error(
                    'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.',
                  )
                const c =
                  l === Pa &&
                  (G.has('EXT_color_buffer_half_float') ||
                    (V.isWebGL2 && G.has('EXT_color_buffer_float')))
                if (
                  !(
                    l === Aa ||
                    ct.convert(l) === ht.getParameter(35738) ||
                    (l === Ra &&
                      (V.isWebGL2 ||
                        G.has('OES_texture_float') ||
                        G.has('WEBGL_color_buffer_float'))) ||
                    c
                  )
                )
                  return void console.error(
                    'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.',
                  )
                36053 === ht.checkFramebufferStatus(36160)
                  ? e >= 0 &&
                    e <= t.width - i &&
                    n >= 0 &&
                    n <= t.height - r &&
                    ht.readPixels(e, n, i, r, ct.convert(a), ct.convert(l), s)
                  : console.error(
                      'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.',
                    )
              } finally {
                const t = null !== y ? q.get(y).__webglFramebuffer : null
                W.bindFramebuffer(36160, t)
              }
            }
          }),
          (this.copyFramebufferToTexture = function (t, e, n = 0) {
            const i = Math.pow(2, -n),
              r = Math.floor(e.image.width * i),
              s = Math.floor(e.image.height * i)
            let o = ct.convert(e.format)
            V.isWebGL2 &&
              (6407 === o && (o = 32849), 6408 === o && (o = 32856)),
              X.setTexture2D(e, 0),
              ht.copyTexImage2D(3553, n, o, t.x, t.y, r, s, 0),
              W.unbindTexture()
          }),
          (this.copyTextureToTexture = function (t, e, n, i = 0) {
            const r = e.image.width,
              s = e.image.height,
              o = ct.convert(n.format),
              a = ct.convert(n.type)
            X.setTexture2D(n, 0),
              ht.pixelStorei(37440, n.flipY),
              ht.pixelStorei(37441, n.premultiplyAlpha),
              ht.pixelStorei(3317, n.unpackAlignment),
              e.isDataTexture
                ? ht.texSubImage2D(3553, i, t.x, t.y, r, s, o, a, e.image.data)
                : e.isCompressedTexture
                ? ht.compressedTexSubImage2D(
                    3553,
                    i,
                    t.x,
                    t.y,
                    e.mipmaps[0].width,
                    e.mipmaps[0].height,
                    o,
                    e.mipmaps[0].data,
                  )
                : ht.texSubImage2D(3553, i, t.x, t.y, o, a, e.image),
              0 === i && n.generateMipmaps && ht.generateMipmap(3553),
              W.unbindTexture()
          }),
          (this.copyTextureToTexture3D = function (t, e, n, i, r = 0) {
            if (m.isWebGL1Renderer)
              return void console.warn(
                'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.',
              )
            const s = t.max.x - t.min.x + 1,
              o = t.max.y - t.min.y + 1,
              a = t.max.z - t.min.z + 1,
              l = ct.convert(i.format),
              c = ct.convert(i.type)
            let u
            if (i.isDataTexture3D) X.setTexture3D(i, 0), (u = 32879)
            else {
              if (!i.isDataTexture2DArray)
                return void console.warn(
                  'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.',
                )
              X.setTexture2DArray(i, 0), (u = 35866)
            }
            ht.pixelStorei(37440, i.flipY),
              ht.pixelStorei(37441, i.premultiplyAlpha),
              ht.pixelStorei(3317, i.unpackAlignment)
            const h = ht.getParameter(3314),
              d = ht.getParameter(32878),
              p = ht.getParameter(3316),
              f = ht.getParameter(3315),
              g = ht.getParameter(32877),
              v = n.isCompressedTexture ? n.mipmaps[0] : n.image
            ht.pixelStorei(3314, v.width),
              ht.pixelStorei(32878, v.height),
              ht.pixelStorei(3316, t.min.x),
              ht.pixelStorei(3315, t.min.y),
              ht.pixelStorei(32877, t.min.z),
              n.isDataTexture || n.isDataTexture3D
                ? ht.texSubImage3D(u, r, e.x, e.y, e.z, s, o, a, l, c, v.data)
                : n.isCompressedTexture
                ? (console.warn(
                    'THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.',
                  ),
                  ht.compressedTexSubImage3D(
                    u,
                    r,
                    e.x,
                    e.y,
                    e.z,
                    s,
                    o,
                    a,
                    l,
                    v.data,
                  ))
                : ht.texSubImage3D(u, r, e.x, e.y, e.z, s, o, a, l, c, v),
              ht.pixelStorei(3314, h),
              ht.pixelStorei(32878, d),
              ht.pixelStorei(3316, p),
              ht.pixelStorei(3315, f),
              ht.pixelStorei(32877, g),
              0 === r && i.generateMipmaps && ht.generateMipmap(u),
              W.unbindTexture()
          }),
          (this.initTexture = function (t) {
            X.setTexture2D(t, 0), W.unbindTexture()
          }),
          (this.resetState = function () {
            ;(v = 0), (_ = 0), (y = null), W.reset(), ut.reset()
          }),
          'undefined' != typeof __THREE_DEVTOOLS__ &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent('observe', { detail: this }),
            )
      }
      ;(class extends Lp {}.prototype.isWebGL1Renderer = !0)
      class Rp {
        constructor(t, e = 25e-5) {
          ;(this.name = ''), (this.color = new Xc(t)), (this.density = e)
        }
        clone() {
          return new Rp(this.color, this.density)
        }
        toJSON() {
          return {
            type: 'FogExp2',
            color: this.color.getHex(),
            density: this.density,
          }
        }
      }
      Rp.prototype.isFogExp2 = !0
      class Pp {
        constructor(t, e = 1, n = 1e3) {
          ;(this.name = ''),
            (this.color = new Xc(t)),
            (this.near = e),
            (this.far = n)
        }
        clone() {
          return new Pp(this.color, this.near, this.far)
        }
        toJSON() {
          return {
            type: 'Fog',
            color: this.color.getHex(),
            near: this.near,
            far: this.far,
          }
        }
      }
      Pp.prototype.isFog = !0
      class Fp extends Dc {
        constructor() {
          super(),
            (this.type = 'Scene'),
            (this.background = null),
            (this.environment = null),
            (this.fog = null),
            (this.overrideMaterial = null),
            (this.autoUpdate = !0),
            'undefined' != typeof __THREE_DEVTOOLS__ &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent('observe', { detail: this }),
              )
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            null !== t.background && (this.background = t.background.clone()),
            null !== t.environment &&
              (this.environment = t.environment.clone()),
            null !== t.fog && (this.fog = t.fog.clone()),
            null !== t.overrideMaterial &&
              (this.overrideMaterial = t.overrideMaterial.clone()),
            (this.autoUpdate = t.autoUpdate),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            this
          )
        }
        toJSON(t) {
          const e = super.toJSON(t)
          return null !== this.fog && (e.object.fog = this.fog.toJSON()), e
        }
      }
      Fp.prototype.isScene = !0
      class Ip {
        constructor(t, e) {
          ;(this.array = t),
            (this.stride = e),
            (this.count = void 0 !== t ? t.length / e : 0),
            (this.usage = Ja),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0),
            (this.uuid = rl())
        }
        onUploadCallback() {}
        set needsUpdate(t) {
          !0 === t && this.version++
        }
        setUsage(t) {
          return (this.usage = t), this
        }
        copy(t) {
          return (
            (this.array = new t.array.constructor(t.array)),
            (this.count = t.count),
            (this.stride = t.stride),
            (this.usage = t.usage),
            this
          )
        }
        copyAt(t, e, n) {
          ;(t *= this.stride), (n *= e.stride)
          for (let i = 0, r = this.stride; i < r; i++)
            this.array[t + i] = e.array[n + i]
          return this
        }
        set(t, e = 0) {
          return this.array.set(t, e), this
        }
        clone(t) {
          void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid &&
              (this.array.buffer._uuid = rl()),
            void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
              (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(
                0,
              ).buffer)
          const e = new this.array.constructor(
              t.arrayBuffers[this.array.buffer._uuid],
            ),
            n = new this.constructor(e, this.stride)
          return n.setUsage(this.usage), n
        }
        onUpload(t) {
          return (this.onUploadCallback = t), this
        }
        toJSON(t) {
          return (
            void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid &&
              (this.array.buffer._uuid = rl()),
            void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
              (t.arrayBuffers[
                this.array.buffer._uuid
              ] = Array.prototype.slice.call(
                new Uint32Array(this.array.buffer),
              )),
            {
              uuid: this.uuid,
              buffer: this.array.buffer._uuid,
              type: this.array.constructor.name,
              stride: this.stride,
            }
          )
        }
      }
      Ip.prototype.isInterleavedBuffer = !0
      const Op = new Tl()
      class Np {
        constructor(t, e, n, i = !1) {
          ;(this.name = ''),
            (this.data = t),
            (this.itemSize = e),
            (this.offset = n),
            (this.normalized = !0 === i)
        }
        get count() {
          return this.data.count
        }
        get array() {
          return this.data.array
        }
        set needsUpdate(t) {
          this.data.needsUpdate = t
        }
        applyMatrix4(t) {
          for (let e = 0, n = this.data.count; e < n; e++)
            (Op.x = this.getX(e)),
              (Op.y = this.getY(e)),
              (Op.z = this.getZ(e)),
              Op.applyMatrix4(t),
              this.setXYZ(e, Op.x, Op.y, Op.z)
          return this
        }
        applyNormalMatrix(t) {
          for (let e = 0, n = this.count; e < n; e++)
            (Op.x = this.getX(e)),
              (Op.y = this.getY(e)),
              (Op.z = this.getZ(e)),
              Op.applyNormalMatrix(t),
              this.setXYZ(e, Op.x, Op.y, Op.z)
          return this
        }
        transformDirection(t) {
          for (let e = 0, n = this.count; e < n; e++)
            (Op.x = this.getX(e)),
              (Op.y = this.getY(e)),
              (Op.z = this.getZ(e)),
              Op.transformDirection(t),
              this.setXYZ(e, Op.x, Op.y, Op.z)
          return this
        }
        setX(t, e) {
          return (this.data.array[t * this.data.stride + this.offset] = e), this
        }
        setY(t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset + 1] = e), this
          )
        }
        setZ(t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset + 2] = e), this
          )
        }
        setW(t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset + 3] = e), this
          )
        }
        getX(t) {
          return this.data.array[t * this.data.stride + this.offset]
        }
        getY(t) {
          return this.data.array[t * this.data.stride + this.offset + 1]
        }
        getZ(t) {
          return this.data.array[t * this.data.stride + this.offset + 2]
        }
        getW(t) {
          return this.data.array[t * this.data.stride + this.offset + 3]
        }
        setXY(t, e, n) {
          return (
            (t = t * this.data.stride + this.offset),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = n),
            this
          )
        }
        setXYZ(t, e, n, i) {
          return (
            (t = t * this.data.stride + this.offset),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = n),
            (this.data.array[t + 2] = i),
            this
          )
        }
        setXYZW(t, e, n, i, r) {
          return (
            (t = t * this.data.stride + this.offset),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = n),
            (this.data.array[t + 2] = i),
            (this.data.array[t + 3] = r),
            this
          )
        }
        clone(t) {
          if (void 0 === t) {
            console.log(
              'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.',
            )
            const t = []
            for (let e = 0; e < this.count; e++) {
              const n = e * this.data.stride + this.offset
              for (let e = 0; e < this.itemSize; e++)
                t.push(this.data.array[n + e])
            }
            return new Kc(
              new this.array.constructor(t),
              this.itemSize,
              this.normalized,
            )
          }
          return (
            void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
            void 0 === t.interleavedBuffers[this.data.uuid] &&
              (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
            new Np(
              t.interleavedBuffers[this.data.uuid],
              this.itemSize,
              this.offset,
              this.normalized,
            )
          )
        }
        toJSON(t) {
          if (void 0 === t) {
            console.log(
              'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.',
            )
            const t = []
            for (let e = 0; e < this.count; e++) {
              const n = e * this.data.stride + this.offset
              for (let e = 0; e < this.itemSize; e++)
                t.push(this.data.array[n + e])
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: t,
              normalized: this.normalized,
            }
          }
          return (
            void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
            void 0 === t.interleavedBuffers[this.data.uuid] &&
              (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
            {
              isInterleavedBufferAttribute: !0,
              itemSize: this.itemSize,
              data: this.data.uuid,
              offset: this.offset,
              normalized: this.normalized,
            }
          )
        }
      }
      Np.prototype.isInterleavedBufferAttribute = !0
      class kp extends Uc {
        constructor(t) {
          super(),
            (this.type = 'SpriteMaterial'),
            (this.color = new Xc(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.rotation = 0),
            (this.sizeAttenuation = !0),
            (this.transparent = !0),
            this.setValues(t)
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.rotation = t.rotation),
            (this.sizeAttenuation = t.sizeAttenuation),
            this
          )
        }
      }
      let Bp
      kp.prototype.isSpriteMaterial = !0
      const zp = new Tl(),
        Up = new Tl(),
        Hp = new Tl(),
        Gp = new dl(),
        Vp = new dl(),
        Wp = new nc(),
        jp = new Tl(),
        qp = new Tl(),
        Xp = new Tl(),
        Yp = new dl(),
        Jp = new dl(),
        Zp = new dl()
      function Kp(t, e, n, i, r, s) {
        Gp.subVectors(t, n).addScalar(0.5).multiply(i),
          void 0 !== r
            ? ((Vp.x = s * Gp.x - r * Gp.y), (Vp.y = r * Gp.x + s * Gp.y))
            : Vp.copy(Gp),
          t.copy(e),
          (t.x += Vp.x),
          (t.y += Vp.y),
          t.applyMatrix4(Wp)
      }
      ;(class extends Dc {
        constructor(t) {
          if ((super(), (this.type = 'Sprite'), void 0 === Bp)) {
            Bp = new lu()
            const t = new Float32Array([
                -0.5,
                -0.5,
                0,
                0,
                0,
                0.5,
                -0.5,
                0,
                1,
                0,
                0.5,
                0.5,
                0,
                1,
                1,
                -0.5,
                0.5,
                0,
                0,
                1,
              ]),
              e = new Ip(t, 5)
            Bp.setIndex([0, 1, 2, 0, 2, 3]),
              Bp.setAttribute('position', new Np(e, 3, 0, !1)),
              Bp.setAttribute('uv', new Np(e, 2, 3, !1))
          }
          ;(this.geometry = Bp),
            (this.material = void 0 !== t ? t : new kp()),
            (this.center = new dl(0.5, 0.5))
        }
        raycast(t, e) {
          null === t.camera &&
            console.error(
              'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.',
            ),
            Up.setFromMatrixScale(this.matrixWorld),
            Wp.copy(t.camera.matrixWorld),
            this.modelViewMatrix.multiplyMatrices(
              t.camera.matrixWorldInverse,
              this.matrixWorld,
            ),
            Hp.setFromMatrixPosition(this.modelViewMatrix),
            t.camera.isPerspectiveCamera &&
              !1 === this.material.sizeAttenuation &&
              Up.multiplyScalar(-Hp.z)
          const n = this.material.rotation
          let i, r
          0 !== n && ((r = Math.cos(n)), (i = Math.sin(n)))
          const s = this.center
          Kp(jp.set(-0.5, -0.5, 0), Hp, s, Up, i, r),
            Kp(qp.set(0.5, -0.5, 0), Hp, s, Up, i, r),
            Kp(Xp.set(0.5, 0.5, 0), Hp, s, Up, i, r),
            Yp.set(0, 0),
            Jp.set(1, 0),
            Zp.set(1, 1)
          let o = t.ray.intersectTriangle(jp, qp, Xp, !1, zp)
          if (
            null === o &&
            (Kp(qp.set(-0.5, 0.5, 0), Hp, s, Up, i, r),
            Jp.set(0, 1),
            (o = t.ray.intersectTriangle(jp, Xp, qp, !1, zp)),
            null === o)
          )
            return
          const a = t.ray.origin.distanceTo(zp)
          a < t.near ||
            a > t.far ||
            e.push({
              distance: a,
              point: zp.clone(),
              uv: Bc.getUV(zp, jp, qp, Xp, Yp, Jp, Zp, new dl()),
              face: null,
              object: this,
            })
        }
        copy(t) {
          return (
            super.copy(t),
            void 0 !== t.center && this.center.copy(t.center),
            (this.material = t.material),
            this
          )
        }
      }.prototype.isSprite = !0)
      const Qp = new Tl(),
        $p = new bl(),
        tf = new bl(),
        ef = new Tl(),
        nf = new nc()
      class rf extends Eu {
        constructor(t, e) {
          super(t, e),
            (this.type = 'SkinnedMesh'),
            (this.bindMode = 'attached'),
            (this.bindMatrix = new nc()),
            (this.bindMatrixInverse = new nc())
        }
        copy(t) {
          return (
            super.copy(t),
            (this.bindMode = t.bindMode),
            this.bindMatrix.copy(t.bindMatrix),
            this.bindMatrixInverse.copy(t.bindMatrixInverse),
            (this.skeleton = t.skeleton),
            this
          )
        }
        bind(t, e) {
          ;(this.skeleton = t),
            void 0 === e &&
              (this.updateMatrixWorld(!0),
              this.skeleton.calculateInverses(),
              (e = this.matrixWorld)),
            this.bindMatrix.copy(e),
            this.bindMatrixInverse.copy(e).invert()
        }
        pose() {
          this.skeleton.pose()
        }
        normalizeSkinWeights() {
          const t = new bl(),
            e = this.geometry.attributes.skinWeight
          for (let n = 0, i = e.count; n < i; n++) {
            ;(t.x = e.getX(n)),
              (t.y = e.getY(n)),
              (t.z = e.getZ(n)),
              (t.w = e.getW(n))
            const i = 1 / t.manhattanLength()
            i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),
              e.setXYZW(n, t.x, t.y, t.z, t.w)
          }
        }
        updateMatrixWorld(t) {
          super.updateMatrixWorld(t),
            'attached' === this.bindMode
              ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
              : 'detached' === this.bindMode
              ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
              : console.warn(
                  'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode,
                )
        }
        boneTransform(t, e) {
          const n = this.skeleton,
            i = this.geometry
          $p.fromBufferAttribute(i.attributes.skinIndex, t),
            tf.fromBufferAttribute(i.attributes.skinWeight, t),
            Qp.copy(e).applyMatrix4(this.bindMatrix),
            e.set(0, 0, 0)
          for (let t = 0; t < 4; t++) {
            const i = tf.getComponent(t)
            if (0 !== i) {
              const r = $p.getComponent(t)
              nf.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
                e.addScaledVector(ef.copy(Qp).applyMatrix4(nf), i)
            }
          }
          return e.applyMatrix4(this.bindMatrixInverse)
        }
      }
      rf.prototype.isSkinnedMesh = !0
      class sf extends Dc {
        constructor() {
          super(), (this.type = 'Bone')
        }
      }
      sf.prototype.isBone = !0
      class of extends yl {
        constructor(
          t = null,
          e = 1,
          n = 1,
          i,
          r,
          s,
          o,
          a,
          l = 1003,
          c = 1003,
          u,
          h,
        ) {
          super(null, s, o, a, l, c, i, r, u, h),
            (this.image = { data: t, width: e, height: n }),
            (this.magFilter = l),
            (this.minFilter = c),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1),
            (this.needsUpdate = !0)
        }
      }
      of.prototype.isDataTexture = !0
      const af = new nc(),
        lf = new nc()
      class cf {
        constructor(t = [], e = []) {
          ;(this.uuid = rl()),
            (this.bones = t.slice(0)),
            (this.boneInverses = e),
            (this.boneMatrices = null),
            (this.boneTexture = null),
            (this.boneTextureSize = 0),
            (this.frame = -1),
            this.init()
        }
        init() {
          const t = this.bones,
            e = this.boneInverses
          if (
            ((this.boneMatrices = new Float32Array(16 * t.length)),
            0 === e.length)
          )
            this.calculateInverses()
          else if (t.length !== e.length) {
            console.warn(
              'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.',
            ),
              (this.boneInverses = [])
            for (let t = 0, e = this.bones.length; t < e; t++)
              this.boneInverses.push(new nc())
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0
          for (let t = 0, e = this.bones.length; t < e; t++) {
            const e = new nc()
            this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(),
              this.boneInverses.push(e)
          }
        }
        pose() {
          for (let t = 0, e = this.bones.length; t < e; t++) {
            const e = this.bones[t]
            e && e.matrixWorld.copy(this.boneInverses[t]).invert()
          }
          for (let t = 0, e = this.bones.length; t < e; t++) {
            const e = this.bones[t]
            e &&
              (e.parent && e.parent.isBone
                ? (e.matrix.copy(e.parent.matrixWorld).invert(),
                  e.matrix.multiply(e.matrixWorld))
                : e.matrix.copy(e.matrixWorld),
              e.matrix.decompose(e.position, e.quaternion, e.scale))
          }
        }
        update() {
          const t = this.bones,
            e = this.boneInverses,
            n = this.boneMatrices,
            i = this.boneTexture
          for (let i = 0, r = t.length; i < r; i++) {
            const r = t[i] ? t[i].matrixWorld : lf
            af.multiplyMatrices(r, e[i]), af.toArray(n, 16 * i)
          }
          null !== i && (i.needsUpdate = !0)
        }
        clone() {
          return new cf(this.bones, this.boneInverses)
        }
        computeBoneTexture() {
          let t = Math.sqrt(4 * this.bones.length)
          ;(t = cl(t)), (t = Math.max(t, 4))
          const e = new Float32Array(t * t * 4)
          e.set(this.boneMatrices)
          const n = new of(e, t, t, Oa, Ra)
          return (
            (this.boneMatrices = e),
            (this.boneTexture = n),
            (this.boneTextureSize = t),
            this
          )
        }
        getBoneByName(t) {
          for (let e = 0, n = this.bones.length; e < n; e++) {
            const n = this.bones[e]
            if (n.name === t) return n
          }
        }
        dispose() {
          null !== this.boneTexture &&
            (this.boneTexture.dispose(), (this.boneTexture = null))
        }
        fromJSON(t, e) {
          this.uuid = t.uuid
          for (let n = 0, i = t.bones.length; n < i; n++) {
            const i = t.bones[n]
            let r = e[i]
            void 0 === r &&
              (console.warn('THREE.Skeleton: No bone found with UUID:', i),
              (r = new sf())),
              this.bones.push(r),
              this.boneInverses.push(new nc().fromArray(t.boneInverses[n]))
          }
          return this.init(), this
        }
        toJSON() {
          const t = {
            metadata: {
              version: 4.5,
              type: 'Skeleton',
              generator: 'Skeleton.toJSON',
            },
            bones: [],
            boneInverses: [],
          }
          t.uuid = this.uuid
          const e = this.bones,
            n = this.boneInverses
          for (let i = 0, r = e.length; i < r; i++) {
            const r = e[i]
            t.bones.push(r.uuid)
            const s = n[i]
            t.boneInverses.push(s.toArray())
          }
          return t
        }
      }
      class uf extends Kc {
        constructor(t, e, n, i = 1) {
          'number' == typeof n &&
            ((i = n),
            (n = !1),
            console.error(
              'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.',
            )),
            super(t, e, n),
            (this.meshPerAttribute = i)
        }
        copy(t) {
          return (
            super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
          )
        }
        toJSON() {
          const t = super.toJSON()
          return (
            (t.meshPerAttribute = this.meshPerAttribute),
            (t.isInstancedBufferAttribute = !0),
            t
          )
        }
      }
      uf.prototype.isInstancedBufferAttribute = !0
      const hf = new nc(),
        df = new nc(),
        pf = [],
        ff = new Eu()
      ;(class extends Eu {
        constructor(t, e, n) {
          super(t, e),
            (this.instanceMatrix = new uf(new Float32Array(16 * n), 16)),
            (this.instanceColor = null),
            (this.count = n),
            (this.frustumCulled = !1)
        }
        copy(t) {
          return (
            super.copy(t),
            this.instanceMatrix.copy(t.instanceMatrix),
            null !== t.instanceColor &&
              (this.instanceColor = t.instanceColor.clone()),
            (this.count = t.count),
            this
          )
        }
        getColorAt(t, e) {
          e.fromArray(this.instanceColor.array, 3 * t)
        }
        getMatrixAt(t, e) {
          e.fromArray(this.instanceMatrix.array, 16 * t)
        }
        raycast(t, e) {
          const n = this.matrixWorld,
            i = this.count
          if (
            ((ff.geometry = this.geometry),
            (ff.material = this.material),
            void 0 !== ff.material)
          )
            for (let r = 0; r < i; r++) {
              this.getMatrixAt(r, hf),
                df.multiplyMatrices(n, hf),
                (ff.matrixWorld = df),
                ff.raycast(t, pf)
              for (let t = 0, n = pf.length; t < n; t++) {
                const n = pf[t]
                ;(n.instanceId = r), (n.object = this), e.push(n)
              }
              pf.length = 0
            }
        }
        setColorAt(t, e) {
          null === this.instanceColor &&
            (this.instanceColor = new uf(
              new Float32Array(3 * this.instanceMatrix.count),
              3,
            )),
            e.toArray(this.instanceColor.array, 3 * t)
        }
        setMatrixAt(t, e) {
          e.toArray(this.instanceMatrix.array, 16 * t)
        }
        updateMorphTargets() {}
        dispose() {
          this.dispatchEvent({ type: 'dispose' })
        }
      }.prototype.isInstancedMesh = !0)
      class mf extends Uc {
        constructor(t) {
          super(),
            (this.type = 'LineBasicMaterial'),
            (this.color = new Xc(16777215)),
            (this.linewidth = 1),
            (this.linecap = 'round'),
            (this.linejoin = 'round'),
            this.setValues(t)
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.linewidth = t.linewidth),
            (this.linecap = t.linecap),
            (this.linejoin = t.linejoin),
            this
          )
        }
      }
      mf.prototype.isLineBasicMaterial = !0
      const gf = new Tl(),
        vf = new Tl(),
        _f = new nc(),
        yf = new ec(),
        xf = new Xl()
      class bf extends Dc {
        constructor(t = new lu(), e = new mf()) {
          super(),
            (this.type = 'Line'),
            (this.geometry = t),
            (this.material = e),
            this.updateMorphTargets()
        }
        copy(t) {
          return (
            super.copy(t),
            (this.material = t.material),
            (this.geometry = t.geometry),
            this
          )
        }
        computeLineDistances() {
          const t = this.geometry
          if (t.isBufferGeometry)
            if (null === t.index) {
              const e = t.attributes.position,
                n = [0]
              for (let t = 1, i = e.count; t < i; t++)
                gf.fromBufferAttribute(e, t - 1),
                  vf.fromBufferAttribute(e, t),
                  (n[t] = n[t - 1]),
                  (n[t] += gf.distanceTo(vf))
              t.setAttribute('lineDistance', new tu(n, 1))
            } else
              console.warn(
                'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.',
              )
          else
            t.isGeometry &&
              console.error(
                'THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',
              )
          return this
        }
        raycast(t, e) {
          const n = this.geometry,
            i = this.matrixWorld,
            r = t.params.Line.threshold,
            s = n.drawRange
          if (
            (null === n.boundingSphere && n.computeBoundingSphere(),
            xf.copy(n.boundingSphere),
            xf.applyMatrix4(i),
            (xf.radius += r),
            !1 === t.ray.intersectsSphere(xf))
          )
            return
          _f.copy(i).invert(), yf.copy(t.ray).applyMatrix4(_f)
          const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            a = o * o,
            l = new Tl(),
            c = new Tl(),
            u = new Tl(),
            h = new Tl(),
            d = this.isLineSegments ? 2 : 1
          if (n.isBufferGeometry) {
            const i = n.index,
              r = n.attributes.position
            if (null !== i)
              for (
                let n = Math.max(0, s.start),
                  o = Math.min(i.count, s.start + s.count) - 1;
                n < o;
                n += d
              ) {
                const s = i.getX(n),
                  o = i.getX(n + 1)
                if (
                  (l.fromBufferAttribute(r, s),
                  c.fromBufferAttribute(r, o),
                  yf.distanceSqToSegment(l, c, h, u) > a)
                )
                  continue
                h.applyMatrix4(this.matrixWorld)
                const d = t.ray.origin.distanceTo(h)
                d < t.near ||
                  d > t.far ||
                  e.push({
                    distance: d,
                    point: u.clone().applyMatrix4(this.matrixWorld),
                    index: n,
                    face: null,
                    faceIndex: null,
                    object: this,
                  })
              }
            else
              for (
                let n = Math.max(0, s.start),
                  i = Math.min(r.count, s.start + s.count) - 1;
                n < i;
                n += d
              ) {
                if (
                  (l.fromBufferAttribute(r, n),
                  c.fromBufferAttribute(r, n + 1),
                  yf.distanceSqToSegment(l, c, h, u) > a)
                )
                  continue
                h.applyMatrix4(this.matrixWorld)
                const i = t.ray.origin.distanceTo(h)
                i < t.near ||
                  i > t.far ||
                  e.push({
                    distance: i,
                    point: u.clone().applyMatrix4(this.matrixWorld),
                    index: n,
                    face: null,
                    faceIndex: null,
                    object: this,
                  })
              }
          } else
            n.isGeometry &&
              console.error(
                'THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',
              )
        }
        updateMorphTargets() {
          const t = this.geometry
          if (t.isBufferGeometry) {
            const e = t.morphAttributes,
              n = Object.keys(e)
            if (n.length > 0) {
              const t = e[n[0]]
              if (void 0 !== t) {
                ;(this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {})
                for (let e = 0, n = t.length; e < n; e++) {
                  const n = t[e].name || String(e)
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[n] = e)
                }
              }
            }
          } else {
            const e = t.morphTargets
            void 0 !== e &&
              e.length > 0 &&
              console.error(
                'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.',
              )
          }
        }
      }
      bf.prototype.isLine = !0
      const wf = new Tl(),
        Mf = new Tl()
      class Sf extends bf {
        constructor(t, e) {
          super(t, e), (this.type = 'LineSegments')
        }
        computeLineDistances() {
          const t = this.geometry
          if (t.isBufferGeometry)
            if (null === t.index) {
              const e = t.attributes.position,
                n = []
              for (let t = 0, i = e.count; t < i; t += 2)
                wf.fromBufferAttribute(e, t),
                  Mf.fromBufferAttribute(e, t + 1),
                  (n[t] = 0 === t ? 0 : n[t - 1]),
                  (n[t + 1] = n[t] + wf.distanceTo(Mf))
              t.setAttribute('lineDistance', new tu(n, 1))
            } else
              console.warn(
                'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.',
              )
          else
            t.isGeometry &&
              console.error(
                'THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',
              )
          return this
        }
      }
      Sf.prototype.isLineSegments = !0
      class Tf extends bf {
        constructor(t, e) {
          super(t, e), (this.type = 'LineLoop')
        }
      }
      Tf.prototype.isLineLoop = !0
      class Ef extends Uc {
        constructor(t) {
          super(),
            (this.type = 'PointsMaterial'),
            (this.color = new Xc(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.size = 1),
            (this.sizeAttenuation = !0),
            this.setValues(t)
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.size = t.size),
            (this.sizeAttenuation = t.sizeAttenuation),
            this
          )
        }
      }
      Ef.prototype.isPointsMaterial = !0
      const Df = new nc(),
        Af = new ec(),
        Cf = new Xl(),
        Lf = new Tl()
      class Rf extends Dc {
        constructor(t = new lu(), e = new Ef()) {
          super(),
            (this.type = 'Points'),
            (this.geometry = t),
            (this.material = e),
            this.updateMorphTargets()
        }
        copy(t) {
          return (
            super.copy(t),
            (this.material = t.material),
            (this.geometry = t.geometry),
            this
          )
        }
        raycast(t, e) {
          const n = this.geometry,
            i = this.matrixWorld,
            r = t.params.Points.threshold,
            s = n.drawRange
          if (
            (null === n.boundingSphere && n.computeBoundingSphere(),
            Cf.copy(n.boundingSphere),
            Cf.applyMatrix4(i),
            (Cf.radius += r),
            !1 === t.ray.intersectsSphere(Cf))
          )
            return
          Df.copy(i).invert(), Af.copy(t.ray).applyMatrix4(Df)
          const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            a = o * o
          if (n.isBufferGeometry) {
            const r = n.index,
              o = n.attributes.position
            if (null !== r)
              for (
                let n = Math.max(0, s.start),
                  l = Math.min(r.count, s.start + s.count);
                n < l;
                n++
              ) {
                const s = r.getX(n)
                Lf.fromBufferAttribute(o, s), Pf(Lf, s, a, i, t, e, this)
              }
            else
              for (
                let n = Math.max(0, s.start),
                  r = Math.min(o.count, s.start + s.count);
                n < r;
                n++
              )
                Lf.fromBufferAttribute(o, n), Pf(Lf, n, a, i, t, e, this)
          } else
            console.error(
              'THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',
            )
        }
        updateMorphTargets() {
          const t = this.geometry
          if (t.isBufferGeometry) {
            const e = t.morphAttributes,
              n = Object.keys(e)
            if (n.length > 0) {
              const t = e[n[0]]
              if (void 0 !== t) {
                ;(this.morphTargetInfluences = []),
                  (this.morphTargetDictionary = {})
                for (let e = 0, n = t.length; e < n; e++) {
                  const n = t[e].name || String(e)
                  this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[n] = e)
                }
              }
            }
          } else {
            const e = t.morphTargets
            void 0 !== e &&
              e.length > 0 &&
              console.error(
                'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.',
              )
          }
        }
      }
      function Pf(t, e, n, i, r, s, o) {
        const a = Af.distanceSqToPoint(t)
        if (a < n) {
          const n = new Tl()
          Af.closestPointToPoint(t, n), n.applyMatrix4(i)
          const l = r.ray.origin.distanceTo(n)
          if (l < r.near || l > r.far) return
          s.push({
            distance: l,
            distanceToRay: Math.sqrt(a),
            point: n,
            index: e,
            face: null,
            object: o,
          })
        }
      }
      ;(Rf.prototype.isPoints = !0),
        (class extends yl {
          constructor(t, e, n, i, r, s, o, a, l) {
            super(t, e, n, i, r, s, o, a, l),
              (this.format = void 0 !== o ? o : Ia),
              (this.minFilter = void 0 !== s ? s : Ea),
              (this.magFilter = void 0 !== r ? r : Ea),
              (this.generateMipmaps = !1)
            const c = this
            'requestVideoFrameCallback' in t &&
              t.requestVideoFrameCallback(function e() {
                ;(c.needsUpdate = !0), t.requestVideoFrameCallback(e)
              })
          }
          clone() {
            return new this.constructor(this.image).copy(this)
          }
          update() {
            const t = this.image
            !1 == 'requestVideoFrameCallback' in t &&
              t.readyState >= t.HAVE_CURRENT_DATA &&
              (this.needsUpdate = !0)
          }
        }.prototype.isVideoTexture = !0)
      ;((class extends yl {
        constructor(t, e, n, i, r, s, o, a, l, c, u, h) {
          super(null, s, o, a, l, c, i, r, u, h),
            (this.image = { width: e, height: n }),
            (this.mipmaps = t),
            (this.flipY = !1),
            (this.generateMipmaps = !1)
        }
      }.prototype.isCompressedTexture = !0),
        (class extends yl {
          constructor(t, e, n, i, r, s, o, a, l) {
            super(t, e, n, i, r, s, o, a, l), (this.needsUpdate = !0)
          }
        }.prototype.isCanvasTexture = !0),
        (class extends yl {
          constructor(t, e, n, i, r, s, o, a, l, c) {
            if ((c = void 0 !== c ? c : Na) !== Na && c !== ka)
              throw new Error(
                'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat',
              )
            void 0 === n && c === Na && (n = Ca),
              void 0 === n && c === ka && (n = Fa),
              super(null, i, r, s, o, a, c, n, l),
              (this.image = { width: t, height: e }),
              (this.magFilter = void 0 !== o ? o : Ma),
              (this.minFilter = void 0 !== a ? a : Ma),
              (this.flipY = !1),
              (this.generateMipmaps = !1)
          }
        }.prototype.isDepthTexture = !0),
        new Tl(),
        new Tl(),
        new Tl(),
        new Bc())
      class Ff {
        constructor() {
          ;(this.type = 'Curve'), (this.arcLengthDivisions = 200)
        }
        getPoint() {
          return console.warn('THREE.Curve: .getPoint() not implemented.'), null
        }
        getPointAt(t, e) {
          const n = this.getUtoTmapping(t)
          return this.getPoint(n, e)
        }
        getPoints(t = 5) {
          const e = []
          for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t))
          return e
        }
        getSpacedPoints(t = 5) {
          const e = []
          for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t))
          return e
        }
        getLength() {
          const t = this.getLengths()
          return t[t.length - 1]
        }
        getLengths(t = this.arcLengthDivisions) {
          if (
            this.cacheArcLengths &&
            this.cacheArcLengths.length === t + 1 &&
            !this.needsUpdate
          )
            return this.cacheArcLengths
          this.needsUpdate = !1
          const e = []
          let n,
            i = this.getPoint(0),
            r = 0
          e.push(0)
          for (let s = 1; s <= t; s++)
            (n = this.getPoint(s / t)),
              (r += n.distanceTo(i)),
              e.push(r),
              (i = n)
          return (this.cacheArcLengths = e), e
        }
        updateArcLengths() {
          ;(this.needsUpdate = !0), this.getLengths()
        }
        getUtoTmapping(t, e) {
          const n = this.getLengths()
          let i = 0
          const r = n.length
          let s
          s = e || t * n[r - 1]
          let o,
            a = 0,
            l = r - 1
          for (; a <= l; )
            if (((i = Math.floor(a + (l - a) / 2)), (o = n[i] - s), o < 0))
              a = i + 1
            else {
              if (!(o > 0)) {
                l = i
                break
              }
              l = i - 1
            }
          if (((i = l), n[i] === s)) return i / (r - 1)
          const c = n[i]
          return (i + (s - c) / (n[i + 1] - c)) / (r - 1)
        }
        getTangent(t, e) {
          const n = 1e-4
          let i = t - n,
            r = t + n
          i < 0 && (i = 0), r > 1 && (r = 1)
          const s = this.getPoint(i),
            o = this.getPoint(r),
            a = e || (s.isVector2 ? new dl() : new Tl())
          return a.copy(o).sub(s).normalize(), a
        }
        getTangentAt(t, e) {
          const n = this.getUtoTmapping(t)
          return this.getTangent(n, e)
        }
        computeFrenetFrames(t, e) {
          const n = new Tl(),
            i = [],
            r = [],
            s = [],
            o = new Tl(),
            a = new nc()
          for (let e = 0; e <= t; e++) {
            const n = e / t
            i[e] = this.getTangentAt(n, new Tl())
          }
          ;(r[0] = new Tl()), (s[0] = new Tl())
          let l = Number.MAX_VALUE
          const c = Math.abs(i[0].x),
            u = Math.abs(i[0].y),
            h = Math.abs(i[0].z)
          c <= l && ((l = c), n.set(1, 0, 0)),
            u <= l && ((l = u), n.set(0, 1, 0)),
            h <= l && n.set(0, 0, 1),
            o.crossVectors(i[0], n).normalize(),
            r[0].crossVectors(i[0], o),
            s[0].crossVectors(i[0], r[0])
          for (let e = 1; e <= t; e++) {
            if (
              ((r[e] = r[e - 1].clone()),
              (s[e] = s[e - 1].clone()),
              o.crossVectors(i[e - 1], i[e]),
              o.length() > Number.EPSILON)
            ) {
              o.normalize()
              const t = Math.acos(sl(i[e - 1].dot(i[e]), -1, 1))
              r[e].applyMatrix4(a.makeRotationAxis(o, t))
            }
            s[e].crossVectors(i[e], r[e])
          }
          if (!0 === e) {
            let e = Math.acos(sl(r[0].dot(r[t]), -1, 1))
            ;(e /= t), i[0].dot(o.crossVectors(r[0], r[t])) > 0 && (e = -e)
            for (let n = 1; n <= t; n++)
              r[n].applyMatrix4(a.makeRotationAxis(i[n], e * n)),
                s[n].crossVectors(i[n], r[n])
          }
          return { tangents: i, normals: r, binormals: s }
        }
        clone() {
          return new this.constructor().copy(this)
        }
        copy(t) {
          return (this.arcLengthDivisions = t.arcLengthDivisions), this
        }
        toJSON() {
          const t = {
            metadata: {
              version: 4.5,
              type: 'Curve',
              generator: 'Curve.toJSON',
            },
          }
          return (
            (t.arcLengthDivisions = this.arcLengthDivisions),
            (t.type = this.type),
            t
          )
        }
        fromJSON(t) {
          return (this.arcLengthDivisions = t.arcLengthDivisions), this
        }
      }
      class If extends Ff {
        constructor(
          t = 0,
          e = 0,
          n = 1,
          i = 1,
          r = 0,
          s = 2 * Math.PI,
          o = !1,
          a = 0,
        ) {
          super(),
            (this.type = 'EllipseCurve'),
            (this.aX = t),
            (this.aY = e),
            (this.xRadius = n),
            (this.yRadius = i),
            (this.aStartAngle = r),
            (this.aEndAngle = s),
            (this.aClockwise = o),
            (this.aRotation = a)
        }
        getPoint(t, e) {
          const n = e || new dl(),
            i = 2 * Math.PI
          let r = this.aEndAngle - this.aStartAngle
          const s = Math.abs(r) < Number.EPSILON
          for (; r < 0; ) r += i
          for (; r > i; ) r -= i
          r < Number.EPSILON && (r = s ? 0 : i),
            !0 !== this.aClockwise || s || (r === i ? (r = -i) : (r -= i))
          const o = this.aStartAngle + t * r
          let a = this.aX + this.xRadius * Math.cos(o),
            l = this.aY + this.yRadius * Math.sin(o)
          if (0 !== this.aRotation) {
            const t = Math.cos(this.aRotation),
              e = Math.sin(this.aRotation),
              n = a - this.aX,
              i = l - this.aY
            ;(a = n * t - i * e + this.aX), (l = n * e + i * t + this.aY)
          }
          return n.set(a, l)
        }
        copy(t) {
          return (
            super.copy(t),
            (this.aX = t.aX),
            (this.aY = t.aY),
            (this.xRadius = t.xRadius),
            (this.yRadius = t.yRadius),
            (this.aStartAngle = t.aStartAngle),
            (this.aEndAngle = t.aEndAngle),
            (this.aClockwise = t.aClockwise),
            (this.aRotation = t.aRotation),
            this
          )
        }
        toJSON() {
          const t = super.toJSON()
          return (
            (t.aX = this.aX),
            (t.aY = this.aY),
            (t.xRadius = this.xRadius),
            (t.yRadius = this.yRadius),
            (t.aStartAngle = this.aStartAngle),
            (t.aEndAngle = this.aEndAngle),
            (t.aClockwise = this.aClockwise),
            (t.aRotation = this.aRotation),
            t
          )
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            (this.aX = t.aX),
            (this.aY = t.aY),
            (this.xRadius = t.xRadius),
            (this.yRadius = t.yRadius),
            (this.aStartAngle = t.aStartAngle),
            (this.aEndAngle = t.aEndAngle),
            (this.aClockwise = t.aClockwise),
            (this.aRotation = t.aRotation),
            this
          )
        }
      }
      If.prototype.isEllipseCurve = !0
      class Of extends If {
        constructor(t, e, n, i, r, s) {
          super(t, e, n, n, i, r, s), (this.type = 'ArcCurve')
        }
      }
      function Nf() {
        let t = 0,
          e = 0,
          n = 0,
          i = 0
        function r(r, s, o, a) {
          ;(t = r),
            (e = o),
            (n = -3 * r + 3 * s - 2 * o - a),
            (i = 2 * r - 2 * s + o + a)
        }
        return {
          initCatmullRom: function (t, e, n, i, s) {
            r(e, n, s * (n - t), s * (i - e))
          },
          initNonuniformCatmullRom: function (t, e, n, i, s, o, a) {
            let l = (e - t) / s - (n - t) / (s + o) + (n - e) / o,
              c = (n - e) / o - (i - e) / (o + a) + (i - n) / a
            ;(l *= o), (c *= o), r(e, n, l, c)
          },
          calc: function (r) {
            const s = r * r
            return t + e * r + n * s + i * (s * r)
          },
        }
      }
      Of.prototype.isArcCurve = !0
      const kf = new Tl(),
        Bf = new Nf(),
        zf = new Nf(),
        Uf = new Nf()
      class Hf extends Ff {
        constructor(t = [], e = !1, n = 'centripetal', i = 0.5) {
          super(),
            (this.type = 'CatmullRomCurve3'),
            (this.points = t),
            (this.closed = e),
            (this.curveType = n),
            (this.tension = i)
        }
        getPoint(t, e = new Tl()) {
          const n = e,
            i = this.points,
            r = i.length,
            s = (r - (this.closed ? 0 : 1)) * t
          let o,
            a,
            l = Math.floor(s),
            c = s - l
          this.closed
            ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r)
            : 0 === c && l === r - 1 && ((l = r - 2), (c = 1)),
            this.closed || l > 0
              ? (o = i[(l - 1) % r])
              : (kf.subVectors(i[0], i[1]).add(i[0]), (o = kf))
          const u = i[l % r],
            h = i[(l + 1) % r]
          if (
            (this.closed || l + 2 < r
              ? (a = i[(l + 2) % r])
              : (kf.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (a = kf)),
            'centripetal' === this.curveType || 'chordal' === this.curveType)
          ) {
            const t = 'chordal' === this.curveType ? 0.5 : 0.25
            let e = Math.pow(o.distanceToSquared(u), t),
              n = Math.pow(u.distanceToSquared(h), t),
              i = Math.pow(h.distanceToSquared(a), t)
            n < 1e-4 && (n = 1),
              e < 1e-4 && (e = n),
              i < 1e-4 && (i = n),
              Bf.initNonuniformCatmullRom(o.x, u.x, h.x, a.x, e, n, i),
              zf.initNonuniformCatmullRom(o.y, u.y, h.y, a.y, e, n, i),
              Uf.initNonuniformCatmullRom(o.z, u.z, h.z, a.z, e, n, i)
          } else
            'catmullrom' === this.curveType &&
              (Bf.initCatmullRom(o.x, u.x, h.x, a.x, this.tension),
              zf.initCatmullRom(o.y, u.y, h.y, a.y, this.tension),
              Uf.initCatmullRom(o.z, u.z, h.z, a.z, this.tension))
          return n.set(Bf.calc(c), zf.calc(c), Uf.calc(c)), n
        }
        copy(t) {
          super.copy(t), (this.points = [])
          for (let e = 0, n = t.points.length; e < n; e++) {
            const n = t.points[e]
            this.points.push(n.clone())
          }
          return (
            (this.closed = t.closed),
            (this.curveType = t.curveType),
            (this.tension = t.tension),
            this
          )
        }
        toJSON() {
          const t = super.toJSON()
          t.points = []
          for (let e = 0, n = this.points.length; e < n; e++) {
            const n = this.points[e]
            t.points.push(n.toArray())
          }
          return (
            (t.closed = this.closed),
            (t.curveType = this.curveType),
            (t.tension = this.tension),
            t
          )
        }
        fromJSON(t) {
          super.fromJSON(t), (this.points = [])
          for (let e = 0, n = t.points.length; e < n; e++) {
            const n = t.points[e]
            this.points.push(new Tl().fromArray(n))
          }
          return (
            (this.closed = t.closed),
            (this.curveType = t.curveType),
            (this.tension = t.tension),
            this
          )
        }
      }
      function Gf(t, e, n, i, r) {
        const s = 0.5 * (i - e),
          o = 0.5 * (r - n),
          a = t * t
        return (
          (2 * n - 2 * i + s + o) * (t * a) +
          (-3 * n + 3 * i - 2 * s - o) * a +
          s * t +
          n
        )
      }
      function Vf(t, e, n, i) {
        return (
          (function (t, e) {
            const n = 1 - t
            return n * n * e
          })(t, e) +
          (function (t, e) {
            return 2 * (1 - t) * t * e
          })(t, n) +
          (function (t, e) {
            return t * t * e
          })(t, i)
        )
      }
      function Wf(t, e, n, i, r) {
        return (
          (function (t, e) {
            const n = 1 - t
            return n * n * n * e
          })(t, e) +
          (function (t, e) {
            const n = 1 - t
            return 3 * n * n * t * e
          })(t, n) +
          (function (t, e) {
            return 3 * (1 - t) * t * t * e
          })(t, i) +
          (function (t, e) {
            return t * t * t * e
          })(t, r)
        )
      }
      Hf.prototype.isCatmullRomCurve3 = !0
      class jf extends Ff {
        constructor(t = new dl(), e = new dl(), n = new dl(), i = new dl()) {
          super(),
            (this.type = 'CubicBezierCurve'),
            (this.v0 = t),
            (this.v1 = e),
            (this.v2 = n),
            (this.v3 = i)
        }
        getPoint(t, e = new dl()) {
          const n = e,
            i = this.v0,
            r = this.v1,
            s = this.v2,
            o = this.v3
          return n.set(Wf(t, i.x, r.x, s.x, o.x), Wf(t, i.y, r.y, s.y, o.y)), n
        }
        copy(t) {
          return (
            super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this.v3.copy(t.v3),
            this
          )
        }
        toJSON() {
          const t = super.toJSON()
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            (t.v3 = this.v3.toArray()),
            t
          )
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this.v3.fromArray(t.v3),
            this
          )
        }
      }
      jf.prototype.isCubicBezierCurve = !0
      class qf extends Ff {
        constructor(t = new Tl(), e = new Tl(), n = new Tl(), i = new Tl()) {
          super(),
            (this.type = 'CubicBezierCurve3'),
            (this.v0 = t),
            (this.v1 = e),
            (this.v2 = n),
            (this.v3 = i)
        }
        getPoint(t, e = new Tl()) {
          const n = e,
            i = this.v0,
            r = this.v1,
            s = this.v2,
            o = this.v3
          return (
            n.set(
              Wf(t, i.x, r.x, s.x, o.x),
              Wf(t, i.y, r.y, s.y, o.y),
              Wf(t, i.z, r.z, s.z, o.z),
            ),
            n
          )
        }
        copy(t) {
          return (
            super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this.v3.copy(t.v3),
            this
          )
        }
        toJSON() {
          const t = super.toJSON()
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            (t.v3 = this.v3.toArray()),
            t
          )
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this.v3.fromArray(t.v3),
            this
          )
        }
      }
      qf.prototype.isCubicBezierCurve3 = !0
      class Xf extends Ff {
        constructor(t = new dl(), e = new dl()) {
          super(), (this.type = 'LineCurve'), (this.v1 = t), (this.v2 = e)
        }
        getPoint(t, e = new dl()) {
          const n = e
          return (
            1 === t
              ? n.copy(this.v2)
              : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(t).add(this.v1)),
            n
          )
        }
        getPointAt(t, e) {
          return this.getPoint(t, e)
        }
        getTangent(t, e) {
          const n = e || new dl()
          return n.copy(this.v2).sub(this.v1).normalize(), n
        }
        copy(t) {
          return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }
        toJSON() {
          const t = super.toJSON()
          return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
          )
        }
      }
      Xf.prototype.isLineCurve = !0
      class Yf extends Ff {
        constructor(t = new dl(), e = new dl(), n = new dl()) {
          super(),
            (this.type = 'QuadraticBezierCurve'),
            (this.v0 = t),
            (this.v1 = e),
            (this.v2 = n)
        }
        getPoint(t, e = new dl()) {
          const n = e,
            i = this.v0,
            r = this.v1,
            s = this.v2
          return n.set(Vf(t, i.x, r.x, s.x), Vf(t, i.y, r.y, s.y)), n
        }
        copy(t) {
          return (
            super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this
          )
        }
        toJSON() {
          const t = super.toJSON()
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            t
          )
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
          )
        }
      }
      Yf.prototype.isQuadraticBezierCurve = !0
      class Jf extends Ff {
        constructor(t = new Tl(), e = new Tl(), n = new Tl()) {
          super(),
            (this.type = 'QuadraticBezierCurve3'),
            (this.v0 = t),
            (this.v1 = e),
            (this.v2 = n)
        }
        getPoint(t, e = new Tl()) {
          const n = e,
            i = this.v0,
            r = this.v1,
            s = this.v2
          return (
            n.set(
              Vf(t, i.x, r.x, s.x),
              Vf(t, i.y, r.y, s.y),
              Vf(t, i.z, r.z, s.z),
            ),
            n
          )
        }
        copy(t) {
          return (
            super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this
          )
        }
        toJSON() {
          const t = super.toJSON()
          return (
            (t.v0 = this.v0.toArray()),
            (t.v1 = this.v1.toArray()),
            (t.v2 = this.v2.toArray()),
            t
          )
        }
        fromJSON(t) {
          return (
            super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
          )
        }
      }
      Jf.prototype.isQuadraticBezierCurve3 = !0
      class Zf extends Ff {
        constructor(t = []) {
          super(), (this.type = 'SplineCurve'), (this.points = t)
        }
        getPoint(t, e = new dl()) {
          const n = e,
            i = this.points,
            r = (i.length - 1) * t,
            s = Math.floor(r),
            o = r - s,
            a = i[0 === s ? s : s - 1],
            l = i[s],
            c = i[s > i.length - 2 ? i.length - 1 : s + 1],
            u = i[s > i.length - 3 ? i.length - 1 : s + 2]
          return n.set(Gf(o, a.x, l.x, c.x, u.x), Gf(o, a.y, l.y, c.y, u.y)), n
        }
        copy(t) {
          super.copy(t), (this.points = [])
          for (let e = 0, n = t.points.length; e < n; e++) {
            const n = t.points[e]
            this.points.push(n.clone())
          }
          return this
        }
        toJSON() {
          const t = super.toJSON()
          t.points = []
          for (let e = 0, n = this.points.length; e < n; e++) {
            const n = this.points[e]
            t.points.push(n.toArray())
          }
          return t
        }
        fromJSON(t) {
          super.fromJSON(t), (this.points = [])
          for (let e = 0, n = t.points.length; e < n; e++) {
            const n = t.points[e]
            this.points.push(new dl().fromArray(n))
          }
          return this
        }
      }
      Zf.prototype.isSplineCurve = !0
      var Kf = Object.freeze({
        __proto__: null,
        ArcCurve: Of,
        CatmullRomCurve3: Hf,
        CubicBezierCurve: jf,
        CubicBezierCurve3: qf,
        EllipseCurve: If,
        LineCurve: Xf,
        LineCurve3: class extends Ff {
          constructor(t = new Tl(), e = new Tl()) {
            super(),
              (this.type = 'LineCurve3'),
              (this.isLineCurve3 = !0),
              (this.v1 = t),
              (this.v2 = e)
          }
          getPoint(t, e = new Tl()) {
            const n = e
            return (
              1 === t
                ? n.copy(this.v2)
                : (n.copy(this.v2).sub(this.v1),
                  n.multiplyScalar(t).add(this.v1)),
              n
            )
          }
          getPointAt(t, e) {
            return this.getPoint(t, e)
          }
          copy(t) {
            return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
          }
          toJSON() {
            const t = super.toJSON()
            return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this
            )
          }
        },
        QuadraticBezierCurve: Yf,
        QuadraticBezierCurve3: Jf,
        SplineCurve: Zf,
      })
      class Qf extends Ff {
        constructor() {
          super(),
            (this.type = 'CurvePath'),
            (this.curves = []),
            (this.autoClose = !1)
        }
        add(t) {
          this.curves.push(t)
        }
        closePath() {
          const t = this.curves[0].getPoint(0),
            e = this.curves[this.curves.length - 1].getPoint(1)
          t.equals(e) || this.curves.push(new Xf(e, t))
        }
        getPoint(t, e) {
          const n = t * this.getLength(),
            i = this.getCurveLengths()
          let r = 0
          for (; r < i.length; ) {
            if (i[r] >= n) {
              const t = i[r] - n,
                s = this.curves[r],
                o = s.getLength(),
                a = 0 === o ? 0 : 1 - t / o
              return s.getPointAt(a, e)
            }
            r++
          }
          return null
        }
        getLength() {
          const t = this.getCurveLengths()
          return t[t.length - 1]
        }
        updateArcLengths() {
          ;(this.needsUpdate = !0),
            (this.cacheLengths = null),
            this.getCurveLengths()
        }
        getCurveLengths() {
          if (
            this.cacheLengths &&
            this.cacheLengths.length === this.curves.length
          )
            return this.cacheLengths
          const t = []
          let e = 0
          for (let n = 0, i = this.curves.length; n < i; n++)
            (e += this.curves[n].getLength()), t.push(e)
          return (this.cacheLengths = t), t
        }
        getSpacedPoints(t = 40) {
          const e = []
          for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t))
          return this.autoClose && e.push(e[0]), e
        }
        getPoints(t = 12) {
          const e = []
          let n
          for (let i = 0, r = this.curves; i < r.length; i++) {
            const s = r[i],
              o =
                s && s.isEllipseCurve
                  ? 2 * t
                  : s && (s.isLineCurve || s.isLineCurve3)
                  ? 1
                  : s && s.isSplineCurve
                  ? t * s.points.length
                  : t,
              a = s.getPoints(o)
            for (let t = 0; t < a.length; t++) {
              const i = a[t]
              ;(n && n.equals(i)) || (e.push(i), (n = i))
            }
          }
          return (
            this.autoClose &&
              e.length > 1 &&
              !e[e.length - 1].equals(e[0]) &&
              e.push(e[0]),
            e
          )
        }
        copy(t) {
          super.copy(t), (this.curves = [])
          for (let e = 0, n = t.curves.length; e < n; e++) {
            const n = t.curves[e]
            this.curves.push(n.clone())
          }
          return (this.autoClose = t.autoClose), this
        }
        toJSON() {
          const t = super.toJSON()
          ;(t.autoClose = this.autoClose), (t.curves = [])
          for (let e = 0, n = this.curves.length; e < n; e++) {
            const n = this.curves[e]
            t.curves.push(n.toJSON())
          }
          return t
        }
        fromJSON(t) {
          super.fromJSON(t), (this.autoClose = t.autoClose), (this.curves = [])
          for (let e = 0, n = t.curves.length; e < n; e++) {
            const n = t.curves[e]
            this.curves.push(new Kf[n.type]().fromJSON(n))
          }
          return this
        }
      }
      class $f extends Qf {
        constructor(t) {
          super(),
            (this.type = 'Path'),
            (this.currentPoint = new dl()),
            t && this.setFromPoints(t)
        }
        setFromPoints(t) {
          this.moveTo(t[0].x, t[0].y)
          for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y)
          return this
        }
        moveTo(t, e) {
          return this.currentPoint.set(t, e), this
        }
        lineTo(t, e) {
          const n = new Xf(this.currentPoint.clone(), new dl(t, e))
          return this.curves.push(n), this.currentPoint.set(t, e), this
        }
        quadraticCurveTo(t, e, n, i) {
          const r = new Yf(
            this.currentPoint.clone(),
            new dl(t, e),
            new dl(n, i),
          )
          return this.curves.push(r), this.currentPoint.set(n, i), this
        }
        bezierCurveTo(t, e, n, i, r, s) {
          const o = new jf(
            this.currentPoint.clone(),
            new dl(t, e),
            new dl(n, i),
            new dl(r, s),
          )
          return this.curves.push(o), this.currentPoint.set(r, s), this
        }
        splineThru(t) {
          const e = [this.currentPoint.clone()].concat(t),
            n = new Zf(e)
          return (
            this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
          )
        }
        arc(t, e, n, i, r, s) {
          const o = this.currentPoint.x,
            a = this.currentPoint.y
          return this.absarc(t + o, e + a, n, i, r, s), this
        }
        absarc(t, e, n, i, r, s) {
          return this.absellipse(t, e, n, n, i, r, s), this
        }
        ellipse(t, e, n, i, r, s, o, a) {
          const l = this.currentPoint.x,
            c = this.currentPoint.y
          return this.absellipse(t + l, e + c, n, i, r, s, o, a), this
        }
        absellipse(t, e, n, i, r, s, o, a) {
          const l = new If(t, e, n, i, r, s, o, a)
          if (this.curves.length > 0) {
            const t = l.getPoint(0)
            t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
          }
          this.curves.push(l)
          const c = l.getPoint(1)
          return this.currentPoint.copy(c), this
        }
        copy(t) {
          return super.copy(t), this.currentPoint.copy(t.currentPoint), this
        }
        toJSON() {
          const t = super.toJSON()
          return (t.currentPoint = this.currentPoint.toArray()), t
        }
        fromJSON(t) {
          return (
            super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
          )
        }
      }
      class tm extends $f {
        constructor(t) {
          super(t), (this.uuid = rl()), (this.type = 'Shape'), (this.holes = [])
        }
        getPointsHoles(t) {
          const e = []
          for (let n = 0, i = this.holes.length; n < i; n++)
            e[n] = this.holes[n].getPoints(t)
          return e
        }
        extractPoints(t) {
          return { shape: this.getPoints(t), holes: this.getPointsHoles(t) }
        }
        copy(t) {
          super.copy(t), (this.holes = [])
          for (let e = 0, n = t.holes.length; e < n; e++) {
            const n = t.holes[e]
            this.holes.push(n.clone())
          }
          return this
        }
        toJSON() {
          const t = super.toJSON()
          ;(t.uuid = this.uuid), (t.holes = [])
          for (let e = 0, n = this.holes.length; e < n; e++) {
            const n = this.holes[e]
            t.holes.push(n.toJSON())
          }
          return t
        }
        fromJSON(t) {
          super.fromJSON(t), (this.uuid = t.uuid), (this.holes = [])
          for (let e = 0, n = t.holes.length; e < n; e++) {
            const n = t.holes[e]
            this.holes.push(new $f().fromJSON(n))
          }
          return this
        }
      }
      function em(t, e, n, i, r) {
        let s, o
        if (
          r ===
          (function (t, e, n, i) {
            let r = 0
            for (let s = e, o = n - i; s < n; s += i)
              (r += (t[o] - t[s]) * (t[s + 1] + t[o + 1])), (o = s)
            return r
          })(t, e, n, i) >
            0
        )
          for (s = e; s < n; s += i) o = wm(s, t[s], t[s + 1], o)
        else for (s = n - i; s >= e; s -= i) o = wm(s, t[s], t[s + 1], o)
        return o && gm(o, o.next) && (Mm(o), (o = o.next)), o
      }
      function nm(t, e) {
        if (!t) return t
        e || (e = t)
        let n,
          i = t
        do {
          if (
            ((n = !1),
            i.steiner || (!gm(i, i.next) && 0 !== mm(i.prev, i, i.next)))
          )
            i = i.next
          else {
            if ((Mm(i), (i = e = i.prev), i === i.next)) break
            n = !0
          }
        } while (n || i !== e)
        return e
      }
      function im(t, e, n, i, r, s, o) {
        if (!t) return
        !o &&
          s &&
          (function (t, e, n, i) {
            let r = t
            do {
              null === r.z && (r.z = hm(r.x, r.y, e, n, i)),
                (r.prevZ = r.prev),
                (r.nextZ = r.next),
                (r = r.next)
            } while (r !== t)
            ;(r.prevZ.nextZ = null),
              (r.prevZ = null),
              (function (t) {
                let e,
                  n,
                  i,
                  r,
                  s,
                  o,
                  a,
                  l,
                  c = 1
                do {
                  for (n = t, t = null, s = null, o = 0; n; ) {
                    for (
                      o++, i = n, a = 0, e = 0;
                      e < c && (a++, (i = i.nextZ), i);
                      e++
                    );
                    for (l = c; a > 0 || (l > 0 && i); )
                      0 !== a && (0 === l || !i || n.z <= i.z)
                        ? ((r = n), (n = n.nextZ), a--)
                        : ((r = i), (i = i.nextZ), l--),
                        s ? (s.nextZ = r) : (t = r),
                        (r.prevZ = s),
                        (s = r)
                    n = i
                  }
                  ;(s.nextZ = null), (c *= 2)
                } while (o > 1)
              })(r)
          })(t, i, r, s)
        let a,
          l,
          c = t
        for (; t.prev !== t.next; )
          if (((a = t.prev), (l = t.next), s ? sm(t, i, r, s) : rm(t)))
            e.push(a.i / n),
              e.push(t.i / n),
              e.push(l.i / n),
              Mm(t),
              (t = l.next),
              (c = l.next)
          else if ((t = l) === c) {
            o
              ? 1 === o
                ? im((t = om(nm(t), e, n)), e, n, i, r, s, 2)
                : 2 === o && am(t, e, n, i, r, s)
              : im(nm(t), e, n, i, r, s, 1)
            break
          }
      }
      function rm(t) {
        const e = t.prev,
          n = t,
          i = t.next
        if (mm(e, n, i) >= 0) return !1
        let r = t.next.next
        for (; r !== t.prev; ) {
          if (
            pm(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) &&
            mm(r.prev, r, r.next) >= 0
          )
            return !1
          r = r.next
        }
        return !0
      }
      function sm(t, e, n, i) {
        const r = t.prev,
          s = t,
          o = t.next
        if (mm(r, s, o) >= 0) return !1
        const a = r.x < s.x ? (r.x < o.x ? r.x : o.x) : s.x < o.x ? s.x : o.x,
          l = r.y < s.y ? (r.y < o.y ? r.y : o.y) : s.y < o.y ? s.y : o.y,
          c = r.x > s.x ? (r.x > o.x ? r.x : o.x) : s.x > o.x ? s.x : o.x,
          u = r.y > s.y ? (r.y > o.y ? r.y : o.y) : s.y > o.y ? s.y : o.y,
          h = hm(a, l, e, n, i),
          d = hm(c, u, e, n, i)
        let p = t.prevZ,
          f = t.nextZ
        for (; p && p.z >= h && f && f.z <= d; ) {
          if (
            p !== t.prev &&
            p !== t.next &&
            pm(r.x, r.y, s.x, s.y, o.x, o.y, p.x, p.y) &&
            mm(p.prev, p, p.next) >= 0
          )
            return !1
          if (
            ((p = p.prevZ),
            f !== t.prev &&
              f !== t.next &&
              pm(r.x, r.y, s.x, s.y, o.x, o.y, f.x, f.y) &&
              mm(f.prev, f, f.next) >= 0)
          )
            return !1
          f = f.nextZ
        }
        for (; p && p.z >= h; ) {
          if (
            p !== t.prev &&
            p !== t.next &&
            pm(r.x, r.y, s.x, s.y, o.x, o.y, p.x, p.y) &&
            mm(p.prev, p, p.next) >= 0
          )
            return !1
          p = p.prevZ
        }
        for (; f && f.z <= d; ) {
          if (
            f !== t.prev &&
            f !== t.next &&
            pm(r.x, r.y, s.x, s.y, o.x, o.y, f.x, f.y) &&
            mm(f.prev, f, f.next) >= 0
          )
            return !1
          f = f.nextZ
        }
        return !0
      }
      function om(t, e, n) {
        let i = t
        do {
          const r = i.prev,
            s = i.next.next
          !gm(r, s) &&
            vm(r, i, i.next, s) &&
            xm(r, s) &&
            xm(s, r) &&
            (e.push(r.i / n),
            e.push(i.i / n),
            e.push(s.i / n),
            Mm(i),
            Mm(i.next),
            (i = t = s)),
            (i = i.next)
        } while (i !== t)
        return nm(i)
      }
      function am(t, e, n, i, r, s) {
        let o = t
        do {
          let t = o.next.next
          for (; t !== o.prev; ) {
            if (o.i !== t.i && fm(o, t)) {
              let a = bm(o, t)
              return (
                (o = nm(o, o.next)),
                (a = nm(a, a.next)),
                im(o, e, n, i, r, s),
                void im(a, e, n, i, r, s)
              )
            }
            t = t.next
          }
          o = o.next
        } while (o !== t)
      }
      function lm(t, e) {
        return t.x - e.x
      }
      function cm(t, e) {
        if (
          ((e = (function (t, e) {
            let n = e
            const i = t.x,
              r = t.y
            let s,
              o = -1 / 0
            do {
              if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                const t =
                  n.x + ((r - n.y) * (n.next.x - n.x)) / (n.next.y - n.y)
                if (t <= i && t > o) {
                  if (((o = t), t === i)) {
                    if (r === n.y) return n
                    if (r === n.next.y) return n.next
                  }
                  s = n.x < n.next.x ? n : n.next
                }
              }
              n = n.next
            } while (n !== e)
            if (!s) return null
            if (i === o) return s
            const a = s,
              l = s.x,
              c = s.y
            let u,
              h = 1 / 0
            n = s
            do {
              i >= n.x &&
                n.x >= l &&
                i !== n.x &&
                pm(r < c ? i : o, r, l, c, r < c ? o : i, r, n.x, n.y) &&
                ((u = Math.abs(r - n.y) / (i - n.x)),
                xm(n, t) &&
                  (u < h ||
                    (u === h && (n.x > s.x || (n.x === s.x && um(s, n))))) &&
                  ((s = n), (h = u))),
                (n = n.next)
            } while (n !== a)
            return s
          })(t, e)),
          e)
        ) {
          const n = bm(e, t)
          nm(e, e.next), nm(n, n.next)
        }
      }
      function um(t, e) {
        return mm(t.prev, t, e.prev) < 0 && mm(e.next, t, t.next) < 0
      }
      function hm(t, e, n, i, r) {
        return (
          (t =
            1431655765 &
            ((t =
              858993459 &
              ((t =
                252645135 &
                ((t = 16711935 & ((t = 32767 * (t - n) * r) | (t << 8))) |
                  (t << 4))) |
                (t << 2))) |
              (t << 1))) |
          ((e =
            1431655765 &
            ((e =
              858993459 &
              ((e =
                252645135 &
                ((e = 16711935 & ((e = 32767 * (e - i) * r) | (e << 8))) |
                  (e << 4))) |
                (e << 2))) |
              (e << 1))) <<
            1)
        )
      }
      function dm(t) {
        let e = t,
          n = t
        do {
          ;(e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next)
        } while (e !== t)
        return n
      }
      function pm(t, e, n, i, r, s, o, a) {
        return (
          (r - o) * (e - a) - (t - o) * (s - a) >= 0 &&
          (t - o) * (i - a) - (n - o) * (e - a) >= 0 &&
          (n - o) * (s - a) - (r - o) * (i - a) >= 0
        )
      }
      function fm(t, e) {
        return (
          t.next.i !== e.i &&
          t.prev.i !== e.i &&
          !(function (t, e) {
            let n = t
            do {
              if (
                n.i !== t.i &&
                n.next.i !== t.i &&
                n.i !== e.i &&
                n.next.i !== e.i &&
                vm(n, n.next, t, e)
              )
                return !0
              n = n.next
            } while (n !== t)
            return !1
          })(t, e) &&
          ((xm(t, e) &&
            xm(e, t) &&
            (function (t, e) {
              let n = t,
                i = !1
              const r = (t.x + e.x) / 2,
                s = (t.y + e.y) / 2
              do {
                n.y > s != n.next.y > s &&
                  n.next.y !== n.y &&
                  r < ((n.next.x - n.x) * (s - n.y)) / (n.next.y - n.y) + n.x &&
                  (i = !i),
                  (n = n.next)
              } while (n !== t)
              return i
            })(t, e) &&
            (mm(t.prev, t, e.prev) || mm(t, e.prev, e))) ||
            (gm(t, e) &&
              mm(t.prev, t, t.next) > 0 &&
              mm(e.prev, e, e.next) > 0))
        )
      }
      function mm(t, e, n) {
        return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
      }
      function gm(t, e) {
        return t.x === e.x && t.y === e.y
      }
      function vm(t, e, n, i) {
        const r = ym(mm(t, e, n)),
          s = ym(mm(t, e, i)),
          o = ym(mm(n, i, t)),
          a = ym(mm(n, i, e))
        return (
          (r !== s && o !== a) ||
          !(0 !== r || !_m(t, n, e)) ||
          !(0 !== s || !_m(t, i, e)) ||
          !(0 !== o || !_m(n, t, i)) ||
          !(0 !== a || !_m(n, e, i))
        )
      }
      function _m(t, e, n) {
        return (
          e.x <= Math.max(t.x, n.x) &&
          e.x >= Math.min(t.x, n.x) &&
          e.y <= Math.max(t.y, n.y) &&
          e.y >= Math.min(t.y, n.y)
        )
      }
      function ym(t) {
        return t > 0 ? 1 : t < 0 ? -1 : 0
      }
      function xm(t, e) {
        return mm(t.prev, t, t.next) < 0
          ? mm(t, e, t.next) >= 0 && mm(t, t.prev, e) >= 0
          : mm(t, e, t.prev) < 0 || mm(t, t.next, e) < 0
      }
      function bm(t, e) {
        const n = new Sm(t.i, t.x, t.y),
          i = new Sm(e.i, e.x, e.y),
          r = t.next,
          s = e.prev
        return (
          (t.next = e),
          (e.prev = t),
          (n.next = r),
          (r.prev = n),
          (i.next = n),
          (n.prev = i),
          (s.next = i),
          (i.prev = s),
          i
        )
      }
      function wm(t, e, n, i) {
        const r = new Sm(t, e, n)
        return (
          i
            ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
            : ((r.prev = r), (r.next = r)),
          r
        )
      }
      function Mm(t) {
        ;(t.next.prev = t.prev),
          (t.prev.next = t.next),
          t.prevZ && (t.prevZ.nextZ = t.nextZ),
          t.nextZ && (t.nextZ.prevZ = t.prevZ)
      }
      function Sm(t, e, n) {
        ;(this.i = t),
          (this.x = e),
          (this.y = n),
          (this.prev = null),
          (this.next = null),
          (this.z = null),
          (this.prevZ = null),
          (this.nextZ = null),
          (this.steiner = !1)
      }
      class Tm {
        static area(t) {
          const e = t.length
          let n = 0
          for (let i = e - 1, r = 0; r < e; i = r++)
            n += t[i].x * t[r].y - t[r].x * t[i].y
          return 0.5 * n
        }
        static isClockWise(t) {
          return Tm.area(t) < 0
        }
        static triangulateShape(t, e) {
          const n = [],
            i = [],
            r = []
          Em(t), Dm(n, t)
          let s = t.length
          e.forEach(Em)
          for (let t = 0; t < e.length; t++)
            i.push(s), (s += e[t].length), Dm(n, e[t])
          const o = (function (t, e, n = 2) {
            const i = e && e.length,
              r = i ? e[0] * n : t.length
            let s = em(t, 0, r, n, !0)
            const o = []
            if (!s || s.next === s.prev) return o
            let a, l, c, u, h, d, p
            if (
              (i &&
                (s = (function (t, e, n, i) {
                  const r = []
                  let s, o, a, l, c
                  for (s = 0, o = e.length; s < o; s++)
                    (a = e[s] * i),
                      (l = s < o - 1 ? e[s + 1] * i : t.length),
                      (c = em(t, a, l, i, !1)),
                      c === c.next && (c.steiner = !0),
                      r.push(dm(c))
                  for (r.sort(lm), s = 0; s < r.length; s++)
                    cm(r[s], n), (n = nm(n, n.next))
                  return n
                })(t, e, s, n)),
              t.length > 80 * n)
            ) {
              ;(a = c = t[0]), (l = u = t[1])
              for (let e = n; e < r; e += n)
                (h = t[e]),
                  (d = t[e + 1]),
                  h < a && (a = h),
                  d < l && (l = d),
                  h > c && (c = h),
                  d > u && (u = d)
              ;(p = Math.max(c - a, u - l)), (p = 0 !== p ? 1 / p : 0)
            }
            return im(s, o, n, a, l, p), o
          })(n, i)
          for (let t = 0; t < o.length; t += 3) r.push(o.slice(t, t + 3))
          return r
        }
      }
      function Em(t) {
        const e = t.length
        e > 2 && t[e - 1].equals(t[0]) && t.pop()
      }
      function Dm(t, e) {
        for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
      }
      class Am extends lu {
        constructor(
          t = new tm([
            new dl(0.5, 0.5),
            new dl(-0.5, 0.5),
            new dl(-0.5, -0.5),
            new dl(0.5, -0.5),
          ]),
          e = {},
        ) {
          super(),
            (this.type = 'ExtrudeGeometry'),
            (this.parameters = { shapes: t, options: e }),
            (t = Array.isArray(t) ? t : [t])
          const n = this,
            i = [],
            r = []
          for (let e = 0, n = t.length; e < n; e++) s(t[e])
          function s(t) {
            const s = [],
              o = void 0 !== e.curveSegments ? e.curveSegments : 12,
              a = void 0 !== e.steps ? e.steps : 1
            let l = void 0 !== e.depth ? e.depth : 1,
              c = void 0 === e.bevelEnabled || e.bevelEnabled,
              u = void 0 !== e.bevelThickness ? e.bevelThickness : 0.2,
              h = void 0 !== e.bevelSize ? e.bevelSize : u - 0.1,
              d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
              p = void 0 !== e.bevelSegments ? e.bevelSegments : 3
            const f = e.extrudePath,
              m = void 0 !== e.UVGenerator ? e.UVGenerator : Cm
            void 0 !== e.amount &&
              (console.warn(
                'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.',
              ),
              (l = e.amount))
            let g,
              v,
              _,
              y,
              x,
              b = !1
            f &&
              ((g = f.getSpacedPoints(a)),
              (b = !0),
              (c = !1),
              (v = f.computeFrenetFrames(a, !1)),
              (_ = new Tl()),
              (y = new Tl()),
              (x = new Tl())),
              c || ((p = 0), (u = 0), (h = 0), (d = 0))
            const w = t.extractPoints(o)
            let M = w.shape
            const S = w.holes
            if (!Tm.isClockWise(M)) {
              M = M.reverse()
              for (let t = 0, e = S.length; t < e; t++) {
                const e = S[t]
                Tm.isClockWise(e) && (S[t] = e.reverse())
              }
            }
            const T = Tm.triangulateShape(M, S),
              E = M
            for (let t = 0, e = S.length; t < e; t++) {
              const e = S[t]
              M = M.concat(e)
            }
            function D(t, e, n) {
              return (
                e || console.error('THREE.ExtrudeGeometry: vec does not exist'),
                e.clone().multiplyScalar(n).add(t)
              )
            }
            const A = M.length,
              C = T.length
            function L(t, e, n) {
              let i, r, s
              const o = t.x - e.x,
                a = t.y - e.y,
                l = n.x - t.x,
                c = n.y - t.y,
                u = o * o + a * a,
                h = o * c - a * l
              if (Math.abs(h) > Number.EPSILON) {
                const h = Math.sqrt(u),
                  d = Math.sqrt(l * l + c * c),
                  p = e.x - a / h,
                  f = e.y + o / h,
                  m =
                    ((n.x - c / d - p) * c - (n.y + l / d - f) * l) /
                    (o * c - a * l)
                ;(i = p + o * m - t.x), (r = f + a * m - t.y)
                const g = i * i + r * r
                if (g <= 2) return new dl(i, r)
                s = Math.sqrt(g / 2)
              } else {
                let t = !1
                o > Number.EPSILON
                  ? l > Number.EPSILON && (t = !0)
                  : o < -Number.EPSILON
                  ? l < -Number.EPSILON && (t = !0)
                  : Math.sign(a) === Math.sign(c) && (t = !0),
                  t
                    ? ((i = -a), (r = o), (s = Math.sqrt(u)))
                    : ((i = o), (r = a), (s = Math.sqrt(u / 2)))
              }
              return new dl(i / s, r / s)
            }
            const R = []
            for (
              let t = 0, e = E.length, n = e - 1, i = t + 1;
              t < e;
              t++, n++, i++
            )
              n === e && (n = 0),
                i === e && (i = 0),
                (R[t] = L(E[t], E[n], E[i]))
            const P = []
            let F,
              I = R.concat()
            for (let t = 0, e = S.length; t < e; t++) {
              const e = S[t]
              F = []
              for (
                let t = 0, n = e.length, i = n - 1, r = t + 1;
                t < n;
                t++, i++, r++
              )
                i === n && (i = 0),
                  r === n && (r = 0),
                  (F[t] = L(e[t], e[i], e[r]))
              P.push(F), (I = I.concat(F))
            }
            for (let t = 0; t < p; t++) {
              const e = t / p,
                n = u * Math.cos((e * Math.PI) / 2),
                i = h * Math.sin((e * Math.PI) / 2) + d
              for (let t = 0, e = E.length; t < e; t++) {
                const e = D(E[t], R[t], i)
                k(e.x, e.y, -n)
              }
              for (let t = 0, e = S.length; t < e; t++) {
                const e = S[t]
                F = P[t]
                for (let t = 0, r = e.length; t < r; t++) {
                  const r = D(e[t], F[t], i)
                  k(r.x, r.y, -n)
                }
              }
            }
            const O = h + d
            for (let t = 0; t < A; t++) {
              const e = c ? D(M[t], I[t], O) : M[t]
              b
                ? (y.copy(v.normals[0]).multiplyScalar(e.x),
                  _.copy(v.binormals[0]).multiplyScalar(e.y),
                  x.copy(g[0]).add(y).add(_),
                  k(x.x, x.y, x.z))
                : k(e.x, e.y, 0)
            }
            for (let t = 1; t <= a; t++)
              for (let e = 0; e < A; e++) {
                const n = c ? D(M[e], I[e], O) : M[e]
                b
                  ? (y.copy(v.normals[t]).multiplyScalar(n.x),
                    _.copy(v.binormals[t]).multiplyScalar(n.y),
                    x.copy(g[t]).add(y).add(_),
                    k(x.x, x.y, x.z))
                  : k(n.x, n.y, (l / a) * t)
              }
            for (let t = p - 1; t >= 0; t--) {
              const e = t / p,
                n = u * Math.cos((e * Math.PI) / 2),
                i = h * Math.sin((e * Math.PI) / 2) + d
              for (let t = 0, e = E.length; t < e; t++) {
                const e = D(E[t], R[t], i)
                k(e.x, e.y, l + n)
              }
              for (let t = 0, e = S.length; t < e; t++) {
                const e = S[t]
                F = P[t]
                for (let t = 0, r = e.length; t < r; t++) {
                  const r = D(e[t], F[t], i)
                  b
                    ? k(r.x, r.y + g[a - 1].y, g[a - 1].x + n)
                    : k(r.x, r.y, l + n)
                }
              }
            }
            function N(t, e) {
              let n = t.length
              for (; --n >= 0; ) {
                const i = n
                let r = n - 1
                r < 0 && (r = t.length - 1)
                for (let t = 0, n = a + 2 * p; t < n; t++) {
                  const n = A * t,
                    s = A * (t + 1)
                  z(e + i + n, e + r + n, e + r + s, e + i + s)
                }
              }
            }
            function k(t, e, n) {
              s.push(t), s.push(e), s.push(n)
            }
            function B(t, e, r) {
              U(t), U(e), U(r)
              const s = i.length / 3,
                o = m.generateTopUV(n, i, s - 3, s - 2, s - 1)
              H(o[0]), H(o[1]), H(o[2])
            }
            function z(t, e, r, s) {
              U(t), U(e), U(s), U(e), U(r), U(s)
              const o = i.length / 3,
                a = m.generateSideWallUV(n, i, o - 6, o - 3, o - 2, o - 1)
              H(a[0]), H(a[1]), H(a[3]), H(a[1]), H(a[2]), H(a[3])
            }
            function U(t) {
              i.push(s[3 * t + 0]), i.push(s[3 * t + 1]), i.push(s[3 * t + 2])
            }
            function H(t) {
              r.push(t.x), r.push(t.y)
            }
            !(function () {
              const t = i.length / 3
              if (c) {
                let t = 0,
                  e = A * t
                for (let t = 0; t < C; t++) {
                  const n = T[t]
                  B(n[2] + e, n[1] + e, n[0] + e)
                }
                ;(t = a + 2 * p), (e = A * t)
                for (let t = 0; t < C; t++) {
                  const n = T[t]
                  B(n[0] + e, n[1] + e, n[2] + e)
                }
              } else {
                for (let t = 0; t < C; t++) {
                  const e = T[t]
                  B(e[2], e[1], e[0])
                }
                for (let t = 0; t < C; t++) {
                  const e = T[t]
                  B(e[0] + A * a, e[1] + A * a, e[2] + A * a)
                }
              }
              n.addGroup(t, i.length / 3 - t, 0)
            })(),
              (function () {
                const t = i.length / 3
                let e = 0
                N(E, e), (e += E.length)
                for (let t = 0, n = S.length; t < n; t++) {
                  const n = S[t]
                  N(n, e), (e += n.length)
                }
                n.addGroup(t, i.length / 3 - t, 1)
              })()
          }
          this.setAttribute('position', new tu(i, 3)),
            this.setAttribute('uv', new tu(r, 2)),
            this.computeVertexNormals()
        }
        toJSON() {
          const t = super.toJSON()
          return (function (t, e, n) {
            if (((n.shapes = []), Array.isArray(t)))
              for (let e = 0, i = t.length; e < i; e++) {
                const i = t[e]
                n.shapes.push(i.uuid)
              }
            else n.shapes.push(t.uuid)
            return (
              void 0 !== e.extrudePath &&
                (n.options.extrudePath = e.extrudePath.toJSON()),
              n
            )
          })(this.parameters.shapes, this.parameters.options, t)
        }
        static fromJSON(t, e) {
          const n = []
          for (let i = 0, r = t.shapes.length; i < r; i++) {
            const r = e[t.shapes[i]]
            n.push(r)
          }
          const i = t.options.extrudePath
          return (
            void 0 !== i &&
              (t.options.extrudePath = new Kf[i.type]().fromJSON(i)),
            new Am(n, t.options)
          )
        }
      }
      const Cm = {
        generateTopUV: function (t, e, n, i, r) {
          const s = e[3 * n],
            o = e[3 * n + 1],
            a = e[3 * i],
            l = e[3 * i + 1],
            c = e[3 * r],
            u = e[3 * r + 1]
          return [new dl(s, o), new dl(a, l), new dl(c, u)]
        },
        generateSideWallUV: function (t, e, n, i, r, s) {
          const o = e[3 * n],
            a = e[3 * n + 1],
            l = e[3 * n + 2],
            c = e[3 * i],
            u = e[3 * i + 1],
            h = e[3 * i + 2],
            d = e[3 * r],
            p = e[3 * r + 1],
            f = e[3 * r + 2],
            m = e[3 * s],
            g = e[3 * s + 1],
            v = e[3 * s + 2]
          return Math.abs(a - u) < Math.abs(o - c)
            ? [
                new dl(o, 1 - l),
                new dl(c, 1 - h),
                new dl(d, 1 - f),
                new dl(m, 1 - v),
              ]
            : [
                new dl(a, 1 - l),
                new dl(u, 1 - h),
                new dl(p, 1 - f),
                new dl(g, 1 - v),
              ]
        },
      }
      class Lm extends lu {
        constructor(
          t = new tm([new dl(0, 0.5), new dl(-0.5, -0.5), new dl(0.5, -0.5)]),
          e = 12,
        ) {
          super(),
            (this.type = 'ShapeGeometry'),
            (this.parameters = { shapes: t, curveSegments: e })
          const n = [],
            i = [],
            r = [],
            s = []
          let o = 0,
            a = 0
          if (!1 === Array.isArray(t)) l(t)
          else
            for (let e = 0; e < t.length; e++)
              l(t[e]), this.addGroup(o, a, e), (o += a), (a = 0)
          function l(t) {
            const o = i.length / 3,
              l = t.extractPoints(e)
            let c = l.shape
            const u = l.holes
            !1 === Tm.isClockWise(c) && (c = c.reverse())
            for (let t = 0, e = u.length; t < e; t++) {
              const e = u[t]
              !0 === Tm.isClockWise(e) && (u[t] = e.reverse())
            }
            const h = Tm.triangulateShape(c, u)
            for (let t = 0, e = u.length; t < e; t++) {
              const e = u[t]
              c = c.concat(e)
            }
            for (let t = 0, e = c.length; t < e; t++) {
              const e = c[t]
              i.push(e.x, e.y, 0), r.push(0, 0, 1), s.push(e.x, e.y)
            }
            for (let t = 0, e = h.length; t < e; t++) {
              const e = h[t],
                i = e[0] + o,
                r = e[1] + o,
                s = e[2] + o
              n.push(i, r, s), (a += 3)
            }
          }
          this.setIndex(n),
            this.setAttribute('position', new tu(i, 3)),
            this.setAttribute('normal', new tu(r, 3)),
            this.setAttribute('uv', new tu(s, 2))
        }
        toJSON() {
          const t = super.toJSON()
          return (function (t, e) {
            if (((e.shapes = []), Array.isArray(t)))
              for (let n = 0, i = t.length; n < i; n++) {
                const i = t[n]
                e.shapes.push(i.uuid)
              }
            else e.shapes.push(t.uuid)
            return e
          })(this.parameters.shapes, t)
        }
        static fromJSON(t, e) {
          const n = []
          for (let i = 0, r = t.shapes.length; i < r; i++) {
            const r = e[t.shapes[i]]
            n.push(r)
          }
          return new Lm(n, t.curveSegments)
        }
      }
      class Rm extends lu {
        constructor(
          t = 1,
          e = 32,
          n = 16,
          i = 0,
          r = 2 * Math.PI,
          s = 0,
          o = Math.PI,
        ) {
          super(),
            (this.type = 'SphereGeometry'),
            (this.parameters = {
              radius: t,
              widthSegments: e,
              heightSegments: n,
              phiStart: i,
              phiLength: r,
              thetaStart: s,
              thetaLength: o,
            }),
            (e = Math.max(3, Math.floor(e))),
            (n = Math.max(2, Math.floor(n)))
          const a = Math.min(s + o, Math.PI)
          let l = 0
          const c = [],
            u = new Tl(),
            h = new Tl(),
            d = [],
            p = [],
            f = [],
            m = []
          for (let d = 0; d <= n; d++) {
            const g = [],
              v = d / n
            let _ = 0
            0 == d && 0 == s
              ? (_ = 0.5 / e)
              : d == n && a == Math.PI && (_ = -0.5 / e)
            for (let n = 0; n <= e; n++) {
              const a = n / e
              ;(u.x = -t * Math.cos(i + a * r) * Math.sin(s + v * o)),
                (u.y = t * Math.cos(s + v * o)),
                (u.z = t * Math.sin(i + a * r) * Math.sin(s + v * o)),
                p.push(u.x, u.y, u.z),
                h.copy(u).normalize(),
                f.push(h.x, h.y, h.z),
                m.push(a + _, 1 - v),
                g.push(l++)
            }
            c.push(g)
          }
          for (let t = 0; t < n; t++)
            for (let i = 0; i < e; i++) {
              const e = c[t][i + 1],
                r = c[t][i],
                o = c[t + 1][i],
                l = c[t + 1][i + 1]
              ;(0 !== t || s > 0) && d.push(e, r, l),
                (t !== n - 1 || a < Math.PI) && d.push(r, o, l)
            }
          this.setIndex(d),
            this.setAttribute('position', new tu(p, 3)),
            this.setAttribute('normal', new tu(f, 3)),
            this.setAttribute('uv', new tu(m, 2))
        }
        static fromJSON(t) {
          return new Rm(
            t.radius,
            t.widthSegments,
            t.heightSegments,
            t.phiStart,
            t.phiLength,
            t.thetaStart,
            t.thetaLength,
          )
        }
      }
      ;(class extends Uc {
        constructor(t) {
          super(),
            (this.type = 'ShadowMaterial'),
            (this.color = new Xc(0)),
            (this.transparent = !0),
            this.setValues(t)
        }
        copy(t) {
          return super.copy(t), this.color.copy(t.color), this
        }
      }.prototype.isShadowMaterial = !0)
      class Pm extends Uc {
        constructor(t) {
          super(),
            (this.defines = { STANDARD: '' }),
            (this.type = 'MeshStandardMaterial'),
            (this.color = new Xc(16777215)),
            (this.roughness = 1),
            (this.metalness = 0),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Xc(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = 0),
            (this.normalScale = new dl(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.roughnessMap = null),
            (this.metalnessMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapIntensity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = 'round'),
            (this.wireframeLinejoin = 'round'),
            (this.flatShading = !1),
            this.setValues(t)
        }
        copy(t) {
          return (
            super.copy(t),
            (this.defines = { STANDARD: '' }),
            this.color.copy(t.color),
            (this.roughness = t.roughness),
            (this.metalness = t.metalness),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            this.emissive.copy(t.emissive),
            (this.emissiveMap = t.emissiveMap),
            (this.emissiveIntensity = t.emissiveIntensity),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.roughnessMap = t.roughnessMap),
            (this.metalnessMap = t.metalnessMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            (this.envMapIntensity = t.envMapIntensity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            (this.flatShading = t.flatShading),
            this
          )
        }
      }
      Pm.prototype.isMeshStandardMaterial = !0
      class Fm extends Pm {
        constructor(t) {
          super(),
            (this.defines = { STANDARD: '', PHYSICAL: '' }),
            (this.type = 'MeshPhysicalMaterial'),
            (this.clearcoatMap = null),
            (this.clearcoatRoughness = 0),
            (this.clearcoatRoughnessMap = null),
            (this.clearcoatNormalScale = new dl(1, 1)),
            (this.clearcoatNormalMap = null),
            (this.ior = 1.5),
            Object.defineProperty(this, 'reflectivity', {
              get: function () {
                return sl((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1)
              },
              set: function (t) {
                this.ior = (1 + 0.4 * t) / (1 - 0.4 * t)
              },
            }),
            (this.sheenTint = new Xc(0)),
            (this.sheenRoughness = 1),
            (this.transmissionMap = null),
            (this.thickness = 0.01),
            (this.thicknessMap = null),
            (this.attenuationDistance = 0),
            (this.attenuationTint = new Xc(1, 1, 1)),
            (this.specularIntensity = 1),
            (this.specularIntensityMap = null),
            (this.specularTint = new Xc(1, 1, 1)),
            (this.specularTintMap = null),
            (this._sheen = 0),
            (this._clearcoat = 0),
            (this._transmission = 0),
            this.setValues(t)
        }
        get sheen() {
          return this._sheen
        }
        set sheen(t) {
          this._sheen > 0 != t > 0 && this.version++, (this._sheen = t)
        }
        get clearcoat() {
          return this._clearcoat
        }
        set clearcoat(t) {
          this._clearcoat > 0 != t > 0 && this.version++, (this._clearcoat = t)
        }
        get transmission() {
          return this._transmission
        }
        set transmission(t) {
          this._transmission > 0 != t > 0 && this.version++,
            (this._transmission = t)
        }
        copy(t) {
          return (
            super.copy(t),
            (this.defines = { STANDARD: '', PHYSICAL: '' }),
            (this.clearcoat = t.clearcoat),
            (this.clearcoatMap = t.clearcoatMap),
            (this.clearcoatRoughness = t.clearcoatRoughness),
            (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
            (this.clearcoatNormalMap = t.clearcoatNormalMap),
            this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
            (this.ior = t.ior),
            (this.sheen = t.sheen),
            this.sheenTint.copy(t.sheenTint),
            (this.sheenRoughness = t.sheenRoughness),
            (this.transmission = t.transmission),
            (this.transmissionMap = t.transmissionMap),
            (this.thickness = t.thickness),
            (this.thicknessMap = t.thicknessMap),
            (this.attenuationDistance = t.attenuationDistance),
            this.attenuationTint.copy(t.attenuationTint),
            (this.specularIntensity = t.specularIntensity),
            (this.specularIntensityMap = t.specularIntensityMap),
            this.specularTint.copy(t.specularTint),
            (this.specularTintMap = t.specularTintMap),
            this
          )
        }
      }
      Fm.prototype.isMeshPhysicalMaterial = !0
      class Im extends Uc {
        constructor(t) {
          super(),
            (this.type = 'MeshPhongMaterial'),
            (this.color = new Xc(16777215)),
            (this.specular = new Xc(1118481)),
            (this.shininess = 30),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Xc(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = 0),
            (this.normalScale = new dl(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = 0),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = 'round'),
            (this.wireframeLinejoin = 'round'),
            (this.flatShading = !1),
            this.setValues(t)
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            this.specular.copy(t.specular),
            (this.shininess = t.shininess),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            this.emissive.copy(t.emissive),
            (this.emissiveMap = t.emissiveMap),
            (this.emissiveIntensity = t.emissiveIntensity),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.specularMap = t.specularMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            (this.combine = t.combine),
            (this.reflectivity = t.reflectivity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            (this.flatShading = t.flatShading),
            this
          )
        }
      }
      Im.prototype.isMeshPhongMaterial = !0
      ;(class extends Uc {
        constructor(t) {
          super(),
            (this.defines = { TOON: '' }),
            (this.type = 'MeshToonMaterial'),
            (this.color = new Xc(16777215)),
            (this.map = null),
            (this.gradientMap = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Xc(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = 0),
            (this.normalScale = new dl(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = 'round'),
            (this.wireframeLinejoin = 'round'),
            this.setValues(t)
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.gradientMap = t.gradientMap),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            this.emissive.copy(t.emissive),
            (this.emissiveMap = t.emissiveMap),
            (this.emissiveIntensity = t.emissiveIntensity),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.alphaMap = t.alphaMap),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            this
          )
        }
      }.prototype.isMeshToonMaterial = !0)
      ;(class extends Uc {
        constructor(t) {
          super(),
            (this.type = 'MeshNormalMaterial'),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = 0),
            (this.normalScale = new dl(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.flatShading = !1),
            this.setValues(t)
        }
        copy(t) {
          return (
            super.copy(t),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.flatShading = t.flatShading),
            this
          )
        }
      }.prototype.isMeshNormalMaterial = !0)
      ;(class extends Uc {
        constructor(t) {
          super(),
            (this.type = 'MeshLambertMaterial'),
            (this.color = new Xc(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Xc(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = 0),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = 'round'),
            (this.wireframeLinejoin = 'round'),
            this.setValues(t)
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            this.emissive.copy(t.emissive),
            (this.emissiveMap = t.emissiveMap),
            (this.emissiveIntensity = t.emissiveIntensity),
            (this.specularMap = t.specularMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            (this.combine = t.combine),
            (this.reflectivity = t.reflectivity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            this
          )
        }
      }.prototype.isMeshLambertMaterial = !0)
      ;(class extends Uc {
        constructor(t) {
          super(),
            (this.defines = { MATCAP: '' }),
            (this.type = 'MeshMatcapMaterial'),
            (this.color = new Xc(16777215)),
            (this.matcap = null),
            (this.map = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = 0),
            (this.normalScale = new dl(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.flatShading = !1),
            this.setValues(t)
        }
        copy(t) {
          return (
            super.copy(t),
            (this.defines = { MATCAP: '' }),
            this.color.copy(t.color),
            (this.matcap = t.matcap),
            (this.map = t.map),
            (this.bumpMap = t.bumpMap),
            (this.bumpScale = t.bumpScale),
            (this.normalMap = t.normalMap),
            (this.normalMapType = t.normalMapType),
            this.normalScale.copy(t.normalScale),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.alphaMap = t.alphaMap),
            (this.flatShading = t.flatShading),
            this
          )
        }
      }.prototype.isMeshMatcapMaterial = !0)
      ;(class extends mf {
        constructor(t) {
          super(),
            (this.type = 'LineDashedMaterial'),
            (this.scale = 1),
            (this.dashSize = 3),
            (this.gapSize = 1),
            this.setValues(t)
        }
        copy(t) {
          return (
            super.copy(t),
            (this.scale = t.scale),
            (this.dashSize = t.dashSize),
            (this.gapSize = t.gapSize),
            this
          )
        }
      }.prototype.isLineDashedMaterial = !0)
      const Om = {
        arraySlice: function (t, e, n) {
          return Om.isTypedArray(t)
            ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length))
            : t.slice(e, n)
        },
        convertArray: function (t, e, n) {
          return !t || (!n && t.constructor === e)
            ? t
            : 'number' == typeof e.BYTES_PER_ELEMENT
            ? new e(t)
            : Array.prototype.slice.call(t)
        },
        isTypedArray: function (t) {
          return ArrayBuffer.isView(t) && !(t instanceof DataView)
        },
        getKeyframeOrder: function (t) {
          const e = t.length,
            n = new Array(e)
          for (let t = 0; t !== e; ++t) n[t] = t
          return (
            n.sort(function (e, n) {
              return t[e] - t[n]
            }),
            n
          )
        },
        sortedArray: function (t, e, n) {
          const i = t.length,
            r = new t.constructor(i)
          for (let s = 0, o = 0; o !== i; ++s) {
            const i = n[s] * e
            for (let n = 0; n !== e; ++n) r[o++] = t[i + n]
          }
          return r
        },
        flattenJSON: function (t, e, n, i) {
          let r = 1,
            s = t[0]
          for (; void 0 !== s && void 0 === s[i]; ) s = t[r++]
          if (void 0 === s) return
          let o = s[i]
          if (void 0 !== o)
            if (Array.isArray(o))
              do {
                ;(o = s[i]),
                  void 0 !== o && (e.push(s.time), n.push.apply(n, o)),
                  (s = t[r++])
              } while (void 0 !== s)
            else if (void 0 !== o.toArray)
              do {
                ;(o = s[i]),
                  void 0 !== o && (e.push(s.time), o.toArray(n, n.length)),
                  (s = t[r++])
              } while (void 0 !== s)
            else
              do {
                ;(o = s[i]),
                  void 0 !== o && (e.push(s.time), n.push(o)),
                  (s = t[r++])
              } while (void 0 !== s)
        },
        subclip: function (t, e, n, i, r = 30) {
          const s = t.clone()
          s.name = e
          const o = []
          for (let t = 0; t < s.tracks.length; ++t) {
            const e = s.tracks[t],
              a = e.getValueSize(),
              l = [],
              c = []
            for (let t = 0; t < e.times.length; ++t) {
              const s = e.times[t] * r
              if (!(s < n || s >= i)) {
                l.push(e.times[t])
                for (let n = 0; n < a; ++n) c.push(e.values[t * a + n])
              }
            }
            0 !== l.length &&
              ((e.times = Om.convertArray(l, e.times.constructor)),
              (e.values = Om.convertArray(c, e.values.constructor)),
              o.push(e))
          }
          s.tracks = o
          let a = 1 / 0
          for (let t = 0; t < s.tracks.length; ++t)
            a > s.tracks[t].times[0] && (a = s.tracks[t].times[0])
          for (let t = 0; t < s.tracks.length; ++t) s.tracks[t].shift(-1 * a)
          return s.resetDuration(), s
        },
        makeClipAdditive: function (t, e = 0, n = t, i = 30) {
          i <= 0 && (i = 30)
          const r = n.tracks.length,
            s = e / i
          for (let e = 0; e < r; ++e) {
            const i = n.tracks[e],
              r = i.ValueTypeName
            if ('bool' === r || 'string' === r) continue
            const o = t.tracks.find(function (t) {
              return t.name === i.name && t.ValueTypeName === r
            })
            if (void 0 === o) continue
            let a = 0
            const l = i.getValueSize()
            i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
              (a = l / 3)
            let c = 0
            const u = o.getValueSize()
            o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
              (c = u / 3)
            const h = i.times.length - 1
            let d
            if (s <= i.times[0]) {
              const t = a,
                e = l - a
              d = Om.arraySlice(i.values, t, e)
            } else if (s >= i.times[h]) {
              const t = h * l + a,
                e = t + l - a
              d = Om.arraySlice(i.values, t, e)
            } else {
              const t = i.createInterpolant(),
                e = a,
                n = l - a
              t.evaluate(s), (d = Om.arraySlice(t.resultBuffer, e, n))
            }
            'quaternion' === r &&
              new Sl().fromArray(d).normalize().conjugate().toArray(d)
            const p = o.times.length
            for (let t = 0; t < p; ++t) {
              const e = t * u + c
              if ('quaternion' === r)
                Sl.multiplyQuaternionsFlat(o.values, e, d, 0, o.values, e)
              else {
                const t = u - 2 * c
                for (let n = 0; n < t; ++n) o.values[e + n] -= d[n]
              }
            }
          }
          return (t.blendMode = 2501), t
        },
      }
      class Nm {
        constructor(t, e, n, i) {
          ;(this.parameterPositions = t),
            (this._cachedIndex = 0),
            (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
            (this.sampleValues = e),
            (this.valueSize = n),
            (this.settings = null),
            (this.DefaultSettings_ = {})
        }
        evaluate(t) {
          const e = this.parameterPositions
          let n = this._cachedIndex,
            i = e[n],
            r = e[n - 1]
          t: {
            e: {
              let s
              n: {
                i: if (!(t < i)) {
                  for (let s = n + 2; ; ) {
                    if (void 0 === i) {
                      if (t < r) break i
                      return (
                        (n = e.length),
                        (this._cachedIndex = n),
                        this.afterEnd_(n - 1, t, r)
                      )
                    }
                    if (n === s) break
                    if (((r = i), (i = e[++n]), t < i)) break e
                  }
                  s = e.length
                  break n
                }
                if (t >= r) break t
                {
                  const o = e[1]
                  t < o && ((n = 2), (r = o))
                  for (let s = n - 2; ; ) {
                    if (void 0 === r)
                      return (this._cachedIndex = 0), this.beforeStart_(0, t, i)
                    if (n === s) break
                    if (((i = r), (r = e[--n - 1]), t >= r)) break e
                  }
                  ;(s = n), (n = 0)
                }
              }
              for (; n < s; ) {
                const i = (n + s) >>> 1
                t < e[i] ? (s = i) : (n = i + 1)
              }
              if (((i = e[n]), (r = e[n - 1]), void 0 === r))
                return (this._cachedIndex = 0), this.beforeStart_(0, t, i)
              if (void 0 === i)
                return (
                  (n = e.length),
                  (this._cachedIndex = n),
                  this.afterEnd_(n - 1, r, t)
                )
            }
            ;(this._cachedIndex = n), this.intervalChanged_(n, r, i)
          }
          return this.interpolate_(n, r, t, i)
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_
        }
        copySampleValue_(t) {
          const e = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            r = t * i
          for (let t = 0; t !== i; ++t) e[t] = n[r + t]
          return e
        }
        interpolate_() {
          throw new Error('call to abstract method')
        }
        intervalChanged_() {}
      }
      ;(Nm.prototype.beforeStart_ = Nm.prototype.copySampleValue_),
        (Nm.prototype.afterEnd_ = Nm.prototype.copySampleValue_)
      class km extends Nm {
        constructor(t, e, n, i) {
          super(t, e, n, i),
            (this._weightPrev = -0),
            (this._offsetPrev = -0),
            (this._weightNext = -0),
            (this._offsetNext = -0),
            (this.DefaultSettings_ = { endingStart: Ha, endingEnd: Ha })
        }
        intervalChanged_(t, e, n) {
          const i = this.parameterPositions
          let r = t - 2,
            s = t + 1,
            o = i[r],
            a = i[s]
          if (void 0 === o)
            switch (this.getSettings_().endingStart) {
              case Ga:
                ;(r = t), (o = 2 * e - n)
                break
              case Va:
                ;(r = i.length - 2), (o = e + i[r] - i[r + 1])
                break
              default:
                ;(r = t), (o = n)
            }
          if (void 0 === a)
            switch (this.getSettings_().endingEnd) {
              case Ga:
                ;(s = t), (a = 2 * n - e)
                break
              case Va:
                ;(s = 1), (a = n + i[1] - i[0])
                break
              default:
                ;(s = t - 1), (a = e)
            }
          const l = 0.5 * (n - e),
            c = this.valueSize
          ;(this._weightPrev = l / (e - o)),
            (this._weightNext = l / (a - n)),
            (this._offsetPrev = r * c),
            (this._offsetNext = s * c)
        }
        interpolate_(t, e, n, i) {
          const r = this.resultBuffer,
            s = this.sampleValues,
            o = this.valueSize,
            a = t * o,
            l = a - o,
            c = this._offsetPrev,
            u = this._offsetNext,
            h = this._weightPrev,
            d = this._weightNext,
            p = (n - e) / (i - e),
            f = p * p,
            m = f * p,
            g = -h * m + 2 * h * f - h * p,
            v = (1 + h) * m + (-1.5 - 2 * h) * f + (-0.5 + h) * p + 1,
            _ = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
            y = d * m - d * f
          for (let t = 0; t !== o; ++t)
            r[t] = g * s[c + t] + v * s[l + t] + _ * s[a + t] + y * s[u + t]
          return r
        }
      }
      class Bm extends Nm {
        constructor(t, e, n, i) {
          super(t, e, n, i)
        }
        interpolate_(t, e, n, i) {
          const r = this.resultBuffer,
            s = this.sampleValues,
            o = this.valueSize,
            a = t * o,
            l = a - o,
            c = (n - e) / (i - e),
            u = 1 - c
          for (let t = 0; t !== o; ++t) r[t] = s[l + t] * u + s[a + t] * c
          return r
        }
      }
      class zm extends Nm {
        constructor(t, e, n, i) {
          super(t, e, n, i)
        }
        interpolate_(t) {
          return this.copySampleValue_(t - 1)
        }
      }
      class Um {
        constructor(t, e, n, i) {
          if (void 0 === t)
            throw new Error('THREE.KeyframeTrack: track name is undefined')
          if (void 0 === e || 0 === e.length)
            throw new Error(
              'THREE.KeyframeTrack: no keyframes in track named ' + t,
            )
          ;(this.name = t),
            (this.times = Om.convertArray(e, this.TimeBufferType)),
            (this.values = Om.convertArray(n, this.ValueBufferType)),
            this.setInterpolation(i || this.DefaultInterpolation)
        }
        static toJSON(t) {
          const e = t.constructor
          let n
          if (e.toJSON !== this.toJSON) n = e.toJSON(t)
          else {
            n = {
              name: t.name,
              times: Om.convertArray(t.times, Array),
              values: Om.convertArray(t.values, Array),
            }
            const e = t.getInterpolation()
            e !== t.DefaultInterpolation && (n.interpolation = e)
          }
          return (n.type = t.ValueTypeName), n
        }
        InterpolantFactoryMethodDiscrete(t) {
          return new zm(this.times, this.values, this.getValueSize(), t)
        }
        InterpolantFactoryMethodLinear(t) {
          return new Bm(this.times, this.values, this.getValueSize(), t)
        }
        InterpolantFactoryMethodSmooth(t) {
          return new km(this.times, this.values, this.getValueSize(), t)
        }
        setInterpolation(t) {
          let e
          switch (t) {
            case Ba:
              e = this.InterpolantFactoryMethodDiscrete
              break
            case za:
              e = this.InterpolantFactoryMethodLinear
              break
            case Ua:
              e = this.InterpolantFactoryMethodSmooth
          }
          if (void 0 === e) {
            const e =
              'unsupported interpolation for ' +
              this.ValueTypeName +
              ' keyframe track named ' +
              this.name
            if (void 0 === this.createInterpolant) {
              if (t === this.DefaultInterpolation) throw new Error(e)
              this.setInterpolation(this.DefaultInterpolation)
            }
            return console.warn('THREE.KeyframeTrack:', e), this
          }
          return (this.createInterpolant = e), this
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return Ba
            case this.InterpolantFactoryMethodLinear:
              return za
            case this.InterpolantFactoryMethodSmooth:
              return Ua
          }
        }
        getValueSize() {
          return this.values.length / this.times.length
        }
        shift(t) {
          if (0 !== t) {
            const e = this.times
            for (let n = 0, i = e.length; n !== i; ++n) e[n] += t
          }
          return this
        }
        scale(t) {
          if (1 !== t) {
            const e = this.times
            for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t
          }
          return this
        }
        trim(t, e) {
          const n = this.times,
            i = n.length
          let r = 0,
            s = i - 1
          for (; r !== i && n[r] < t; ) ++r
          for (; -1 !== s && n[s] > e; ) --s
          if ((++s, 0 !== r || s !== i)) {
            r >= s && ((s = Math.max(s, 1)), (r = s - 1))
            const t = this.getValueSize()
            ;(this.times = Om.arraySlice(n, r, s)),
              (this.values = Om.arraySlice(this.values, r * t, s * t))
          }
          return this
        }
        validate() {
          let t = !0
          const e = this.getValueSize()
          e - Math.floor(e) != 0 &&
            (console.error(
              'THREE.KeyframeTrack: Invalid value size in track.',
              this,
            ),
            (t = !1))
          const n = this.times,
            i = this.values,
            r = n.length
          0 === r &&
            (console.error('THREE.KeyframeTrack: Track is empty.', this),
            (t = !1))
          let s = null
          for (let e = 0; e !== r; e++) {
            const i = n[e]
            if ('number' == typeof i && isNaN(i)) {
              console.error(
                'THREE.KeyframeTrack: Time is not a valid number.',
                this,
                e,
                i,
              ),
                (t = !1)
              break
            }
            if (null !== s && s > i) {
              console.error(
                'THREE.KeyframeTrack: Out of order keys.',
                this,
                e,
                i,
                s,
              ),
                (t = !1)
              break
            }
            s = i
          }
          if (void 0 !== i && Om.isTypedArray(i))
            for (let e = 0, n = i.length; e !== n; ++e) {
              const n = i[e]
              if (isNaN(n)) {
                console.error(
                  'THREE.KeyframeTrack: Value is not a valid number.',
                  this,
                  e,
                  n,
                ),
                  (t = !1)
                break
              }
            }
          return t
        }
        optimize() {
          const t = Om.arraySlice(this.times),
            e = Om.arraySlice(this.values),
            n = this.getValueSize(),
            i = this.getInterpolation() === Ua,
            r = t.length - 1
          let s = 1
          for (let o = 1; o < r; ++o) {
            let r = !1
            const a = t[o]
            if (a !== t[o + 1] && (1 !== o || a !== t[0]))
              if (i) r = !0
              else {
                const t = o * n,
                  i = t - n,
                  s = t + n
                for (let o = 0; o !== n; ++o) {
                  const n = e[t + o]
                  if (n !== e[i + o] || n !== e[s + o]) {
                    r = !0
                    break
                  }
                }
              }
            if (r) {
              if (o !== s) {
                t[s] = t[o]
                const i = o * n,
                  r = s * n
                for (let t = 0; t !== n; ++t) e[r + t] = e[i + t]
              }
              ++s
            }
          }
          if (r > 0) {
            t[s] = t[r]
            for (let t = r * n, i = s * n, o = 0; o !== n; ++o)
              e[i + o] = e[t + o]
            ++s
          }
          return (
            s !== t.length
              ? ((this.times = Om.arraySlice(t, 0, s)),
                (this.values = Om.arraySlice(e, 0, s * n)))
              : ((this.times = t), (this.values = e)),
            this
          )
        }
        clone() {
          const t = Om.arraySlice(this.times, 0),
            e = Om.arraySlice(this.values, 0),
            n = new (0, this.constructor)(this.name, t, e)
          return (n.createInterpolant = this.createInterpolant), n
        }
      }
      ;(Um.prototype.TimeBufferType = Float32Array),
        (Um.prototype.ValueBufferType = Float32Array),
        (Um.prototype.DefaultInterpolation = za)
      class Hm extends Um {}
      ;(Hm.prototype.ValueTypeName = 'bool'),
        (Hm.prototype.ValueBufferType = Array),
        (Hm.prototype.DefaultInterpolation = Ba),
        (Hm.prototype.InterpolantFactoryMethodLinear = void 0),
        (Hm.prototype.InterpolantFactoryMethodSmooth = void 0)
      class Gm extends Um {}
      Gm.prototype.ValueTypeName = 'color'
      class Vm extends Um {}
      Vm.prototype.ValueTypeName = 'number'
      class Wm extends Nm {
        constructor(t, e, n, i) {
          super(t, e, n, i)
        }
        interpolate_(t, e, n, i) {
          const r = this.resultBuffer,
            s = this.sampleValues,
            o = this.valueSize,
            a = (n - e) / (i - e)
          let l = t * o
          for (let t = l + o; l !== t; l += 4)
            Sl.slerpFlat(r, 0, s, l - o, s, l, a)
          return r
        }
      }
      class jm extends Um {
        InterpolantFactoryMethodLinear(t) {
          return new Wm(this.times, this.values, this.getValueSize(), t)
        }
      }
      ;(jm.prototype.ValueTypeName = 'quaternion'),
        (jm.prototype.DefaultInterpolation = za),
        (jm.prototype.InterpolantFactoryMethodSmooth = void 0)
      class qm extends Um {}
      ;(qm.prototype.ValueTypeName = 'string'),
        (qm.prototype.ValueBufferType = Array),
        (qm.prototype.DefaultInterpolation = Ba),
        (qm.prototype.InterpolantFactoryMethodLinear = void 0),
        (qm.prototype.InterpolantFactoryMethodSmooth = void 0)
      class Xm extends Um {}
      Xm.prototype.ValueTypeName = 'vector'
      class Ym {
        constructor(t, e = -1, n, i = 2500) {
          ;(this.name = t),
            (this.tracks = n),
            (this.duration = e),
            (this.blendMode = i),
            (this.uuid = rl()),
            this.duration < 0 && this.resetDuration()
        }
        static parse(t) {
          const e = [],
            n = t.tracks,
            i = 1 / (t.fps || 1)
          for (let t = 0, r = n.length; t !== r; ++t) e.push(Jm(n[t]).scale(i))
          const r = new this(t.name, t.duration, e, t.blendMode)
          return (r.uuid = t.uuid), r
        }
        static toJSON(t) {
          const e = [],
            n = t.tracks,
            i = {
              name: t.name,
              duration: t.duration,
              tracks: e,
              uuid: t.uuid,
              blendMode: t.blendMode,
            }
          for (let t = 0, i = n.length; t !== i; ++t) e.push(Um.toJSON(n[t]))
          return i
        }
        static CreateFromMorphTargetSequence(t, e, n, i) {
          const r = e.length,
            s = []
          for (let t = 0; t < r; t++) {
            let o = [],
              a = []
            o.push((t + r - 1) % r, t, (t + 1) % r), a.push(0, 1, 0)
            const l = Om.getKeyframeOrder(o)
            ;(o = Om.sortedArray(o, 1, l)),
              (a = Om.sortedArray(a, 1, l)),
              i || 0 !== o[0] || (o.push(r), a.push(a[0])),
              s.push(
                new Vm('.morphTargetInfluences[' + e[t].name + ']', o, a).scale(
                  1 / n,
                ),
              )
          }
          return new this(t, -1, s)
        }
        static findByName(t, e) {
          let n = t
          if (!Array.isArray(t)) {
            const e = t
            n = (e.geometry && e.geometry.animations) || e.animations
          }
          for (let t = 0; t < n.length; t++) if (n[t].name === e) return n[t]
          return null
        }
        static CreateClipsFromMorphTargetSequences(t, e, n) {
          const i = {},
            r = /^([\w-]*?)([\d]+)$/
          for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e],
              s = n.name.match(r)
            if (s && s.length > 1) {
              const t = s[1]
              let e = i[t]
              e || (i[t] = e = []), e.push(n)
            }
          }
          const s = []
          for (const t in i)
            s.push(this.CreateFromMorphTargetSequence(t, i[t], e, n))
          return s
        }
        static parseAnimation(t, e) {
          if (!t)
            return (
              console.error(
                'THREE.AnimationClip: No animation in JSONLoader data.',
              ),
              null
            )
          const n = function (t, e, n, i, r) {
              if (0 !== n.length) {
                const s = [],
                  o = []
                Om.flattenJSON(n, s, o, i),
                  0 !== s.length && r.push(new t(e, s, o))
              }
            },
            i = [],
            r = t.name || 'default',
            s = t.fps || 30,
            o = t.blendMode
          let a = t.length || -1
          const l = t.hierarchy || []
          for (let t = 0; t < l.length; t++) {
            const r = l[t].keys
            if (r && 0 !== r.length)
              if (r[0].morphTargets) {
                const t = {}
                let e
                for (e = 0; e < r.length; e++)
                  if (r[e].morphTargets)
                    for (let n = 0; n < r[e].morphTargets.length; n++)
                      t[r[e].morphTargets[n]] = -1
                for (const n in t) {
                  const t = [],
                    s = []
                  for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                    const i = r[e]
                    t.push(i.time), s.push(i.morphTarget === n ? 1 : 0)
                  }
                  i.push(new Vm('.morphTargetInfluence[' + n + ']', t, s))
                }
                a = t.length * (s || 1)
              } else {
                const s = '.bones[' + e[t].name + ']'
                n(Xm, s + '.position', r, 'pos', i),
                  n(jm, s + '.quaternion', r, 'rot', i),
                  n(Xm, s + '.scale', r, 'scl', i)
              }
          }
          return 0 === i.length ? null : new this(r, a, i, o)
        }
        resetDuration() {
          let t = 0
          for (let e = 0, n = this.tracks.length; e !== n; ++e) {
            const n = this.tracks[e]
            t = Math.max(t, n.times[n.times.length - 1])
          }
          return (this.duration = t), this
        }
        trim() {
          for (let t = 0; t < this.tracks.length; t++)
            this.tracks[t].trim(0, this.duration)
          return this
        }
        validate() {
          let t = !0
          for (let e = 0; e < this.tracks.length; e++)
            t = t && this.tracks[e].validate()
          return t
        }
        optimize() {
          for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize()
          return this
        }
        clone() {
          const t = []
          for (let e = 0; e < this.tracks.length; e++)
            t.push(this.tracks[e].clone())
          return new this.constructor(
            this.name,
            this.duration,
            t,
            this.blendMode,
          )
        }
        toJSON() {
          return this.constructor.toJSON(this)
        }
      }
      function Jm(t) {
        if (void 0 === t.type)
          throw new Error(
            'THREE.KeyframeTrack: track type undefined, can not parse',
          )
        const e = (function (t) {
          switch (t.toLowerCase()) {
            case 'scalar':
            case 'double':
            case 'float':
            case 'number':
            case 'integer':
              return Vm
            case 'vector':
            case 'vector2':
            case 'vector3':
            case 'vector4':
              return Xm
            case 'color':
              return Gm
            case 'quaternion':
              return jm
            case 'bool':
            case 'boolean':
              return Hm
            case 'string':
              return qm
          }
          throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + t)
        })(t.type)
        if (void 0 === t.times) {
          const e = [],
            n = []
          Om.flattenJSON(t.keys, e, n, 'value'), (t.times = e), (t.values = n)
        }
        return void 0 !== e.parse
          ? e.parse(t)
          : new e(t.name, t.times, t.values, t.interpolation)
      }
      const Zm = {
        enabled: !1,
        files: {},
        add: function (t, e) {
          !1 !== this.enabled && (this.files[t] = e)
        },
        get: function (t) {
          if (!1 !== this.enabled) return this.files[t]
        },
        remove: function (t) {
          delete this.files[t]
        },
        clear: function () {
          this.files = {}
        },
      }
      const Km = new (class {
        constructor(t, e, n) {
          const i = this
          let r,
            s = !1,
            o = 0,
            a = 0
          const l = []
          ;(this.onStart = void 0),
            (this.onLoad = t),
            (this.onProgress = e),
            (this.onError = n),
            (this.itemStart = function (t) {
              a++,
                !1 === s && void 0 !== i.onStart && i.onStart(t, o, a),
                (s = !0)
            }),
            (this.itemEnd = function (t) {
              o++,
                void 0 !== i.onProgress && i.onProgress(t, o, a),
                o === a && ((s = !1), void 0 !== i.onLoad && i.onLoad())
            }),
            (this.itemError = function (t) {
              void 0 !== i.onError && i.onError(t)
            }),
            (this.resolveURL = function (t) {
              return r ? r(t) : t
            }),
            (this.setURLModifier = function (t) {
              return (r = t), this
            }),
            (this.addHandler = function (t, e) {
              return l.push(t, e), this
            }),
            (this.removeHandler = function (t) {
              const e = l.indexOf(t)
              return -1 !== e && l.splice(e, 2), this
            }),
            (this.getHandler = function (t) {
              for (let e = 0, n = l.length; e < n; e += 2) {
                const n = l[e],
                  i = l[e + 1]
                if ((n.global && (n.lastIndex = 0), n.test(t))) return i
              }
              return null
            })
        }
      })()
      class Qm {
        constructor(t) {
          ;(this.manager = void 0 !== t ? t : Km),
            (this.crossOrigin = 'anonymous'),
            (this.withCredentials = !1),
            (this.path = ''),
            (this.resourcePath = ''),
            (this.requestHeader = {})
        }
        load() {}
        loadAsync(t, e) {
          const n = this
          return new Promise(function (i, r) {
            n.load(t, i, e, r)
          })
        }
        parse() {}
        setCrossOrigin(t) {
          return (this.crossOrigin = t), this
        }
        setWithCredentials(t) {
          return (this.withCredentials = t), this
        }
        setPath(t) {
          return (this.path = t), this
        }
        setResourcePath(t) {
          return (this.resourcePath = t), this
        }
        setRequestHeader(t) {
          return (this.requestHeader = t), this
        }
      }
      const $m = {}
      class tg extends Qm {
        constructor(t) {
          super(t)
        }
        load(t, e, n, i) {
          void 0 === t && (t = ''),
            void 0 !== this.path && (t = this.path + t),
            (t = this.manager.resolveURL(t))
          const r = this,
            s = Zm.get(t)
          if (void 0 !== s)
            return (
              r.manager.itemStart(t),
              setTimeout(function () {
                e && e(s), r.manager.itemEnd(t)
              }, 0),
              s
            )
          if (void 0 !== $m[t])
            return void $m[t].push({ onLoad: e, onProgress: n, onError: i })
          const o = t.match(/^data:(.*?)(;base64)?,(.*)$/)
          let a
          if (o) {
            const n = o[1],
              s = !!o[2]
            let a = o[3]
            ;(a = decodeURIComponent(a)), s && (a = atob(a))
            try {
              let i
              const s = (this.responseType || '').toLowerCase()
              switch (s) {
                case 'arraybuffer':
                case 'blob':
                  const t = new Uint8Array(a.length)
                  for (let e = 0; e < a.length; e++) t[e] = a.charCodeAt(e)
                  i =
                    'blob' === s ? new Blob([t.buffer], { type: n }) : t.buffer
                  break
                case 'document':
                  const e = new DOMParser()
                  i = e.parseFromString(a, n)
                  break
                case 'json':
                  i = JSON.parse(a)
                  break
                default:
                  i = a
              }
              setTimeout(function () {
                e && e(i), r.manager.itemEnd(t)
              }, 0)
            } catch (e) {
              setTimeout(function () {
                i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
              }, 0)
            }
          } else {
            ;($m[t] = []),
              $m[t].push({ onLoad: e, onProgress: n, onError: i }),
              (a = new XMLHttpRequest()),
              a.open('GET', t, !0),
              a.addEventListener(
                'load',
                function (e) {
                  const n = this.response,
                    i = $m[t]
                  if (
                    (delete $m[t], 200 === this.status || 0 === this.status)
                  ) {
                    0 === this.status &&
                      console.warn('THREE.FileLoader: HTTP Status 0 received.'),
                      Zm.add(t, n)
                    for (let t = 0, e = i.length; t < e; t++) {
                      const e = i[t]
                      e.onLoad && e.onLoad(n)
                    }
                    r.manager.itemEnd(t)
                  } else {
                    for (let t = 0, n = i.length; t < n; t++) {
                      const n = i[t]
                      n.onError && n.onError(e)
                    }
                    r.manager.itemError(t), r.manager.itemEnd(t)
                  }
                },
                !1,
              ),
              a.addEventListener(
                'progress',
                function (e) {
                  const n = $m[t]
                  for (let t = 0, i = n.length; t < i; t++) {
                    const i = n[t]
                    i.onProgress && i.onProgress(e)
                  }
                },
                !1,
              ),
              a.addEventListener(
                'error',
                function (e) {
                  const n = $m[t]
                  delete $m[t]
                  for (let t = 0, i = n.length; t < i; t++) {
                    const i = n[t]
                    i.onError && i.onError(e)
                  }
                  r.manager.itemError(t), r.manager.itemEnd(t)
                },
                !1,
              ),
              a.addEventListener(
                'abort',
                function (e) {
                  const n = $m[t]
                  delete $m[t]
                  for (let t = 0, i = n.length; t < i; t++) {
                    const i = n[t]
                    i.onError && i.onError(e)
                  }
                  r.manager.itemError(t), r.manager.itemEnd(t)
                },
                !1,
              ),
              void 0 !== this.responseType &&
                (a.responseType = this.responseType),
              void 0 !== this.withCredentials &&
                (a.withCredentials = this.withCredentials),
              a.overrideMimeType &&
                a.overrideMimeType(
                  void 0 !== this.mimeType ? this.mimeType : 'text/plain',
                )
            for (const t in this.requestHeader)
              a.setRequestHeader(t, this.requestHeader[t])
            a.send(null)
          }
          return r.manager.itemStart(t), a
        }
        setResponseType(t) {
          return (this.responseType = t), this
        }
        setMimeType(t) {
          return (this.mimeType = t), this
        }
      }
      class eg extends Qm {
        constructor(t) {
          super(t)
        }
        load(t, e, n, i) {
          void 0 !== this.path && (t = this.path + t),
            (t = this.manager.resolveURL(t))
          const r = this,
            s = Zm.get(t)
          if (void 0 !== s)
            return (
              r.manager.itemStart(t),
              setTimeout(function () {
                e && e(s), r.manager.itemEnd(t)
              }, 0),
              s
            )
          const o = ml('img')
          function a() {
            o.removeEventListener('load', a, !1),
              o.removeEventListener('error', l, !1),
              Zm.add(t, this),
              e && e(this),
              r.manager.itemEnd(t)
          }
          function l(e) {
            o.removeEventListener('load', a, !1),
              o.removeEventListener('error', l, !1),
              i && i(e),
              r.manager.itemError(t),
              r.manager.itemEnd(t)
          }
          return (
            o.addEventListener('load', a, !1),
            o.addEventListener('error', l, !1),
            'data:' !== t.substr(0, 5) &&
              void 0 !== this.crossOrigin &&
              (o.crossOrigin = this.crossOrigin),
            r.manager.itemStart(t),
            (o.src = t),
            o
          )
        }
      }
      class ng extends Qm {
        constructor(t) {
          super(t)
        }
        load(t, e, n, i) {
          const r = new ku(),
            s = new eg(this.manager)
          s.setCrossOrigin(this.crossOrigin), s.setPath(this.path)
          let o = 0
          function a(n) {
            s.load(
              t[n],
              function (t) {
                ;(r.images[n] = t),
                  o++,
                  6 === o && ((r.needsUpdate = !0), e && e(r))
              },
              void 0,
              i,
            )
          }
          for (let e = 0; e < t.length; ++e) a(e)
          return r
        }
      }
      class ig extends Qm {
        constructor(t) {
          super(t)
        }
        load(t, e, n, i) {
          const r = new yl(),
            s = new eg(this.manager)
          return (
            s.setCrossOrigin(this.crossOrigin),
            s.setPath(this.path),
            s.load(
              t,
              function (t) {
                ;(r.image = t), (r.needsUpdate = !0), void 0 !== e && e(r)
              },
              n,
              i,
            ),
            r
          )
        }
      }
      class rg extends Dc {
        constructor(t, e = 1) {
          super(),
            (this.type = 'Light'),
            (this.color = new Xc(t)),
            (this.intensity = e)
        }
        dispose() {}
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.intensity = t.intensity),
            this
          )
        }
        toJSON(t) {
          const e = super.toJSON(t)
          return (
            (e.object.color = this.color.getHex()),
            (e.object.intensity = this.intensity),
            void 0 !== this.groundColor &&
              (e.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (e.object.distance = this.distance),
            void 0 !== this.angle && (e.object.angle = this.angle),
            void 0 !== this.decay && (e.object.decay = this.decay),
            void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
            e
          )
        }
      }
      rg.prototype.isLight = !0
      ;(class extends rg {
        constructor(t, e, n) {
          super(t, n),
            (this.type = 'HemisphereLight'),
            this.position.copy(Dc.DefaultUp),
            this.updateMatrix(),
            (this.groundColor = new Xc(e))
        }
        copy(t) {
          return (
            rg.prototype.copy.call(this, t),
            this.groundColor.copy(t.groundColor),
            this
          )
        }
      }.prototype.isHemisphereLight = !0)
      const sg = new nc(),
        og = new Tl(),
        ag = new Tl()
      class lg {
        constructor(t) {
          ;(this.camera = t),
            (this.bias = 0),
            (this.normalBias = 0),
            (this.radius = 1),
            (this.blurSamples = 8),
            (this.mapSize = new dl(512, 512)),
            (this.map = null),
            (this.mapPass = null),
            (this.matrix = new nc()),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this._frustum = new ju()),
            (this._frameExtents = new dl(1, 1)),
            (this._viewportCount = 1),
            (this._viewports = [new bl(0, 0, 1, 1)])
        }
        getViewportCount() {
          return this._viewportCount
        }
        getFrustum() {
          return this._frustum
        }
        updateMatrices(t) {
          const e = this.camera,
            n = this.matrix
          og.setFromMatrixPosition(t.matrixWorld),
            e.position.copy(og),
            ag.setFromMatrixPosition(t.target.matrixWorld),
            e.lookAt(ag),
            e.updateMatrixWorld(),
            sg.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(sg),
            n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
            n.multiply(e.projectionMatrix),
            n.multiply(e.matrixWorldInverse)
        }
        getViewport(t) {
          return this._viewports[t]
        }
        getFrameExtents() {
          return this._frameExtents
        }
        dispose() {
          this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
        }
        copy(t) {
          return (
            (this.camera = t.camera.clone()),
            (this.bias = t.bias),
            (this.radius = t.radius),
            this.mapSize.copy(t.mapSize),
            this
          )
        }
        clone() {
          return new this.constructor().copy(this)
        }
        toJSON() {
          const t = {}
          return (
            0 !== this.bias && (t.bias = this.bias),
            0 !== this.normalBias && (t.normalBias = this.normalBias),
            1 !== this.radius && (t.radius = this.radius),
            (512 === this.mapSize.x && 512 === this.mapSize.y) ||
              (t.mapSize = this.mapSize.toArray()),
            (t.camera = this.camera.toJSON(!1).object),
            delete t.camera.matrix,
            t
          )
        }
      }
      class cg extends lg {
        constructor() {
          super(new Iu(50, 1, 0.5, 500)), (this.focus = 1)
        }
        updateMatrices(t) {
          const e = this.camera,
            n = 2 * el * t.angle * this.focus,
            i = this.mapSize.width / this.mapSize.height,
            r = t.distance || e.far
          ;(n === e.fov && i === e.aspect && r === e.far) ||
            ((e.fov = n),
            (e.aspect = i),
            (e.far = r),
            e.updateProjectionMatrix()),
            super.updateMatrices(t)
        }
        copy(t) {
          return super.copy(t), (this.focus = t.focus), this
        }
      }
      cg.prototype.isSpotLightShadow = !0
      class ug extends rg {
        constructor(t, e, n = 0, i = Math.PI / 3, r = 0, s = 1) {
          super(t, e),
            (this.type = 'SpotLight'),
            this.position.copy(Dc.DefaultUp),
            this.updateMatrix(),
            (this.target = new Dc()),
            (this.distance = n),
            (this.angle = i),
            (this.penumbra = r),
            (this.decay = s),
            (this.shadow = new cg())
        }
        get power() {
          return this.intensity * Math.PI
        }
        set power(t) {
          this.intensity = t / Math.PI
        }
        dispose() {
          this.shadow.dispose()
        }
        copy(t) {
          return (
            super.copy(t),
            (this.distance = t.distance),
            (this.angle = t.angle),
            (this.penumbra = t.penumbra),
            (this.decay = t.decay),
            (this.target = t.target.clone()),
            (this.shadow = t.shadow.clone()),
            this
          )
        }
      }
      ug.prototype.isSpotLight = !0
      const hg = new nc(),
        dg = new Tl(),
        pg = new Tl()
      class fg extends lg {
        constructor() {
          super(new Iu(90, 1, 0.5, 500)),
            (this._frameExtents = new dl(4, 2)),
            (this._viewportCount = 6),
            (this._viewports = [
              new bl(2, 1, 1, 1),
              new bl(0, 1, 1, 1),
              new bl(3, 1, 1, 1),
              new bl(1, 1, 1, 1),
              new bl(3, 0, 1, 1),
              new bl(1, 0, 1, 1),
            ]),
            (this._cubeDirections = [
              new Tl(1, 0, 0),
              new Tl(-1, 0, 0),
              new Tl(0, 0, 1),
              new Tl(0, 0, -1),
              new Tl(0, 1, 0),
              new Tl(0, -1, 0),
            ]),
            (this._cubeUps = [
              new Tl(0, 1, 0),
              new Tl(0, 1, 0),
              new Tl(0, 1, 0),
              new Tl(0, 1, 0),
              new Tl(0, 0, 1),
              new Tl(0, 0, -1),
            ])
        }
        updateMatrices(t, e = 0) {
          const n = this.camera,
            i = this.matrix,
            r = t.distance || n.far
          r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
            dg.setFromMatrixPosition(t.matrixWorld),
            n.position.copy(dg),
            pg.copy(n.position),
            pg.add(this._cubeDirections[e]),
            n.up.copy(this._cubeUps[e]),
            n.lookAt(pg),
            n.updateMatrixWorld(),
            i.makeTranslation(-dg.x, -dg.y, -dg.z),
            hg.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(hg)
        }
      }
      fg.prototype.isPointLightShadow = !0
      class mg extends rg {
        constructor(t, e, n = 0, i = 1) {
          super(t, e),
            (this.type = 'PointLight'),
            (this.distance = n),
            (this.decay = i),
            (this.shadow = new fg())
        }
        get power() {
          return 4 * this.intensity * Math.PI
        }
        set power(t) {
          this.intensity = t / (4 * Math.PI)
        }
        dispose() {
          this.shadow.dispose()
        }
        copy(t) {
          return (
            super.copy(t),
            (this.distance = t.distance),
            (this.decay = t.decay),
            (this.shadow = t.shadow.clone()),
            this
          )
        }
      }
      mg.prototype.isPointLight = !0
      class gg extends lg {
        constructor() {
          super(new rh(-5, 5, 5, -5, 0.5, 500))
        }
      }
      gg.prototype.isDirectionalLightShadow = !0
      class vg extends rg {
        constructor(t, e) {
          super(t, e),
            (this.type = 'DirectionalLight'),
            this.position.copy(Dc.DefaultUp),
            this.updateMatrix(),
            (this.target = new Dc()),
            (this.shadow = new gg())
        }
        dispose() {
          this.shadow.dispose()
        }
        copy(t) {
          return (
            super.copy(t),
            (this.target = t.target.clone()),
            (this.shadow = t.shadow.clone()),
            this
          )
        }
      }
      vg.prototype.isDirectionalLight = !0
      class _g extends rg {
        constructor(t, e) {
          super(t, e), (this.type = 'AmbientLight')
        }
      }
      _g.prototype.isAmbientLight = !0
      ;(class extends rg {
        constructor(t, e, n = 10, i = 10) {
          super(t, e),
            (this.type = 'RectAreaLight'),
            (this.width = n),
            (this.height = i)
        }
        get power() {
          return this.intensity * this.width * this.height * Math.PI
        }
        set power(t) {
          this.intensity = t / (this.width * this.height * Math.PI)
        }
        copy(t) {
          return (
            super.copy(t),
            (this.width = t.width),
            (this.height = t.height),
            this
          )
        }
        toJSON(t) {
          const e = super.toJSON(t)
          return (
            (e.object.width = this.width), (e.object.height = this.height), e
          )
        }
      }.prototype.isRectAreaLight = !0)
      class yg {
        constructor() {
          this.coefficients = []
          for (let t = 0; t < 9; t++) this.coefficients.push(new Tl())
        }
        set(t) {
          for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e])
          return this
        }
        zero() {
          for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0)
          return this
        }
        getAt(t, e) {
          const n = t.x,
            i = t.y,
            r = t.z,
            s = this.coefficients
          return (
            e.copy(s[0]).multiplyScalar(0.282095),
            e.addScaledVector(s[1], 0.488603 * i),
            e.addScaledVector(s[2], 0.488603 * r),
            e.addScaledVector(s[3], 0.488603 * n),
            e.addScaledVector(s[4], n * i * 1.092548),
            e.addScaledVector(s[5], i * r * 1.092548),
            e.addScaledVector(s[6], 0.315392 * (3 * r * r - 1)),
            e.addScaledVector(s[7], n * r * 1.092548),
            e.addScaledVector(s[8], 0.546274 * (n * n - i * i)),
            e
          )
        }
        getIrradianceAt(t, e) {
          const n = t.x,
            i = t.y,
            r = t.z,
            s = this.coefficients
          return (
            e.copy(s[0]).multiplyScalar(0.886227),
            e.addScaledVector(s[1], 1.023328 * i),
            e.addScaledVector(s[2], 1.023328 * r),
            e.addScaledVector(s[3], 1.023328 * n),
            e.addScaledVector(s[4], 0.858086 * n * i),
            e.addScaledVector(s[5], 0.858086 * i * r),
            e.addScaledVector(s[6], 0.743125 * r * r - 0.247708),
            e.addScaledVector(s[7], 0.858086 * n * r),
            e.addScaledVector(s[8], 0.429043 * (n * n - i * i)),
            e
          )
        }
        add(t) {
          for (let e = 0; e < 9; e++)
            this.coefficients[e].add(t.coefficients[e])
          return this
        }
        addScaledSH(t, e) {
          for (let n = 0; n < 9; n++)
            this.coefficients[n].addScaledVector(t.coefficients[n], e)
          return this
        }
        scale(t) {
          for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t)
          return this
        }
        lerp(t, e) {
          for (let n = 0; n < 9; n++)
            this.coefficients[n].lerp(t.coefficients[n], e)
          return this
        }
        equals(t) {
          for (let e = 0; e < 9; e++)
            if (!this.coefficients[e].equals(t.coefficients[e])) return !1
          return !0
        }
        copy(t) {
          return this.set(t.coefficients)
        }
        clone() {
          return new this.constructor().copy(this)
        }
        fromArray(t, e = 0) {
          const n = this.coefficients
          for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i)
          return this
        }
        toArray(t = [], e = 0) {
          const n = this.coefficients
          for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i)
          return t
        }
        static getBasisAt(t, e) {
          const n = t.x,
            i = t.y,
            r = t.z
          ;(e[0] = 0.282095),
            (e[1] = 0.488603 * i),
            (e[2] = 0.488603 * r),
            (e[3] = 0.488603 * n),
            (e[4] = 1.092548 * n * i),
            (e[5] = 1.092548 * i * r),
            (e[6] = 0.315392 * (3 * r * r - 1)),
            (e[7] = 1.092548 * n * r),
            (e[8] = 0.546274 * (n * n - i * i))
        }
      }
      yg.prototype.isSphericalHarmonics3 = !0
      class xg extends rg {
        constructor(t = new yg(), e = 1) {
          super(void 0, e), (this.sh = t)
        }
        copy(t) {
          return super.copy(t), this.sh.copy(t.sh), this
        }
        fromJSON(t) {
          return (this.intensity = t.intensity), this.sh.fromArray(t.sh), this
        }
        toJSON(t) {
          const e = super.toJSON(t)
          return (e.object.sh = this.sh.toArray()), e
        }
      }
      xg.prototype.isLightProbe = !0
      class bg {
        static decodeText(t) {
          if ('undefined' != typeof TextDecoder)
            return new TextDecoder().decode(t)
          let e = ''
          for (let n = 0, i = t.length; n < i; n++)
            e += String.fromCharCode(t[n])
          try {
            return decodeURIComponent(escape(e))
          } catch (t) {
            return e
          }
        }
        static extractUrlBase(t) {
          const e = t.lastIndexOf('/')
          return -1 === e ? './' : t.substr(0, e + 1)
        }
      }
      ;(class extends lu {
        constructor() {
          super(),
            (this.type = 'InstancedBufferGeometry'),
            (this.instanceCount = 1 / 0)
        }
        copy(t) {
          return super.copy(t), (this.instanceCount = t.instanceCount), this
        }
        clone() {
          return new this.constructor().copy(this)
        }
        toJSON() {
          const t = super.toJSON(this)
          return (
            (t.instanceCount = this.instanceCount),
            (t.isInstancedBufferGeometry = !0),
            t
          )
        }
      }.prototype.isInstancedBufferGeometry = !0)
      class wg extends Qm {
        constructor(t) {
          super(t),
            'undefined' == typeof createImageBitmap &&
              console.warn(
                'THREE.ImageBitmapLoader: createImageBitmap() not supported.',
              ),
            'undefined' == typeof fetch &&
              console.warn('THREE.ImageBitmapLoader: fetch() not supported.'),
            (this.options = { premultiplyAlpha: 'none' })
        }
        setOptions(t) {
          return (this.options = t), this
        }
        load(t, e, n, i) {
          void 0 === t && (t = ''),
            void 0 !== this.path && (t = this.path + t),
            (t = this.manager.resolveURL(t))
          const r = this,
            s = Zm.get(t)
          if (void 0 !== s)
            return (
              r.manager.itemStart(t),
              setTimeout(function () {
                e && e(s), r.manager.itemEnd(t)
              }, 0),
              s
            )
          const o = {}
          ;(o.credentials =
            'anonymous' === this.crossOrigin ? 'same-origin' : 'include'),
            (o.headers = this.requestHeader),
            fetch(t, o)
              .then(function (t) {
                return t.blob()
              })
              .then(function (t) {
                return createImageBitmap(
                  t,
                  Object.assign(r.options, { colorSpaceConversion: 'none' }),
                )
              })
              .then(function (n) {
                Zm.add(t, n), e && e(n), r.manager.itemEnd(t)
              })
              .catch(function (e) {
                i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
              }),
            r.manager.itemStart(t)
        }
      }
      let Mg
      wg.prototype.isImageBitmapLoader = !0
      class Sg extends Qm {
        constructor(t) {
          super(t)
        }
        load(t, e, n, i) {
          const r = this,
            s = new tg(this.manager)
          s.setResponseType('arraybuffer'),
            s.setPath(this.path),
            s.setRequestHeader(this.requestHeader),
            s.setWithCredentials(this.withCredentials),
            s.load(
              t,
              function (n) {
                try {
                  const t = n.slice(0)
                  ;(void 0 === Mg &&
                    (Mg = new (window.AudioContext ||
                      window.webkitAudioContext)()),
                  Mg).decodeAudioData(t, function (t) {
                    e(t)
                  })
                } catch (e) {
                  i ? i(e) : console.error(e), r.manager.itemError(t)
                }
              },
              n,
              i,
            )
        }
      }
      ;((class extends xg {
        constructor(t, e, n = 1) {
          super(void 0, n)
          const i = new Xc().set(t),
            r = new Xc().set(e),
            s = new Tl(i.r, i.g, i.b),
            o = new Tl(r.r, r.g, r.b),
            a = Math.sqrt(Math.PI),
            l = a * Math.sqrt(0.75)
          this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a),
            this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(l)
        }
      }.prototype.isHemisphereLightProbe = !0),
        (class extends xg {
          constructor(t, e = 1) {
            super(void 0, e)
            const n = new Xc().set(t)
            this.sh.coefficients[0]
              .set(n.r, n.g, n.b)
              .multiplyScalar(2 * Math.sqrt(Math.PI))
          }
        }.prototype.isAmbientLightProbe = !0))
      class Tg {
        constructor(t, e, n) {
          let i, r, s
          switch (((this.binding = t), (this.valueSize = n), e)) {
            case 'quaternion':
              ;(i = this._slerp),
                (r = this._slerpAdditive),
                (s = this._setAdditiveIdentityQuaternion),
                (this.buffer = new Float64Array(6 * n)),
                (this._workIndex = 5)
              break
            case 'string':
            case 'bool':
              ;(i = this._select),
                (r = this._select),
                (s = this._setAdditiveIdentityOther),
                (this.buffer = new Array(5 * n))
              break
            default:
              ;(i = this._lerp),
                (r = this._lerpAdditive),
                (s = this._setAdditiveIdentityNumeric),
                (this.buffer = new Float64Array(5 * n))
          }
          ;(this._mixBufferRegion = i),
            (this._mixBufferRegionAdditive = r),
            (this._setIdentity = s),
            (this._origIndex = 3),
            (this._addIndex = 4),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            (this.useCount = 0),
            (this.referenceCount = 0)
        }
        accumulate(t, e) {
          const n = this.buffer,
            i = this.valueSize,
            r = t * i + i
          let s = this.cumulativeWeight
          if (0 === s) {
            for (let t = 0; t !== i; ++t) n[r + t] = n[t]
            s = e
          } else {
            s += e
            const t = e / s
            this._mixBufferRegion(n, r, 0, t, i)
          }
          this.cumulativeWeight = s
        }
        accumulateAdditive(t) {
          const e = this.buffer,
            n = this.valueSize,
            i = n * this._addIndex
          0 === this.cumulativeWeightAdditive && this._setIdentity(),
            this._mixBufferRegionAdditive(e, i, 0, t, n),
            (this.cumulativeWeightAdditive += t)
        }
        apply(t) {
          const e = this.valueSize,
            n = this.buffer,
            i = t * e + e,
            r = this.cumulativeWeight,
            s = this.cumulativeWeightAdditive,
            o = this.binding
          if (
            ((this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            r < 1)
          ) {
            const t = e * this._origIndex
            this._mixBufferRegion(n, i, t, 1 - r, e)
          }
          s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e)
          for (let t = e, r = e + e; t !== r; ++t)
            if (n[t] !== n[t + e]) {
              o.setValue(n, i)
              break
            }
        }
        saveOriginalState() {
          const t = this.binding,
            e = this.buffer,
            n = this.valueSize,
            i = n * this._origIndex
          t.getValue(e, i)
          for (let t = n, r = i; t !== r; ++t) e[t] = e[i + (t % n)]
          this._setIdentity(),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0)
        }
        restoreOriginalState() {
          const t = 3 * this.valueSize
          this.binding.setValue(this.buffer, t)
        }
        _setAdditiveIdentityNumeric() {
          const t = this._addIndex * this.valueSize,
            e = t + this.valueSize
          for (let n = t; n < e; n++) this.buffer[n] = 0
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric(),
            (this.buffer[this._addIndex * this.valueSize + 3] = 1)
        }
        _setAdditiveIdentityOther() {
          const t = this._origIndex * this.valueSize,
            e = this._addIndex * this.valueSize
          for (let n = 0; n < this.valueSize; n++)
            this.buffer[e + n] = this.buffer[t + n]
        }
        _select(t, e, n, i, r) {
          if (i >= 0.5) for (let i = 0; i !== r; ++i) t[e + i] = t[n + i]
        }
        _slerp(t, e, n, i) {
          Sl.slerpFlat(t, e, t, e, t, n, i)
        }
        _slerpAdditive(t, e, n, i, r) {
          const s = this._workIndex * r
          Sl.multiplyQuaternionsFlat(t, s, t, e, t, n),
            Sl.slerpFlat(t, e, t, e, t, s, i)
        }
        _lerp(t, e, n, i, r) {
          const s = 1 - i
          for (let o = 0; o !== r; ++o) {
            const r = e + o
            t[r] = t[r] * s + t[n + o] * i
          }
        }
        _lerpAdditive(t, e, n, i, r) {
          for (let s = 0; s !== r; ++s) {
            const r = e + s
            t[r] = t[r] + t[n + s] * i
          }
        }
      }
      const Eg = new RegExp('[\\[\\]\\.:\\/]', 'g'),
        Dg = '[^\\[\\]\\.:\\/]',
        Ag = '[^' + '\\[\\]\\.:\\/'.replace('\\.', '') + ']',
        Cg = /((?:WC+[\/:])*)/.source.replace('WC', Dg),
        Lg = /(WCOD+)?/.source.replace('WCOD', Ag),
        Rg = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', Dg),
        Pg = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', Dg),
        Fg = new RegExp('^' + Cg + Lg + Rg + Pg + '$'),
        Ig = ['material', 'materials', 'bones']
      class Og {
        constructor(t, e, n) {
          ;(this.path = e),
            (this.parsedPath = n || Og.parseTrackName(e)),
            (this.node = Og.findNode(t, this.parsedPath.nodeName) || t),
            (this.rootNode = t),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound)
        }
        static create(t, e, n) {
          return t && t.isAnimationObjectGroup
            ? new Og.Composite(t, e, n)
            : new Og(t, e, n)
        }
        static sanitizeNodeName(t) {
          return t.replace(/\s/g, '_').replace(Eg, '')
        }
        static parseTrackName(t) {
          const e = Fg.exec(t)
          if (!e)
            throw new Error('PropertyBinding: Cannot parse trackName: ' + t)
          const n = {
              nodeName: e[2],
              objectName: e[3],
              objectIndex: e[4],
              propertyName: e[5],
              propertyIndex: e[6],
            },
            i = n.nodeName && n.nodeName.lastIndexOf('.')
          if (void 0 !== i && -1 !== i) {
            const t = n.nodeName.substring(i + 1)
            ;-1 !== Ig.indexOf(t) &&
              ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = t))
          }
          if (null === n.propertyName || 0 === n.propertyName.length)
            throw new Error(
              'PropertyBinding: can not parse propertyName from trackName: ' +
                t,
            )
          return n
        }
        static findNode(t, e) {
          if (
            !e ||
            '' === e ||
            '.' === e ||
            -1 === e ||
            e === t.name ||
            e === t.uuid
          )
            return t
          if (t.skeleton) {
            const n = t.skeleton.getBoneByName(e)
            if (void 0 !== n) return n
          }
          if (t.children) {
            const n = function (t) {
                for (let i = 0; i < t.length; i++) {
                  const r = t[i]
                  if (r.name === e || r.uuid === e) return r
                  const s = n(r.children)
                  if (s) return s
                }
                return null
              },
              i = n(t.children)
            if (i) return i
          }
          return null
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(t, e) {
          t[e] = this.targetObject[this.propertyName]
        }
        _getValue_array(t, e) {
          const n = this.resolvedProperty
          for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i]
        }
        _getValue_arrayElement(t, e) {
          t[e] = this.resolvedProperty[this.propertyIndex]
        }
        _getValue_toArray(t, e) {
          this.resolvedProperty.toArray(t, e)
        }
        _setValue_direct(t, e) {
          this.targetObject[this.propertyName] = t[e]
        }
        _setValue_direct_setNeedsUpdate(t, e) {
          ;(this.targetObject[this.propertyName] = t[e]),
            (this.targetObject.needsUpdate = !0)
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
          ;(this.targetObject[this.propertyName] = t[e]),
            (this.targetObject.matrixWorldNeedsUpdate = !0)
        }
        _setValue_array(t, e) {
          const n = this.resolvedProperty
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++]
        }
        _setValue_array_setNeedsUpdate(t, e) {
          const n = this.resolvedProperty
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++]
          this.targetObject.needsUpdate = !0
        }
        _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
          const n = this.resolvedProperty
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++]
          this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _setValue_arrayElement(t, e) {
          this.resolvedProperty[this.propertyIndex] = t[e]
        }
        _setValue_arrayElement_setNeedsUpdate(t, e) {
          ;(this.resolvedProperty[this.propertyIndex] = t[e]),
            (this.targetObject.needsUpdate = !0)
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
          ;(this.resolvedProperty[this.propertyIndex] = t[e]),
            (this.targetObject.matrixWorldNeedsUpdate = !0)
        }
        _setValue_fromArray(t, e) {
          this.resolvedProperty.fromArray(t, e)
        }
        _setValue_fromArray_setNeedsUpdate(t, e) {
          this.resolvedProperty.fromArray(t, e),
            (this.targetObject.needsUpdate = !0)
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
          this.resolvedProperty.fromArray(t, e),
            (this.targetObject.matrixWorldNeedsUpdate = !0)
        }
        _getValue_unbound(t, e) {
          this.bind(), this.getValue(t, e)
        }
        _setValue_unbound(t, e) {
          this.bind(), this.setValue(t, e)
        }
        bind() {
          let t = this.node
          const e = this.parsedPath,
            n = e.objectName,
            i = e.propertyName
          let r = e.propertyIndex
          if (
            (t ||
              ((t = Og.findNode(this.rootNode, e.nodeName) || this.rootNode),
              (this.node = t)),
            (this.getValue = this._getValue_unavailable),
            (this.setValue = this._setValue_unavailable),
            !t)
          )
            return void console.error(
              'THREE.PropertyBinding: Trying to update node for track: ' +
                this.path +
                " but it wasn't found.",
            )
          if (n) {
            let i = e.objectIndex
            switch (n) {
              case 'materials':
                if (!t.material)
                  return void console.error(
                    'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
                    this,
                  )
                if (!t.material.materials)
                  return void console.error(
                    'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',
                    this,
                  )
                t = t.material.materials
                break
              case 'bones':
                if (!t.skeleton)
                  return void console.error(
                    'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',
                    this,
                  )
                t = t.skeleton.bones
                for (let e = 0; e < t.length; e++)
                  if (t[e].name === i) {
                    i = e
                    break
                  }
                break
              default:
                if (void 0 === t[n])
                  return void console.error(
                    'THREE.PropertyBinding: Can not bind to objectName of node undefined.',
                    this,
                  )
                t = t[n]
            }
            if (void 0 !== i) {
              if (void 0 === t[i])
                return void console.error(
                  'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',
                  this,
                  t,
                )
              t = t[i]
            }
          }
          const s = t[i]
          if (void 0 === s) {
            const n = e.nodeName
            return void console.error(
              'THREE.PropertyBinding: Trying to update property for track: ' +
                n +
                '.' +
                i +
                " but it wasn't found.",
              t,
            )
          }
          let o = this.Versioning.None
          ;(this.targetObject = t),
            void 0 !== t.needsUpdate
              ? (o = this.Versioning.NeedsUpdate)
              : void 0 !== t.matrixWorldNeedsUpdate &&
                (o = this.Versioning.MatrixWorldNeedsUpdate)
          let a = this.BindingType.Direct
          if (void 0 !== r) {
            if ('morphTargetInfluences' === i) {
              if (!t.geometry)
                return void console.error(
                  'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',
                  this,
                )
              if (!t.geometry.isBufferGeometry)
                return void console.error(
                  'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.',
                  this,
                )
              if (!t.geometry.morphAttributes)
                return void console.error(
                  'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',
                  this,
                )
              void 0 !== t.morphTargetDictionary[r] &&
                (r = t.morphTargetDictionary[r])
            }
            ;(a = this.BindingType.ArrayElement),
              (this.resolvedProperty = s),
              (this.propertyIndex = r)
          } else
            void 0 !== s.fromArray && void 0 !== s.toArray
              ? ((a = this.BindingType.HasFromToArray),
                (this.resolvedProperty = s))
              : Array.isArray(s)
              ? ((a = this.BindingType.EntireArray),
                (this.resolvedProperty = s))
              : (this.propertyName = i)
          ;(this.getValue = this.GetterByBindingType[a]),
            (this.setValue = this.SetterByBindingTypeAndVersioning[a][o])
        }
        unbind() {
          ;(this.node = null),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound)
        }
      }
      ;(Og.Composite = class {
        constructor(t, e, n) {
          const i = n || Og.parseTrackName(e)
          ;(this._targetGroup = t), (this._bindings = t.subscribe_(e, i))
        }
        getValue(t, e) {
          this.bind()
          const n = this._targetGroup.nCachedObjects_,
            i = this._bindings[n]
          void 0 !== i && i.getValue(t, e)
        }
        setValue(t, e) {
          const n = this._bindings
          for (
            let i = this._targetGroup.nCachedObjects_, r = n.length;
            i !== r;
            ++i
          )
            n[i].setValue(t, e)
        }
        bind() {
          const t = this._bindings
          for (
            let e = this._targetGroup.nCachedObjects_, n = t.length;
            e !== n;
            ++e
          )
            t[e].bind()
        }
        unbind() {
          const t = this._bindings
          for (
            let e = this._targetGroup.nCachedObjects_, n = t.length;
            e !== n;
            ++e
          )
            t[e].unbind()
        }
      }),
        (Og.prototype.BindingType = {
          Direct: 0,
          EntireArray: 1,
          ArrayElement: 2,
          HasFromToArray: 3,
        }),
        (Og.prototype.Versioning = {
          None: 0,
          NeedsUpdate: 1,
          MatrixWorldNeedsUpdate: 2,
        }),
        (Og.prototype.GetterByBindingType = [
          Og.prototype._getValue_direct,
          Og.prototype._getValue_array,
          Og.prototype._getValue_arrayElement,
          Og.prototype._getValue_toArray,
        ]),
        (Og.prototype.SetterByBindingTypeAndVersioning = [
          [
            Og.prototype._setValue_direct,
            Og.prototype._setValue_direct_setNeedsUpdate,
            Og.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
          ],
          [
            Og.prototype._setValue_array,
            Og.prototype._setValue_array_setNeedsUpdate,
            Og.prototype._setValue_array_setMatrixWorldNeedsUpdate,
          ],
          [
            Og.prototype._setValue_arrayElement,
            Og.prototype._setValue_arrayElement_setNeedsUpdate,
            Og.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
          ],
          [
            Og.prototype._setValue_fromArray,
            Og.prototype._setValue_fromArray_setNeedsUpdate,
            Og.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
          ],
        ])
      class Ng {
        constructor(t, e, n = null, i = e.blendMode) {
          ;(this._mixer = t),
            (this._clip = e),
            (this._localRoot = n),
            (this.blendMode = i)
          const r = e.tracks,
            s = r.length,
            o = new Array(s),
            a = { endingStart: Ha, endingEnd: Ha }
          for (let t = 0; t !== s; ++t) {
            const e = r[t].createInterpolant(null)
            ;(o[t] = e), (e.settings = a)
          }
          ;(this._interpolantSettings = a),
            (this._interpolants = o),
            (this._propertyBindings = new Array(s)),
            (this._cacheIndex = null),
            (this._byClipCacheIndex = null),
            (this._timeScaleInterpolant = null),
            (this._weightInterpolant = null),
            (this.loop = 2201),
            (this._loopCount = -1),
            (this._startTime = null),
            (this.time = 0),
            (this.timeScale = 1),
            (this._effectiveTimeScale = 1),
            (this.weight = 1),
            (this._effectiveWeight = 1),
            (this.repetitions = 1 / 0),
            (this.paused = !1),
            (this.enabled = !0),
            (this.clampWhenFinished = !1),
            (this.zeroSlopeAtStart = !0),
            (this.zeroSlopeAtEnd = !0)
        }
        play() {
          return this._mixer._activateAction(this), this
        }
        stop() {
          return this._mixer._deactivateAction(this), this.reset()
        }
        reset() {
          return (
            (this.paused = !1),
            (this.enabled = !0),
            (this.time = 0),
            (this._loopCount = -1),
            (this._startTime = null),
            this.stopFading().stopWarping()
          )
        }
        isRunning() {
          return (
            this.enabled &&
            !this.paused &&
            0 !== this.timeScale &&
            null === this._startTime &&
            this._mixer._isActiveAction(this)
          )
        }
        isScheduled() {
          return this._mixer._isActiveAction(this)
        }
        startAt(t) {
          return (this._startTime = t), this
        }
        setLoop(t, e) {
          return (this.loop = t), (this.repetitions = e), this
        }
        setEffectiveWeight(t) {
          return (
            (this.weight = t),
            (this._effectiveWeight = this.enabled ? t : 0),
            this.stopFading()
          )
        }
        getEffectiveWeight() {
          return this._effectiveWeight
        }
        fadeIn(t) {
          return this._scheduleFading(t, 0, 1)
        }
        fadeOut(t) {
          return this._scheduleFading(t, 1, 0)
        }
        crossFadeFrom(t, e, n) {
          if ((t.fadeOut(e), this.fadeIn(e), n)) {
            const n = this._clip.duration,
              i = t._clip.duration,
              r = i / n,
              s = n / i
            t.warp(1, r, e), this.warp(s, 1, e)
          }
          return this
        }
        crossFadeTo(t, e, n) {
          return t.crossFadeFrom(this, e, n)
        }
        stopFading() {
          const t = this._weightInterpolant
          return (
            null !== t &&
              ((this._weightInterpolant = null),
              this._mixer._takeBackControlInterpolant(t)),
            this
          )
        }
        setEffectiveTimeScale(t) {
          return (
            (this.timeScale = t),
            (this._effectiveTimeScale = this.paused ? 0 : t),
            this.stopWarping()
          )
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale
        }
        setDuration(t) {
          return (this.timeScale = this._clip.duration / t), this.stopWarping()
        }
        syncWith(t) {
          return (
            (this.time = t.time),
            (this.timeScale = t.timeScale),
            this.stopWarping()
          )
        }
        halt(t) {
          return this.warp(this._effectiveTimeScale, 0, t)
        }
        warp(t, e, n) {
          const i = this._mixer,
            r = i.time,
            s = this.timeScale
          let o = this._timeScaleInterpolant
          null === o &&
            ((o = i._lendControlInterpolant()),
            (this._timeScaleInterpolant = o))
          const a = o.parameterPositions,
            l = o.sampleValues
          return (
            (a[0] = r), (a[1] = r + n), (l[0] = t / s), (l[1] = e / s), this
          )
        }
        stopWarping() {
          const t = this._timeScaleInterpolant
          return (
            null !== t &&
              ((this._timeScaleInterpolant = null),
              this._mixer._takeBackControlInterpolant(t)),
            this
          )
        }
        getMixer() {
          return this._mixer
        }
        getClip() {
          return this._clip
        }
        getRoot() {
          return this._localRoot || this._mixer._root
        }
        _update(t, e, n, i) {
          if (!this.enabled) return void this._updateWeight(t)
          const r = this._startTime
          if (null !== r) {
            const i = (t - r) * n
            if (i < 0 || 0 === n) return
            ;(this._startTime = null), (e = n * i)
          }
          e *= this._updateTimeScale(t)
          const s = this._updateTime(e),
            o = this._updateWeight(t)
          if (o > 0) {
            const t = this._interpolants,
              e = this._propertyBindings
            if (2501 === this.blendMode)
              for (let n = 0, i = t.length; n !== i; ++n)
                t[n].evaluate(s), e[n].accumulateAdditive(o)
            else
              for (let n = 0, r = t.length; n !== r; ++n)
                t[n].evaluate(s), e[n].accumulate(i, o)
          }
        }
        _updateWeight(t) {
          let e = 0
          if (this.enabled) {
            e = this.weight
            const n = this._weightInterpolant
            if (null !== n) {
              const i = n.evaluate(t)[0]
              ;(e *= i),
                t > n.parameterPositions[1] &&
                  (this.stopFading(), 0 === i && (this.enabled = !1))
            }
          }
          return (this._effectiveWeight = e), e
        }
        _updateTimeScale(t) {
          let e = 0
          if (!this.paused) {
            e = this.timeScale
            const n = this._timeScaleInterpolant
            null !== n &&
              ((e *= n.evaluate(t)[0]),
              t > n.parameterPositions[1] &&
                (this.stopWarping(),
                0 === e ? (this.paused = !0) : (this.timeScale = e)))
          }
          return (this._effectiveTimeScale = e), e
        }
        _updateTime(t) {
          const e = this._clip.duration,
            n = this.loop
          let i = this.time + t,
            r = this._loopCount
          const s = 2202 === n
          if (0 === t) return -1 === r ? i : s && 1 == (1 & r) ? e - i : i
          if (2200 === n) {
            ;-1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1))
            t: {
              if (i >= e) i = e
              else {
                if (!(i < 0)) {
                  this.time = i
                  break t
                }
                i = 0
              }
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (this.time = i),
                this._mixer.dispatchEvent({
                  type: 'finished',
                  action: this,
                  direction: t < 0 ? -1 : 1,
                })
            }
          } else {
            if (
              (-1 === r &&
                (t >= 0
                  ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, s))
                  : this._setEndings(0 === this.repetitions, !0, s)),
              i >= e || i < 0)
            ) {
              const n = Math.floor(i / e)
              ;(i -= e * n), (r += Math.abs(n))
              const o = this.repetitions - r
              if (o <= 0)
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1),
                  (i = t > 0 ? e : 0),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: 'finished',
                    action: this,
                    direction: t > 0 ? 1 : -1,
                  })
              else {
                if (1 === o) {
                  const e = t < 0
                  this._setEndings(e, !e, s)
                } else this._setEndings(!1, !1, s)
                ;(this._loopCount = r),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: 'loop',
                    action: this,
                    loopDelta: n,
                  })
              }
            } else this.time = i
            if (s && 1 == (1 & r)) return e - i
          }
          return i
        }
        _setEndings(t, e, n) {
          const i = this._interpolantSettings
          n
            ? ((i.endingStart = Ga), (i.endingEnd = Ga))
            : ((i.endingStart = t ? (this.zeroSlopeAtStart ? Ga : Ha) : Va),
              (i.endingEnd = e ? (this.zeroSlopeAtEnd ? Ga : Ha) : Va))
        }
        _scheduleFading(t, e, n) {
          const i = this._mixer,
            r = i.time
          let s = this._weightInterpolant
          null === s &&
            ((s = i._lendControlInterpolant()), (this._weightInterpolant = s))
          const o = s.parameterPositions,
            a = s.sampleValues
          return (o[0] = r), (a[0] = e), (o[1] = r + t), (a[1] = n), this
        }
      }
      ;(class extends Qa {
        constructor(t) {
          super(),
            (this._root = t),
            this._initMemoryManager(),
            (this._accuIndex = 0),
            (this.time = 0),
            (this.timeScale = 1)
        }
        _bindAction(t, e) {
          const n = t._localRoot || this._root,
            i = t._clip.tracks,
            r = i.length,
            s = t._propertyBindings,
            o = t._interpolants,
            a = n.uuid,
            l = this._bindingsByRootAndName
          let c = l[a]
          void 0 === c && ((c = {}), (l[a] = c))
          for (let t = 0; t !== r; ++t) {
            const r = i[t],
              l = r.name
            let u = c[l]
            if (void 0 !== u) s[t] = u
            else {
              if (((u = s[t]), void 0 !== u)) {
                null === u._cacheIndex &&
                  (++u.referenceCount, this._addInactiveBinding(u, a, l))
                continue
              }
              const i = e && e._propertyBindings[t].binding.parsedPath
              ;(u = new Tg(
                Og.create(n, l, i),
                r.ValueTypeName,
                r.getValueSize(),
              )),
                ++u.referenceCount,
                this._addInactiveBinding(u, a, l),
                (s[t] = u)
            }
            o[t].resultBuffer = u.buffer
          }
        }
        _activateAction(t) {
          if (!this._isActiveAction(t)) {
            if (null === t._cacheIndex) {
              const e = (t._localRoot || this._root).uuid,
                n = t._clip.uuid,
                i = this._actionsByClip[n]
              this._bindAction(t, i && i.knownActions[0]),
                this._addInactiveAction(t, n, e)
            }
            const e = t._propertyBindings
            for (let t = 0, n = e.length; t !== n; ++t) {
              const n = e[t]
              0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
            }
            this._lendAction(t)
          }
        }
        _deactivateAction(t) {
          if (this._isActiveAction(t)) {
            const e = t._propertyBindings
            for (let t = 0, n = e.length; t !== n; ++t) {
              const n = e[t]
              0 == --n.useCount &&
                (n.restoreOriginalState(), this._takeBackBinding(n))
            }
            this._takeBackAction(t)
          }
        }
        _initMemoryManager() {
          ;(this._actions = []),
            (this._nActiveActions = 0),
            (this._actionsByClip = {}),
            (this._bindings = []),
            (this._nActiveBindings = 0),
            (this._bindingsByRootAndName = {}),
            (this._controlInterpolants = []),
            (this._nActiveControlInterpolants = 0)
          const t = this
          this.stats = {
            actions: {
              get total() {
                return t._actions.length
              },
              get inUse() {
                return t._nActiveActions
              },
            },
            bindings: {
              get total() {
                return t._bindings.length
              },
              get inUse() {
                return t._nActiveBindings
              },
            },
            controlInterpolants: {
              get total() {
                return t._controlInterpolants.length
              },
              get inUse() {
                return t._nActiveControlInterpolants
              },
            },
          }
        }
        _isActiveAction(t) {
          const e = t._cacheIndex
          return null !== e && e < this._nActiveActions
        }
        _addInactiveAction(t, e, n) {
          const i = this._actions,
            r = this._actionsByClip
          let s = r[e]
          if (void 0 === s)
            (s = { knownActions: [t], actionByRoot: {} }),
              (t._byClipCacheIndex = 0),
              (r[e] = s)
          else {
            const e = s.knownActions
            ;(t._byClipCacheIndex = e.length), e.push(t)
          }
          ;(t._cacheIndex = i.length), i.push(t), (s.actionByRoot[n] = t)
        }
        _removeInactiveAction(t) {
          const e = this._actions,
            n = e[e.length - 1],
            i = t._cacheIndex
          ;(n._cacheIndex = i), (e[i] = n), e.pop(), (t._cacheIndex = null)
          const r = t._clip.uuid,
            s = this._actionsByClip,
            o = s[r],
            a = o.knownActions,
            l = a[a.length - 1],
            c = t._byClipCacheIndex
          ;(l._byClipCacheIndex = c),
            (a[c] = l),
            a.pop(),
            (t._byClipCacheIndex = null),
            delete o.actionByRoot[(t._localRoot || this._root).uuid],
            0 === a.length && delete s[r],
            this._removeInactiveBindingsForAction(t)
        }
        _removeInactiveBindingsForAction(t) {
          const e = t._propertyBindings
          for (let t = 0, n = e.length; t !== n; ++t) {
            const n = e[t]
            0 == --n.referenceCount && this._removeInactiveBinding(n)
          }
        }
        _lendAction(t) {
          const e = this._actions,
            n = t._cacheIndex,
            i = this._nActiveActions++,
            r = e[i]
          ;(t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r)
        }
        _takeBackAction(t) {
          const e = this._actions,
            n = t._cacheIndex,
            i = --this._nActiveActions,
            r = e[i]
          ;(t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r)
        }
        _addInactiveBinding(t, e, n) {
          const i = this._bindingsByRootAndName,
            r = this._bindings
          let s = i[e]
          void 0 === s && ((s = {}), (i[e] = s)),
            (s[n] = t),
            (t._cacheIndex = r.length),
            r.push(t)
        }
        _removeInactiveBinding(t) {
          const e = this._bindings,
            n = t.binding,
            i = n.rootNode.uuid,
            r = n.path,
            s = this._bindingsByRootAndName,
            o = s[i],
            a = e[e.length - 1],
            l = t._cacheIndex
          ;(a._cacheIndex = l),
            (e[l] = a),
            e.pop(),
            delete o[r],
            0 === Object.keys(o).length && delete s[i]
        }
        _lendBinding(t) {
          const e = this._bindings,
            n = t._cacheIndex,
            i = this._nActiveBindings++,
            r = e[i]
          ;(t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r)
        }
        _takeBackBinding(t) {
          const e = this._bindings,
            n = t._cacheIndex,
            i = --this._nActiveBindings,
            r = e[i]
          ;(t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r)
        }
        _lendControlInterpolant() {
          const t = this._controlInterpolants,
            e = this._nActiveControlInterpolants++
          let n = t[e]
          return (
            void 0 === n &&
              ((n = new Bm(
                new Float32Array(2),
                new Float32Array(2),
                1,
                this._controlInterpolantsResultBuffer,
              )),
              (n.__cacheIndex = e),
              (t[e] = n)),
            n
          )
        }
        _takeBackControlInterpolant(t) {
          const e = this._controlInterpolants,
            n = t.__cacheIndex,
            i = --this._nActiveControlInterpolants,
            r = e[i]
          ;(t.__cacheIndex = i), (e[i] = t), (r.__cacheIndex = n), (e[n] = r)
        }
        clipAction(t, e, n) {
          const i = e || this._root,
            r = i.uuid
          let s = 'string' == typeof t ? Ym.findByName(i, t) : t
          const o = null !== s ? s.uuid : t,
            a = this._actionsByClip[o]
          let l = null
          if (
            (void 0 === n && (n = null !== s ? s.blendMode : 2500),
            void 0 !== a)
          ) {
            const t = a.actionByRoot[r]
            if (void 0 !== t && t.blendMode === n) return t
            ;(l = a.knownActions[0]), null === s && (s = l._clip)
          }
          if (null === s) return null
          const c = new Ng(this, s, e, n)
          return this._bindAction(c, l), this._addInactiveAction(c, o, r), c
        }
        existingAction(t, e) {
          const n = e || this._root,
            i = n.uuid,
            r = 'string' == typeof t ? Ym.findByName(n, t) : t,
            s = r ? r.uuid : t,
            o = this._actionsByClip[s]
          return (void 0 !== o && o.actionByRoot[i]) || null
        }
        stopAllAction() {
          const t = this._actions
          for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop()
          return this
        }
        update(t) {
          t *= this.timeScale
          const e = this._actions,
            n = this._nActiveActions,
            i = (this.time += t),
            r = Math.sign(t),
            s = (this._accuIndex ^= 1)
          for (let o = 0; o !== n; ++o) e[o]._update(i, t, r, s)
          const o = this._bindings,
            a = this._nActiveBindings
          for (let t = 0; t !== a; ++t) o[t].apply(s)
          return this
        }
        setTime(t) {
          this.time = 0
          for (let t = 0; t < this._actions.length; t++)
            this._actions[t].time = 0
          return this.update(t)
        }
        getRoot() {
          return this._root
        }
        uncacheClip(t) {
          const e = this._actions,
            n = t.uuid,
            i = this._actionsByClip,
            r = i[n]
          if (void 0 !== r) {
            const t = r.knownActions
            for (let n = 0, i = t.length; n !== i; ++n) {
              const i = t[n]
              this._deactivateAction(i)
              const r = i._cacheIndex,
                s = e[e.length - 1]
              ;(i._cacheIndex = null),
                (i._byClipCacheIndex = null),
                (s._cacheIndex = r),
                (e[r] = s),
                e.pop(),
                this._removeInactiveBindingsForAction(i)
            }
            delete i[n]
          }
        }
        uncacheRoot(t) {
          const e = t.uuid,
            n = this._actionsByClip
          for (const t in n) {
            const i = n[t].actionByRoot[e]
            void 0 !== i &&
              (this._deactivateAction(i), this._removeInactiveAction(i))
          }
          const i = this._bindingsByRootAndName[e]
          if (void 0 !== i)
            for (const t in i) {
              const e = i[t]
              e.restoreOriginalState(), this._removeInactiveBinding(e)
            }
        }
        uncacheAction(t, e) {
          const n = this.existingAction(t, e)
          null !== n &&
            (this._deactivateAction(n), this._removeInactiveAction(n))
        }
      }.prototype._controlInterpolantsResultBuffer = new Float32Array(1))
      class kg {
        constructor(t) {
          'string' == typeof t &&
            (console.warn('THREE.Uniform: Type parameter is no longer needed.'),
            (t = arguments[1])),
            (this.value = t)
        }
        clone() {
          return new kg(
            void 0 === this.value.clone ? this.value : this.value.clone(),
          )
        }
      }
      ;(class extends Ip {
        constructor(t, e, n = 1) {
          super(t, e), (this.meshPerAttribute = n)
        }
        copy(t) {
          return (
            super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
          )
        }
        clone(t) {
          const e = super.clone(t)
          return (e.meshPerAttribute = this.meshPerAttribute), e
        }
        toJSON(t) {
          const e = super.toJSON(t)
          return (
            (e.isInstancedInterleavedBuffer = !0),
            (e.meshPerAttribute = this.meshPerAttribute),
            e
          )
        }
      }.prototype.isInstancedInterleavedBuffer = !0)
      class Bg {
        constructor(t, e, n = 0, i = 1 / 0) {
          ;(this.ray = new ec(t, e)),
            (this.near = n),
            (this.far = i),
            (this.camera = null),
            (this.layers = new pc()),
            (this.params = {
              Mesh: {},
              Line: { threshold: 1 },
              LOD: {},
              Points: { threshold: 1 },
              Sprite: {},
            })
        }
        set(t, e) {
          this.ray.set(t, e)
        }
        setFromCamera(t, e) {
          e && e.isPerspectiveCamera
            ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
              this.ray.direction
                .set(t.x, t.y, 0.5)
                .unproject(e)
                .sub(this.ray.origin)
                .normalize(),
              (this.camera = e))
            : e && e.isOrthographicCamera
            ? (this.ray.origin
                .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
                .unproject(e),
              this.ray.direction
                .set(0, 0, -1)
                .transformDirection(e.matrixWorld),
              (this.camera = e))
            : console.error(
                'THREE.Raycaster: Unsupported camera type: ' + e.type,
              )
        }
        intersectObject(t, e = !0, n = []) {
          return Ug(t, this, n, e), n.sort(zg), n
        }
        intersectObjects(t, e = !0, n = []) {
          for (let i = 0, r = t.length; i < r; i++) Ug(t[i], this, n, e)
          return n.sort(zg), n
        }
      }
      function zg(t, e) {
        return t.distance - e.distance
      }
      function Ug(t, e, n, i) {
        if ((t.layers.test(e.layers) && t.raycast(e, n), !0 === i)) {
          const i = t.children
          for (let t = 0, r = i.length; t < r; t++) Ug(i[t], e, n, !0)
        }
      }
      const Hg = new dl()
      class Gg {
        constructor(t = new dl(1 / 0, 1 / 0), e = new dl(-1 / 0, -1 / 0)) {
          ;(this.min = t), (this.max = e)
        }
        set(t, e) {
          return this.min.copy(t), this.max.copy(e), this
        }
        setFromPoints(t) {
          this.makeEmpty()
          for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e])
          return this
        }
        setFromCenterAndSize(t, e) {
          const n = Hg.copy(e).multiplyScalar(0.5)
          return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
        }
        clone() {
          return new this.constructor().copy(this)
        }
        copy(t) {
          return this.min.copy(t.min), this.max.copy(t.max), this
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = 1 / 0),
            (this.max.x = this.max.y = -1 / 0),
            this
          )
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y
        }
        getCenter(t) {
          return this.isEmpty()
            ? t.set(0, 0)
            : t.addVectors(this.min, this.max).multiplyScalar(0.5)
        }
        getSize(t) {
          return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
        }
        expandByPoint(t) {
          return this.min.min(t), this.max.max(t), this
        }
        expandByVector(t) {
          return this.min.sub(t), this.max.add(t), this
        }
        expandByScalar(t) {
          return this.min.addScalar(-t), this.max.addScalar(t), this
        }
        containsPoint(t) {
          return !(
            t.x < this.min.x ||
            t.x > this.max.x ||
            t.y < this.min.y ||
            t.y > this.max.y
          )
        }
        containsBox(t) {
          return (
            this.min.x <= t.min.x &&
            t.max.x <= this.max.x &&
            this.min.y <= t.min.y &&
            t.max.y <= this.max.y
          )
        }
        getParameter(t, e) {
          return e.set(
            (t.x - this.min.x) / (this.max.x - this.min.x),
            (t.y - this.min.y) / (this.max.y - this.min.y),
          )
        }
        intersectsBox(t) {
          return !(
            t.max.x < this.min.x ||
            t.min.x > this.max.x ||
            t.max.y < this.min.y ||
            t.min.y > this.max.y
          )
        }
        clampPoint(t, e) {
          return e.copy(t).clamp(this.min, this.max)
        }
        distanceToPoint(t) {
          return Hg.copy(t).clamp(this.min, this.max).sub(t).length()
        }
        intersect(t) {
          return this.min.max(t.min), this.max.min(t.max), this
        }
        union(t) {
          return this.min.min(t.min), this.max.max(t.max), this
        }
        translate(t) {
          return this.min.add(t), this.max.add(t), this
        }
        equals(t) {
          return t.min.equals(this.min) && t.max.equals(this.max)
        }
      }
      ;(Gg.prototype.isBox2 = !0),
        (class extends Dc {
          constructor(t) {
            super(),
              (this.material = t),
              (this.render = function () {}),
              (this.hasPositions = !1),
              (this.hasNormals = !1),
              (this.hasColors = !1),
              (this.hasUvs = !1),
              (this.positionArray = null),
              (this.normalArray = null),
              (this.colorArray = null),
              (this.uvArray = null),
              (this.count = 0)
          }
        }.prototype.isImmediateRenderObject = !0)
      const Vg = new Tl(),
        Wg = new nc(),
        jg = new nc()
      function qg(t) {
        const e = []
        t && t.isBone && e.push(t)
        for (let n = 0; n < t.children.length; n++)
          e.push.apply(e, qg(t.children[n]))
        return e
      }
      class Xg {
        constructor() {
          ;(this.type = 'ShapePath'),
            (this.color = new Xc()),
            (this.subPaths = []),
            (this.currentPath = null)
        }
        moveTo(t, e) {
          return (
            (this.currentPath = new $f()),
            this.subPaths.push(this.currentPath),
            this.currentPath.moveTo(t, e),
            this
          )
        }
        lineTo(t, e) {
          return this.currentPath.lineTo(t, e), this
        }
        quadraticCurveTo(t, e, n, i) {
          return this.currentPath.quadraticCurveTo(t, e, n, i), this
        }
        bezierCurveTo(t, e, n, i, r, s) {
          return this.currentPath.bezierCurveTo(t, e, n, i, r, s), this
        }
        splineThru(t) {
          return this.currentPath.splineThru(t), this
        }
        toShapes(t, e) {
          function n(t) {
            const e = []
            for (let n = 0, i = t.length; n < i; n++) {
              const i = t[n],
                r = new tm()
              ;(r.curves = i.curves), e.push(r)
            }
            return e
          }
          function i(t, e) {
            const n = e.length
            let i = !1
            for (let r = n - 1, s = 0; s < n; r = s++) {
              let n = e[r],
                o = e[s],
                a = o.x - n.x,
                l = o.y - n.y
              if (Math.abs(l) > Number.EPSILON) {
                if (
                  (l < 0 && ((n = e[s]), (a = -a), (o = e[r]), (l = -l)),
                  t.y < n.y || t.y > o.y)
                )
                  continue
                if (t.y === n.y) {
                  if (t.x === n.x) return !0
                } else {
                  const e = l * (t.x - n.x) - a * (t.y - n.y)
                  if (0 === e) return !0
                  if (e < 0) continue
                  i = !i
                }
              } else {
                if (t.y !== n.y) continue
                if ((o.x <= t.x && t.x <= n.x) || (n.x <= t.x && t.x <= o.x))
                  return !0
              }
            }
            return i
          }
          const r = Tm.isClockWise,
            s = this.subPaths
          if (0 === s.length) return []
          if (!0 === e) return n(s)
          let o, a, l
          const c = []
          if (1 === s.length)
            return (
              (a = s[0]), (l = new tm()), (l.curves = a.curves), c.push(l), c
            )
          let u = !r(s[0].getPoints())
          u = t ? !u : u
          const h = [],
            d = []
          let p,
            f,
            m = [],
            g = 0
          ;(d[g] = void 0), (m[g] = [])
          for (let e = 0, n = s.length; e < n; e++)
            (a = s[e]),
              (p = a.getPoints()),
              (o = r(p)),
              (o = t ? !o : o),
              o
                ? (!u && d[g] && g++,
                  (d[g] = { s: new tm(), p: p }),
                  (d[g].s.curves = a.curves),
                  u && g++,
                  (m[g] = []))
                : m[g].push({ h: a, p: p[0] })
          if (!d[0]) return n(s)
          if (d.length > 1) {
            let t = !1
            const e = []
            for (let t = 0, e = d.length; t < e; t++) h[t] = []
            for (let n = 0, r = d.length; n < r; n++) {
              const r = m[n]
              for (let s = 0; s < r.length; s++) {
                const o = r[s]
                let a = !0
                for (let r = 0; r < d.length; r++)
                  i(o.p, d[r].p) &&
                    (n !== r && e.push({ froms: n, tos: r, hole: s }),
                    a ? ((a = !1), h[r].push(o)) : (t = !0))
                a && h[n].push(o)
              }
            }
            e.length > 0 && (t || (m = h))
          }
          for (let t = 0, e = d.length; t < e; t++) {
            ;(l = d[t].s), c.push(l), (f = m[t])
            for (let t = 0, e = f.length; t < e; t++) l.holes.push(f[t].h)
          }
          return c
        }
      }
      const Yg = new Float32Array(1)
      new Int32Array(Yg.buffer),
        (Ff.create = function (t, e) {
          return (
            console.log('THREE.Curve.create() has been deprecated'),
            (t.prototype = Object.create(Ff.prototype)),
            (t.prototype.constructor = t),
            (t.prototype.getPoint = e),
            t
          )
        }),
        ($f.prototype.fromPoints = function (t) {
          return (
            console.warn(
              'THREE.Path: .fromPoints() has been renamed to .setFromPoints().',
            ),
            this.setFromPoints(t)
          )
        }),
        (class extends Sf {
          constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
            ;(n = new Xc(n)), (i = new Xc(i))
            const r = e / 2,
              s = t / e,
              o = t / 2,
              a = [],
              l = []
            for (let t = 0, c = 0, u = -o; t <= e; t++, u += s) {
              a.push(-o, 0, u, o, 0, u), a.push(u, 0, -o, u, 0, o)
              const e = t === r ? n : i
              e.toArray(l, c),
                (c += 3),
                e.toArray(l, c),
                (c += 3),
                e.toArray(l, c),
                (c += 3),
                e.toArray(l, c),
                (c += 3)
            }
            const c = new lu()
            c.setAttribute('position', new tu(a, 3)),
              c.setAttribute('color', new tu(l, 3)),
              super(c, new mf({ vertexColors: !0, toneMapped: !1 })),
              (this.type = 'GridHelper')
          }
        }.prototype.setColors = function () {
          console.error(
            'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.',
          )
        }),
        (class extends Sf {
          constructor(t) {
            const e = qg(t),
              n = new lu(),
              i = [],
              r = [],
              s = new Xc(0, 0, 1),
              o = new Xc(0, 1, 0)
            for (let t = 0; t < e.length; t++) {
              const n = e[t]
              n.parent &&
                n.parent.isBone &&
                (i.push(0, 0, 0),
                i.push(0, 0, 0),
                r.push(s.r, s.g, s.b),
                r.push(o.r, o.g, o.b))
            }
            n.setAttribute('position', new tu(i, 3)),
              n.setAttribute('color', new tu(r, 3)),
              super(
                n,
                new mf({
                  vertexColors: !0,
                  depthTest: !1,
                  depthWrite: !1,
                  toneMapped: !1,
                  transparent: !0,
                }),
              ),
              (this.type = 'SkeletonHelper'),
              (this.isSkeletonHelper = !0),
              (this.root = t),
              (this.bones = e),
              (this.matrix = t.matrixWorld),
              (this.matrixAutoUpdate = !1)
          }
          updateMatrixWorld(t) {
            const e = this.bones,
              n = this.geometry,
              i = n.getAttribute('position')
            jg.copy(this.root.matrixWorld).invert()
            for (let t = 0, n = 0; t < e.length; t++) {
              const r = e[t]
              r.parent &&
                r.parent.isBone &&
                (Wg.multiplyMatrices(jg, r.matrixWorld),
                Vg.setFromMatrixPosition(Wg),
                i.setXYZ(n, Vg.x, Vg.y, Vg.z),
                Wg.multiplyMatrices(jg, r.parent.matrixWorld),
                Vg.setFromMatrixPosition(Wg),
                i.setXYZ(n + 1, Vg.x, Vg.y, Vg.z),
                (n += 2))
            }
            ;(n.getAttribute('position').needsUpdate = !0),
              super.updateMatrixWorld(t)
          }
        }.prototype.update = function () {
          console.error(
            'THREE.SkeletonHelper: update() no longer needs to be called.',
          )
        }),
        (Qm.prototype.extractUrlBase = function (t) {
          return (
            console.warn(
              'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.',
            ),
            bg.extractUrlBase(t)
          )
        }),
        (Qm.Handlers = {
          add: function () {
            console.error(
              'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.',
            )
          },
          get: function () {
            console.error(
              'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.',
            )
          },
        }),
        (Gg.prototype.center = function (t) {
          return (
            console.warn(
              'THREE.Box2: .center() has been renamed to .getCenter().',
            ),
            this.getCenter(t)
          )
        }),
        (Gg.prototype.empty = function () {
          return (
            console.warn(
              'THREE.Box2: .empty() has been renamed to .isEmpty().',
            ),
            this.isEmpty()
          )
        }),
        (Gg.prototype.isIntersectionBox = function (t) {
          return (
            console.warn(
              'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().',
            ),
            this.intersectsBox(t)
          )
        }),
        (Gg.prototype.size = function (t) {
          return (
            console.warn('THREE.Box2: .size() has been renamed to .getSize().'),
            this.getSize(t)
          )
        }),
        (Al.prototype.center = function (t) {
          return (
            console.warn(
              'THREE.Box3: .center() has been renamed to .getCenter().',
            ),
            this.getCenter(t)
          )
        }),
        (Al.prototype.empty = function () {
          return (
            console.warn(
              'THREE.Box3: .empty() has been renamed to .isEmpty().',
            ),
            this.isEmpty()
          )
        }),
        (Al.prototype.isIntersectionBox = function (t) {
          return (
            console.warn(
              'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().',
            ),
            this.intersectsBox(t)
          )
        }),
        (Al.prototype.isIntersectionSphere = function (t) {
          return (
            console.warn(
              'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().',
            ),
            this.intersectsSphere(t)
          )
        }),
        (Al.prototype.size = function (t) {
          return (
            console.warn('THREE.Box3: .size() has been renamed to .getSize().'),
            this.getSize(t)
          )
        }),
        (Xl.prototype.empty = function () {
          return (
            console.warn(
              'THREE.Sphere: .empty() has been renamed to .isEmpty().',
            ),
            this.isEmpty()
          )
        }),
        (ju.prototype.setFromMatrix = function (t) {
          return (
            console.warn(
              'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().',
            ),
            this.setFromProjectionMatrix(t)
          )
        }),
        (pl.prototype.flattenToArrayOffset = function (t, e) {
          return (
            console.warn(
              'THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.',
            ),
            this.toArray(t, e)
          )
        }),
        (pl.prototype.multiplyVector3 = function (t) {
          return (
            console.warn(
              'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.',
            ),
            t.applyMatrix3(this)
          )
        }),
        (pl.prototype.multiplyVector3Array = function () {
          console.error(
            'THREE.Matrix3: .multiplyVector3Array() has been removed.',
          )
        }),
        (pl.prototype.applyToBufferAttribute = function (t) {
          return (
            console.warn(
              'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.',
            ),
            t.applyMatrix3(this)
          )
        }),
        (pl.prototype.applyToVector3Array = function () {
          console.error(
            'THREE.Matrix3: .applyToVector3Array() has been removed.',
          )
        }),
        (pl.prototype.getInverse = function (t) {
          return (
            console.warn(
              'THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.',
            ),
            this.copy(t).invert()
          )
        }),
        (nc.prototype.extractPosition = function (t) {
          return (
            console.warn(
              'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().',
            ),
            this.copyPosition(t)
          )
        }),
        (nc.prototype.flattenToArrayOffset = function (t, e) {
          return (
            console.warn(
              'THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.',
            ),
            this.toArray(t, e)
          )
        }),
        (nc.prototype.getPosition = function () {
          return (
            console.warn(
              'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.',
            ),
            new Tl().setFromMatrixColumn(this, 3)
          )
        }),
        (nc.prototype.setRotationFromQuaternion = function (t) {
          return (
            console.warn(
              'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().',
            ),
            this.makeRotationFromQuaternion(t)
          )
        }),
        (nc.prototype.multiplyToArray = function () {
          console.warn('THREE.Matrix4: .multiplyToArray() has been removed.')
        }),
        (nc.prototype.multiplyVector3 = function (t) {
          return (
            console.warn(
              'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.',
            ),
            t.applyMatrix4(this)
          )
        }),
        (nc.prototype.multiplyVector4 = function (t) {
          return (
            console.warn(
              'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.',
            ),
            t.applyMatrix4(this)
          )
        }),
        (nc.prototype.multiplyVector3Array = function () {
          console.error(
            'THREE.Matrix4: .multiplyVector3Array() has been removed.',
          )
        }),
        (nc.prototype.rotateAxis = function (t) {
          console.warn(
            'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.',
          ),
            t.transformDirection(this)
        }),
        (nc.prototype.crossVector = function (t) {
          return (
            console.warn(
              'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.',
            ),
            t.applyMatrix4(this)
          )
        }),
        (nc.prototype.translate = function () {
          console.error('THREE.Matrix4: .translate() has been removed.')
        }),
        (nc.prototype.rotateX = function () {
          console.error('THREE.Matrix4: .rotateX() has been removed.')
        }),
        (nc.prototype.rotateY = function () {
          console.error('THREE.Matrix4: .rotateY() has been removed.')
        }),
        (nc.prototype.rotateZ = function () {
          console.error('THREE.Matrix4: .rotateZ() has been removed.')
        }),
        (nc.prototype.rotateByAxis = function () {
          console.error('THREE.Matrix4: .rotateByAxis() has been removed.')
        }),
        (nc.prototype.applyToBufferAttribute = function (t) {
          return (
            console.warn(
              'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.',
            ),
            t.applyMatrix4(this)
          )
        }),
        (nc.prototype.applyToVector3Array = function () {
          console.error(
            'THREE.Matrix4: .applyToVector3Array() has been removed.',
          )
        }),
        (nc.prototype.makeFrustum = function (t, e, n, i, r, s) {
          return (
            console.warn(
              'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.',
            ),
            this.makePerspective(t, e, i, n, r, s)
          )
        }),
        (nc.prototype.getInverse = function (t) {
          return (
            console.warn(
              'THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.',
            ),
            this.copy(t).invert()
          )
        }),
        (Gu.prototype.isIntersectionLine = function (t) {
          return (
            console.warn(
              'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().',
            ),
            this.intersectsLine(t)
          )
        }),
        (Sl.prototype.multiplyVector3 = function (t) {
          return (
            console.warn(
              'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.',
            ),
            t.applyQuaternion(this)
          )
        }),
        (Sl.prototype.inverse = function () {
          return (
            console.warn(
              'THREE.Quaternion: .inverse() has been renamed to invert().',
            ),
            this.invert()
          )
        }),
        (ec.prototype.isIntersectionBox = function (t) {
          return (
            console.warn(
              'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().',
            ),
            this.intersectsBox(t)
          )
        }),
        (ec.prototype.isIntersectionPlane = function (t) {
          return (
            console.warn(
              'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().',
            ),
            this.intersectsPlane(t)
          )
        }),
        (ec.prototype.isIntersectionSphere = function (t) {
          return (
            console.warn(
              'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().',
            ),
            this.intersectsSphere(t)
          )
        }),
        (Bc.prototype.area = function () {
          return (
            console.warn(
              'THREE.Triangle: .area() has been renamed to .getArea().',
            ),
            this.getArea()
          )
        }),
        (Bc.prototype.barycoordFromPoint = function (t, e) {
          return (
            console.warn(
              'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().',
            ),
            this.getBarycoord(t, e)
          )
        }),
        (Bc.prototype.midpoint = function (t) {
          return (
            console.warn(
              'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().',
            ),
            this.getMidpoint(t)
          )
        }),
        (Bc.prototypenormal = function (t) {
          return (
            console.warn(
              'THREE.Triangle: .normal() has been renamed to .getNormal().',
            ),
            this.getNormal(t)
          )
        }),
        (Bc.prototype.plane = function (t) {
          return (
            console.warn(
              'THREE.Triangle: .plane() has been renamed to .getPlane().',
            ),
            this.getPlane(t)
          )
        }),
        (Bc.barycoordFromPoint = function (t, e, n, i, r) {
          return (
            console.warn(
              'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().',
            ),
            Bc.getBarycoord(t, e, n, i, r)
          )
        }),
        (Bc.normal = function (t, e, n, i) {
          return (
            console.warn(
              'THREE.Triangle: .normal() has been renamed to .getNormal().',
            ),
            Bc.getNormal(t, e, n, i)
          )
        }),
        (tm.prototype.extractAllPoints = function (t) {
          return (
            console.warn(
              'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.',
            ),
            this.extractPoints(t)
          )
        }),
        (tm.prototype.extrude = function (t) {
          return (
            console.warn(
              'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.',
            ),
            new Am(this, t)
          )
        }),
        (tm.prototype.makeGeometry = function (t) {
          return (
            console.warn(
              'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.',
            ),
            new Lm(this, t)
          )
        }),
        (dl.prototype.fromAttribute = function (t, e, n) {
          return (
            console.warn(
              'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().',
            ),
            this.fromBufferAttribute(t, e, n)
          )
        }),
        (dl.prototype.distanceToManhattan = function (t) {
          return (
            console.warn(
              'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().',
            ),
            this.manhattanDistanceTo(t)
          )
        }),
        (dl.prototype.lengthManhattan = function () {
          return (
            console.warn(
              'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().',
            ),
            this.manhattanLength()
          )
        }),
        (Tl.prototype.setEulerFromRotationMatrix = function () {
          console.error(
            'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.',
          )
        }),
        (Tl.prototype.setEulerFromQuaternion = function () {
          console.error(
            'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.',
          )
        }),
        (Tl.prototype.getPositionFromMatrix = function (t) {
          return (
            console.warn(
              'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().',
            ),
            this.setFromMatrixPosition(t)
          )
        }),
        (Tl.prototype.getScaleFromMatrix = function (t) {
          return (
            console.warn(
              'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().',
            ),
            this.setFromMatrixScale(t)
          )
        }),
        (Tl.prototype.getColumnFromMatrix = function (t, e) {
          return (
            console.warn(
              'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().',
            ),
            this.setFromMatrixColumn(e, t)
          )
        }),
        (Tl.prototype.applyProjection = function (t) {
          return (
            console.warn(
              'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.',
            ),
            this.applyMatrix4(t)
          )
        }),
        (Tl.prototype.fromAttribute = function (t, e, n) {
          return (
            console.warn(
              'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().',
            ),
            this.fromBufferAttribute(t, e, n)
          )
        }),
        (Tl.prototype.distanceToManhattan = function (t) {
          return (
            console.warn(
              'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().',
            ),
            this.manhattanDistanceTo(t)
          )
        }),
        (Tl.prototype.lengthManhattan = function () {
          return (
            console.warn(
              'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().',
            ),
            this.manhattanLength()
          )
        }),
        (bl.prototype.fromAttribute = function (t, e, n) {
          return (
            console.warn(
              'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().',
            ),
            this.fromBufferAttribute(t, e, n)
          )
        }),
        (bl.prototype.lengthManhattan = function () {
          return (
            console.warn(
              'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().',
            ),
            this.manhattanLength()
          )
        }),
        (Dc.prototype.getChildByName = function (t) {
          return (
            console.warn(
              'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().',
            ),
            this.getObjectByName(t)
          )
        }),
        (Dc.prototype.renderDepth = function () {
          console.warn(
            'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.',
          )
        }),
        (Dc.prototype.translate = function (t, e) {
          return (
            console.warn(
              'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.',
            ),
            this.translateOnAxis(e, t)
          )
        }),
        (Dc.prototype.getWorldRotation = function () {
          console.error(
            'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.',
          )
        }),
        (Dc.prototype.applyMatrix = function (t) {
          return (
            console.warn(
              'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().',
            ),
            this.applyMatrix4(t)
          )
        }),
        Object.defineProperties(Dc.prototype, {
          eulerOrder: {
            get: function () {
              return (
                console.warn(
                  'THREE.Object3D: .eulerOrder is now .rotation.order.',
                ),
                this.rotation.order
              )
            },
            set: function (t) {
              console.warn(
                'THREE.Object3D: .eulerOrder is now .rotation.order.',
              ),
                (this.rotation.order = t)
            },
          },
          useQuaternion: {
            get: function () {
              console.warn(
                'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.',
              )
            },
            set: function () {
              console.warn(
                'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.',
              )
            },
          },
        }),
        (Eu.prototype.setDrawMode = function () {
          console.error(
            'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.',
          )
        }),
        Object.defineProperties(Eu.prototype, {
          drawMode: {
            get: function () {
              return (
                console.error(
                  'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.',
                ),
                0
              )
            },
            set: function () {
              console.error(
                'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.',
              )
            },
          },
        }),
        (rf.prototype.initBones = function () {
          console.error('THREE.SkinnedMesh: initBones() has been removed.')
        }),
        (Iu.prototype.setLens = function (t, e) {
          console.warn(
            'THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.',
          ),
            void 0 !== e && (this.filmGauge = e),
            this.setFocalLength(t)
        }),
        Object.defineProperties(rg.prototype, {
          onlyShadow: {
            set: function () {
              console.warn('THREE.Light: .onlyShadow has been removed.')
            },
          },
          shadowCameraFov: {
            set: function (t) {
              console.warn(
                'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.',
              ),
                (this.shadow.camera.fov = t)
            },
          },
          shadowCameraLeft: {
            set: function (t) {
              console.warn(
                'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.',
              ),
                (this.shadow.camera.left = t)
            },
          },
          shadowCameraRight: {
            set: function (t) {
              console.warn(
                'THREE.Light: .shadowCameraRight is now .shadow.camera.right.',
              ),
                (this.shadow.camera.right = t)
            },
          },
          shadowCameraTop: {
            set: function (t) {
              console.warn(
                'THREE.Light: .shadowCameraTop is now .shadow.camera.top.',
              ),
                (this.shadow.camera.top = t)
            },
          },
          shadowCameraBottom: {
            set: function (t) {
              console.warn(
                'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.',
              ),
                (this.shadow.camera.bottom = t)
            },
          },
          shadowCameraNear: {
            set: function (t) {
              console.warn(
                'THREE.Light: .shadowCameraNear is now .shadow.camera.near.',
              ),
                (this.shadow.camera.near = t)
            },
          },
          shadowCameraFar: {
            set: function (t) {
              console.warn(
                'THREE.Light: .shadowCameraFar is now .shadow.camera.far.',
              ),
                (this.shadow.camera.far = t)
            },
          },
          shadowCameraVisible: {
            set: function () {
              console.warn(
                'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.',
              )
            },
          },
          shadowBias: {
            set: function (t) {
              console.warn('THREE.Light: .shadowBias is now .shadow.bias.'),
                (this.shadow.bias = t)
            },
          },
          shadowDarkness: {
            set: function () {
              console.warn('THREE.Light: .shadowDarkness has been removed.')
            },
          },
          shadowMapWidth: {
            set: function (t) {
              console.warn(
                'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.',
              ),
                (this.shadow.mapSize.width = t)
            },
          },
          shadowMapHeight: {
            set: function (t) {
              console.warn(
                'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.',
              ),
                (this.shadow.mapSize.height = t)
            },
          },
        }),
        Object.defineProperties(Kc.prototype, {
          length: {
            get: function () {
              return (
                console.warn(
                  'THREE.BufferAttribute: .length has been deprecated. Use .count instead.',
                ),
                this.array.length
              )
            },
          },
          dynamic: {
            get: function () {
              return (
                console.warn(
                  'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.',
                ),
                this.usage === Za
              )
            },
            set: function () {
              console.warn(
                'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.',
              ),
                this.setUsage(Za)
            },
          },
        }),
        (Kc.prototype.setDynamic = function (t) {
          return (
            console.warn(
              'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.',
            ),
            this.setUsage(!0 === t ? Za : Ja),
            this
          )
        }),
        (Kc.prototype.copyIndicesArray = function () {
          console.error(
            'THREE.BufferAttribute: .copyIndicesArray() has been removed.',
          )
        }),
        (Kc.prototype.setArray = function () {
          console.error(
            'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers',
          )
        }),
        (lu.prototype.addIndex = function (t) {
          console.warn(
            'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().',
          ),
            this.setIndex(t)
        }),
        (lu.prototype.addAttribute = function (t, e) {
          return (
            console.warn(
              'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().',
            ),
            (e && e.isBufferAttribute) || (e && e.isInterleavedBufferAttribute)
              ? 'index' === t
                ? (console.warn(
                    'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.',
                  ),
                  this.setIndex(e),
                  this)
                : this.setAttribute(t, e)
              : (console.warn(
                  'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).',
                ),
                this.setAttribute(t, new Kc(arguments[1], arguments[2])))
          )
        }),
        (lu.prototype.addDrawCall = function (t, e, n) {
          void 0 !== n &&
            console.warn(
              'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.',
            ),
            console.warn(
              'THREE.BufferGeometry: .addDrawCall() is now .addGroup().',
            ),
            this.addGroup(t, e)
        }),
        (lu.prototype.clearDrawCalls = function () {
          console.warn(
            'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().',
          ),
            this.clearGroups()
        }),
        (lu.prototype.computeOffsets = function () {
          console.warn(
            'THREE.BufferGeometry: .computeOffsets() has been removed.',
          )
        }),
        (lu.prototype.removeAttribute = function (t) {
          return (
            console.warn(
              'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().',
            ),
            this.deleteAttribute(t)
          )
        }),
        (lu.prototype.applyMatrix = function (t) {
          return (
            console.warn(
              'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().',
            ),
            this.applyMatrix4(t)
          )
        }),
        Object.defineProperties(lu.prototype, {
          drawcalls: {
            get: function () {
              return (
                console.error(
                  'THREE.BufferGeometry: .drawcalls has been renamed to .groups.',
                ),
                this.groups
              )
            },
          },
          offsets: {
            get: function () {
              return (
                console.warn(
                  'THREE.BufferGeometry: .offsets has been renamed to .groups.',
                ),
                this.groups
              )
            },
          },
        }),
        (Ip.prototype.setDynamic = function (t) {
          return (
            console.warn(
              'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.',
            ),
            this.setUsage(!0 === t ? Za : Ja),
            this
          )
        }),
        (Ip.prototype.setArray = function () {
          console.error(
            'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers',
          )
        }),
        (Am.prototype.getArrays = function () {
          console.error('THREE.ExtrudeGeometry: .getArrays() has been removed.')
        }),
        (Am.prototype.addShapeList = function () {
          console.error(
            'THREE.ExtrudeGeometry: .addShapeList() has been removed.',
          )
        }),
        (Am.prototype.addShape = function () {
          console.error('THREE.ExtrudeGeometry: .addShape() has been removed.')
        }),
        (Fp.prototype.dispose = function () {
          console.error('THREE.Scene: .dispose() has been removed.')
        }),
        (kg.prototype.onUpdate = function () {
          return (
            console.warn(
              'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.',
            ),
            this
          )
        }),
        Object.defineProperties(Uc.prototype, {
          wrapAround: {
            get: function () {
              console.warn('THREE.Material: .wrapAround has been removed.')
            },
            set: function () {
              console.warn('THREE.Material: .wrapAround has been removed.')
            },
          },
          overdraw: {
            get: function () {
              console.warn('THREE.Material: .overdraw has been removed.')
            },
            set: function () {
              console.warn('THREE.Material: .overdraw has been removed.')
            },
          },
          wrapRGB: {
            get: function () {
              return (
                console.warn('THREE.Material: .wrapRGB has been removed.'),
                new Xc()
              )
            },
          },
          shading: {
            get: function () {
              console.error(
                'THREE.' +
                  this.type +
                  ': .shading has been removed. Use the boolean .flatShading instead.',
              )
            },
            set: function (t) {
              console.warn(
                'THREE.' +
                  this.type +
                  ': .shading has been removed. Use the boolean .flatShading instead.',
              ),
                (this.flatShading = 1 === t)
            },
          },
          stencilMask: {
            get: function () {
              return (
                console.warn(
                  'THREE.' +
                    this.type +
                    ': .stencilMask has been removed. Use .stencilFuncMask instead.',
                ),
                this.stencilFuncMask
              )
            },
            set: function (t) {
              console.warn(
                'THREE.' +
                  this.type +
                  ': .stencilMask has been removed. Use .stencilFuncMask instead.',
              ),
                (this.stencilFuncMask = t)
            },
          },
          vertexTangents: {
            get: function () {
              console.warn(
                'THREE.' + this.type + ': .vertexTangents has been removed.',
              )
            },
            set: function () {
              console.warn(
                'THREE.' + this.type + ': .vertexTangents has been removed.',
              )
            },
          },
        }),
        Object.defineProperties(Pu.prototype, {
          derivatives: {
            get: function () {
              return (
                console.warn(
                  'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.',
                ),
                this.extensions.derivatives
              )
            },
            set: function (t) {
              console.warn(
                'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.',
              ),
                (this.extensions.derivatives = t)
            },
          },
        }),
        (Lp.prototype.clearTarget = function (t, e, n, i) {
          console.warn(
            'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.',
          ),
            this.setRenderTarget(t),
            this.clear(e, n, i)
        }),
        (Lp.prototype.animate = function (t) {
          console.warn(
            'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().',
          ),
            this.setAnimationLoop(t)
        }),
        (Lp.prototype.getCurrentRenderTarget = function () {
          return (
            console.warn(
              'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().',
            ),
            this.getRenderTarget()
          )
        }),
        (Lp.prototype.getMaxAnisotropy = function () {
          return (
            console.warn(
              'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().',
            ),
            this.capabilities.getMaxAnisotropy()
          )
        }),
        (Lp.prototype.getPrecision = function () {
          return (
            console.warn(
              'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.',
            ),
            this.capabilities.precision
          )
        }),
        (Lp.prototype.resetGLState = function () {
          return (
            console.warn(
              'THREE.WebGLRenderer: .resetGLState() is now .state.reset().',
            ),
            this.state.reset()
          )
        }),
        (Lp.prototype.supportsFloatTextures = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).",
            ),
            this.extensions.get('OES_texture_float')
          )
        }),
        (Lp.prototype.supportsHalfFloatTextures = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).",
            ),
            this.extensions.get('OES_texture_half_float')
          )
        }),
        (Lp.prototype.supportsStandardDerivatives = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).",
            ),
            this.extensions.get('OES_standard_derivatives')
          )
        }),
        (Lp.prototype.supportsCompressedTextureS3TC = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).",
            ),
            this.extensions.get('WEBGL_compressed_texture_s3tc')
          )
        }),
        (Lp.prototype.supportsCompressedTexturePVRTC = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).",
            ),
            this.extensions.get('WEBGL_compressed_texture_pvrtc')
          )
        }),
        (Lp.prototype.supportsBlendMinMax = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).",
            ),
            this.extensions.get('EXT_blend_minmax')
          )
        }),
        (Lp.prototype.supportsVertexTextures = function () {
          return (
            console.warn(
              'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.',
            ),
            this.capabilities.vertexTextures
          )
        }),
        (Lp.prototype.supportsInstancedArrays = function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).",
            ),
            this.extensions.get('ANGLE_instanced_arrays')
          )
        }),
        (Lp.prototype.enableScissorTest = function (t) {
          console.warn(
            'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().',
          ),
            this.setScissorTest(t)
        }),
        (Lp.prototype.initMaterial = function () {
          console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.')
        }),
        (Lp.prototype.addPrePlugin = function () {
          console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.')
        }),
        (Lp.prototype.addPostPlugin = function () {
          console.warn(
            'THREE.WebGLRenderer: .addPostPlugin() has been removed.',
          )
        }),
        (Lp.prototype.updateShadowMap = function () {
          console.warn(
            'THREE.WebGLRenderer: .updateShadowMap() has been removed.',
          )
        }),
        (Lp.prototype.setFaceCulling = function () {
          console.warn(
            'THREE.WebGLRenderer: .setFaceCulling() has been removed.',
          )
        }),
        (Lp.prototype.allocTextureUnit = function () {
          console.warn(
            'THREE.WebGLRenderer: .allocTextureUnit() has been removed.',
          )
        }),
        (Lp.prototype.setTexture = function () {
          console.warn('THREE.WebGLRenderer: .setTexture() has been removed.')
        }),
        (Lp.prototype.setTexture2D = function () {
          console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.')
        }),
        (Lp.prototype.setTextureCube = function () {
          console.warn(
            'THREE.WebGLRenderer: .setTextureCube() has been removed.',
          )
        }),
        (Lp.prototype.getActiveMipMapLevel = function () {
          return (
            console.warn(
              'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().',
            ),
            this.getActiveMipmapLevel()
          )
        }),
        Object.defineProperties(Lp.prototype, {
          shadowMapEnabled: {
            get: function () {
              return this.shadowMap.enabled
            },
            set: function (t) {
              console.warn(
                'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.',
              ),
                (this.shadowMap.enabled = t)
            },
          },
          shadowMapType: {
            get: function () {
              return this.shadowMap.type
            },
            set: function (t) {
              console.warn(
                'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.',
              ),
                (this.shadowMap.type = t)
            },
          },
          shadowMapCullFace: {
            get: function () {
              console.warn(
                'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.',
              )
            },
            set: function () {
              console.warn(
                'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.',
              )
            },
          },
          context: {
            get: function () {
              return (
                console.warn(
                  'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.',
                ),
                this.getContext()
              )
            },
          },
          vr: {
            get: function () {
              return (
                console.warn(
                  'THREE.WebGLRenderer: .vr has been renamed to .xr',
                ),
                this.xr
              )
            },
          },
          gammaInput: {
            get: function () {
              return (
                console.warn(
                  'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.',
                ),
                !1
              )
            },
            set: function () {
              console.warn(
                'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.',
              )
            },
          },
          gammaOutput: {
            get: function () {
              return (
                console.warn(
                  'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.',
                ),
                !1
              )
            },
            set: function (t) {
              console.warn(
                'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.',
              ),
                (this.outputEncoding = !0 === t ? ja : Wa)
            },
          },
          toneMappingWhitePoint: {
            get: function () {
              return (
                console.warn(
                  'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.',
                ),
                1
              )
            },
            set: function () {
              console.warn(
                'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.',
              )
            },
          },
        }),
        Object.defineProperties(xp.prototype, {
          cullFace: {
            get: function () {
              console.warn(
                'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.',
              )
            },
            set: function () {
              console.warn(
                'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.',
              )
            },
          },
          renderReverseSided: {
            get: function () {
              console.warn(
                'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.',
              )
            },
            set: function () {
              console.warn(
                'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.',
              )
            },
          },
          renderSingleSided: {
            get: function () {
              console.warn(
                'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.',
              )
            },
            set: function () {
              console.warn(
                'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.',
              )
            },
          },
        }),
        Object.defineProperties(wl.prototype, {
          wrapS: {
            get: function () {
              return (
                console.warn(
                  'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.',
                ),
                this.texture.wrapS
              )
            },
            set: function (t) {
              console.warn(
                'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.',
              ),
                (this.texture.wrapS = t)
            },
          },
          wrapT: {
            get: function () {
              return (
                console.warn(
                  'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.',
                ),
                this.texture.wrapT
              )
            },
            set: function (t) {
              console.warn(
                'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.',
              ),
                (this.texture.wrapT = t)
            },
          },
          magFilter: {
            get: function () {
              return (
                console.warn(
                  'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.',
                ),
                this.texture.magFilter
              )
            },
            set: function (t) {
              console.warn(
                'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.',
              ),
                (this.texture.magFilter = t)
            },
          },
          minFilter: {
            get: function () {
              return (
                console.warn(
                  'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.',
                ),
                this.texture.minFilter
              )
            },
            set: function (t) {
              console.warn(
                'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.',
              ),
                (this.texture.minFilter = t)
            },
          },
          anisotropy: {
            get: function () {
              return (
                console.warn(
                  'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.',
                ),
                this.texture.anisotropy
              )
            },
            set: function (t) {
              console.warn(
                'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.',
              ),
                (this.texture.anisotropy = t)
            },
          },
          offset: {
            get: function () {
              return (
                console.warn(
                  'THREE.WebGLRenderTarget: .offset is now .texture.offset.',
                ),
                this.texture.offset
              )
            },
            set: function (t) {
              console.warn(
                'THREE.WebGLRenderTarget: .offset is now .texture.offset.',
              ),
                (this.texture.offset = t)
            },
          },
          repeat: {
            get: function () {
              return (
                console.warn(
                  'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.',
                ),
                this.texture.repeat
              )
            },
            set: function (t) {
              console.warn(
                'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.',
              ),
                (this.texture.repeat = t)
            },
          },
          format: {
            get: function () {
              return (
                console.warn(
                  'THREE.WebGLRenderTarget: .format is now .texture.format.',
                ),
                this.texture.format
              )
            },
            set: function (t) {
              console.warn(
                'THREE.WebGLRenderTarget: .format is now .texture.format.',
              ),
                (this.texture.format = t)
            },
          },
          type: {
            get: function () {
              return (
                console.warn(
                  'THREE.WebGLRenderTarget: .type is now .texture.type.',
                ),
                this.texture.type
              )
            },
            set: function (t) {
              console.warn(
                'THREE.WebGLRenderTarget: .type is now .texture.type.',
              ),
                (this.texture.type = t)
            },
          },
          generateMipmaps: {
            get: function () {
              return (
                console.warn(
                  'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.',
                ),
                this.texture.generateMipmaps
              )
            },
            set: function (t) {
              console.warn(
                'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.',
              ),
                (this.texture.generateMipmaps = t)
            },
          },
        }),
        (class extends Dc {
          constructor(t) {
            super(),
              (this.type = 'Audio'),
              (this.listener = t),
              (this.context = t.context),
              (this.gain = this.context.createGain()),
              this.gain.connect(t.getInput()),
              (this.autoplay = !1),
              (this.buffer = null),
              (this.detune = 0),
              (this.loop = !1),
              (this.loopStart = 0),
              (this.loopEnd = 0),
              (this.offset = 0),
              (this.duration = void 0),
              (this.playbackRate = 1),
              (this.isPlaying = !1),
              (this.hasPlaybackControl = !0),
              (this.source = null),
              (this.sourceType = 'empty'),
              (this._startedAt = 0),
              (this._progress = 0),
              (this._connected = !1),
              (this.filters = [])
          }
          getOutput() {
            return this.gain
          }
          setNodeSource(t) {
            return (
              (this.hasPlaybackControl = !1),
              (this.sourceType = 'audioNode'),
              (this.source = t),
              this.connect(),
              this
            )
          }
          setMediaElementSource(t) {
            return (
              (this.hasPlaybackControl = !1),
              (this.sourceType = 'mediaNode'),
              (this.source = this.context.createMediaElementSource(t)),
              this.connect(),
              this
            )
          }
          setMediaStreamSource(t) {
            return (
              (this.hasPlaybackControl = !1),
              (this.sourceType = 'mediaStreamNode'),
              (this.source = this.context.createMediaStreamSource(t)),
              this.connect(),
              this
            )
          }
          setBuffer(t) {
            return (
              (this.buffer = t),
              (this.sourceType = 'buffer'),
              this.autoplay && this.play(),
              this
            )
          }
          play(t = 0) {
            if (!0 === this.isPlaying)
              return void console.warn('THREE.Audio: Audio is already playing.')
            if (!1 === this.hasPlaybackControl)
              return void console.warn(
                'THREE.Audio: this Audio has no playback control.',
              )
            this._startedAt = this.context.currentTime + t
            const e = this.context.createBufferSource()
            return (
              (e.buffer = this.buffer),
              (e.loop = this.loop),
              (e.loopStart = this.loopStart),
              (e.loopEnd = this.loopEnd),
              (e.onended = this.onEnded.bind(this)),
              e.start(
                this._startedAt,
                this._progress + this.offset,
                this.duration,
              ),
              (this.isPlaying = !0),
              (this.source = e),
              this.setDetune(this.detune),
              this.setPlaybackRate(this.playbackRate),
              this.connect()
            )
          }
          pause() {
            if (!1 !== this.hasPlaybackControl)
              return (
                !0 === this.isPlaying &&
                  ((this._progress +=
                    Math.max(this.context.currentTime - this._startedAt, 0) *
                    this.playbackRate),
                  !0 === this.loop &&
                    (this._progress =
                      this._progress % (this.duration || this.buffer.duration)),
                  this.source.stop(),
                  (this.source.onended = null),
                  (this.isPlaying = !1)),
                this
              )
            console.warn('THREE.Audio: this Audio has no playback control.')
          }
          stop() {
            if (!1 !== this.hasPlaybackControl)
              return (
                (this._progress = 0),
                this.source.stop(),
                (this.source.onended = null),
                (this.isPlaying = !1),
                this
              )
            console.warn('THREE.Audio: this Audio has no playback control.')
          }
          connect() {
            if (this.filters.length > 0) {
              this.source.connect(this.filters[0])
              for (let t = 1, e = this.filters.length; t < e; t++)
                this.filters[t - 1].connect(this.filters[t])
              this.filters[this.filters.length - 1].connect(this.getOutput())
            } else this.source.connect(this.getOutput())
            return (this._connected = !0), this
          }
          disconnect() {
            if (this.filters.length > 0) {
              this.source.disconnect(this.filters[0])
              for (let t = 1, e = this.filters.length; t < e; t++)
                this.filters[t - 1].disconnect(this.filters[t])
              this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else this.source.disconnect(this.getOutput())
            return (this._connected = !1), this
          }
          getFilters() {
            return this.filters
          }
          setFilters(t) {
            return (
              t || (t = []),
              !0 === this._connected
                ? (this.disconnect(),
                  (this.filters = t.slice()),
                  this.connect())
                : (this.filters = t.slice()),
              this
            )
          }
          setDetune(t) {
            if (((this.detune = t), void 0 !== this.source.detune))
              return (
                !0 === this.isPlaying &&
                  this.source.detune.setTargetAtTime(
                    this.detune,
                    this.context.currentTime,
                    0.01,
                  ),
                this
              )
          }
          getDetune() {
            return this.detune
          }
          getFilter() {
            return this.getFilters()[0]
          }
          setFilter(t) {
            return this.setFilters(t ? [t] : [])
          }
          setPlaybackRate(t) {
            if (!1 !== this.hasPlaybackControl)
              return (
                (this.playbackRate = t),
                !0 === this.isPlaying &&
                  this.source.playbackRate.setTargetAtTime(
                    this.playbackRate,
                    this.context.currentTime,
                    0.01,
                  ),
                this
              )
            console.warn('THREE.Audio: this Audio has no playback control.')
          }
          getPlaybackRate() {
            return this.playbackRate
          }
          onEnded() {
            this.isPlaying = !1
          }
          getLoop() {
            return !1 === this.hasPlaybackControl
              ? (console.warn(
                  'THREE.Audio: this Audio has no playback control.',
                ),
                !1)
              : this.loop
          }
          setLoop(t) {
            if (!1 !== this.hasPlaybackControl)
              return (
                (this.loop = t),
                !0 === this.isPlaying && (this.source.loop = this.loop),
                this
              )
            console.warn('THREE.Audio: this Audio has no playback control.')
          }
          setLoopStart(t) {
            return (this.loopStart = t), this
          }
          setLoopEnd(t) {
            return (this.loopEnd = t), this
          }
          getVolume() {
            return this.gain.gain.value
          }
          setVolume(t) {
            return (
              this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
              this
            )
          }
        }.prototype.load = function (t) {
          console.warn(
            'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.',
          )
          const e = this
          return (
            new Sg().load(t, function (t) {
              e.setBuffer(t)
            }),
            this
          )
        }),
        (Nu.prototype.updateCubeMap = function (t, e) {
          return (
            console.warn(
              'THREE.CubeCamera: .updateCubeMap() is now .update().',
            ),
            this.update(t, e)
          )
        }),
        (Nu.prototype.clear = function (t, e, n, i) {
          return (
            console.warn(
              'THREE.CubeCamera: .clear() is now .renderTarget.clear().',
            ),
            this.renderTarget.clear(t, e, n, i)
          )
        }),
        (vl.crossOrigin = void 0),
        (vl.loadTexture = function (t, e, n, i) {
          console.warn(
            'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.',
          )
          const r = new ig()
          r.setCrossOrigin(this.crossOrigin)
          const s = r.load(t, n, void 0, i)
          return e && (s.mapping = e), s
        }),
        (vl.loadTextureCube = function (t, e, n, i) {
          console.warn(
            'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.',
          )
          const r = new ng()
          r.setCrossOrigin(this.crossOrigin)
          const s = r.load(t, n, void 0, i)
          return e && (s.mapping = e), s
        }),
        (vl.loadCompressedTexture = function () {
          console.error(
            'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.',
          )
        }),
        (vl.loadCompressedTextureCube = function () {
          console.error(
            'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.',
          )
        }),
        'undefined' != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent('register', { detail: { revision: '133' } }),
          ),
        'undefined' != typeof window &&
          (window.__THREE__
            ? console.warn(
                'WARNING: Multiple instances of Three.js being imported.',
              )
            : (window.__THREE__ = '133'))
      class Jg extends Qm {
        constructor(t) {
          super(t),
            (this.dracoLoader = null),
            (this.ktx2Loader = null),
            (this.meshoptDecoder = null),
            (this.pluginCallbacks = []),
            this.register(function (t) {
              return new tv(t)
            }),
            this.register(function (t) {
              return new sv(t)
            }),
            this.register(function (t) {
              return new ov(t)
            }),
            this.register(function (t) {
              return new ev(t)
            }),
            this.register(function (t) {
              return new nv(t)
            }),
            this.register(function (t) {
              return new iv(t)
            }),
            this.register(function (t) {
              return new rv(t)
            }),
            this.register(function (t) {
              return new Qg(t)
            }),
            this.register(function (t) {
              return new av(t)
            })
        }
        load(t, e, n, i) {
          const r = this
          let s
          ;(s =
            '' !== this.resourcePath
              ? this.resourcePath
              : '' !== this.path
              ? this.path
              : bg.extractUrlBase(t)),
            this.manager.itemStart(t)
          const o = function (e) {
              i ? i(e) : console.error(e),
                r.manager.itemError(t),
                r.manager.itemEnd(t)
            },
            a = new tg(this.manager)
          a.setPath(this.path),
            a.setResponseType('arraybuffer'),
            a.setRequestHeader(this.requestHeader),
            a.setWithCredentials(this.withCredentials),
            a.load(
              t,
              function (n) {
                try {
                  r.parse(
                    n,
                    s,
                    function (n) {
                      e(n), r.manager.itemEnd(t)
                    },
                    o,
                  )
                } catch (t) {
                  o(t)
                }
              },
              n,
              o,
            )
        }
        setDRACOLoader(t) {
          return (this.dracoLoader = t), this
        }
        setDDSLoader() {
          throw new Error(
            'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".',
          )
        }
        setKTX2Loader(t) {
          return (this.ktx2Loader = t), this
        }
        setMeshoptDecoder(t) {
          return (this.meshoptDecoder = t), this
        }
        register(t) {
          return (
            -1 === this.pluginCallbacks.indexOf(t) &&
              this.pluginCallbacks.push(t),
            this
          )
        }
        unregister(t) {
          return (
            -1 !== this.pluginCallbacks.indexOf(t) &&
              this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1),
            this
          )
        }
        parse(t, e, n, i) {
          let r
          const s = {},
            o = {}
          if ('string' == typeof t) r = t
          else if (bg.decodeText(new Uint8Array(t, 0, 4)) === lv) {
            try {
              s[Kg.KHR_BINARY_GLTF] = new cv(t)
            } catch (t) {
              return void (i && i(t))
            }
            r = s[Kg.KHR_BINARY_GLTF].content
          } else r = bg.decodeText(new Uint8Array(t))
          const a = JSON.parse(r)
          if (void 0 === a.asset || a.asset.version[0] < 2)
            return void (
              i &&
              i(
                new Error(
                  'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.',
                ),
              )
            )
          const l = new Pv(a, {
            path: e || this.resourcePath || '',
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder,
          })
          l.fileLoader.setRequestHeader(this.requestHeader)
          for (let t = 0; t < this.pluginCallbacks.length; t++) {
            const e = this.pluginCallbacks[t](l)
            ;(o[e.name] = e), (s[e.name] = !0)
          }
          if (a.extensionsUsed)
            for (let t = 0; t < a.extensionsUsed.length; ++t) {
              const e = a.extensionsUsed[t],
                n = a.extensionsRequired || []
              switch (e) {
                case Kg.KHR_MATERIALS_UNLIT:
                  s[e] = new $g()
                  break
                case Kg.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                  s[e] = new pv()
                  break
                case Kg.KHR_DRACO_MESH_COMPRESSION:
                  s[e] = new uv(a, this.dracoLoader)
                  break
                case Kg.KHR_TEXTURE_TRANSFORM:
                  s[e] = new hv()
                  break
                case Kg.KHR_MESH_QUANTIZATION:
                  s[e] = new fv()
                  break
                default:
                  n.indexOf(e) >= 0 &&
                    void 0 === o[e] &&
                    console.warn(
                      'THREE.GLTFLoader: Unknown extension "' + e + '".',
                    )
              }
            }
          l.setExtensions(s), l.setPlugins(o), l.parse(n, i)
        }
      }
      function Zg() {
        let t = {}
        return {
          get: function (e) {
            return t[e]
          },
          add: function (e, n) {
            t[e] = n
          },
          remove: function (e) {
            delete t[e]
          },
          removeAll: function () {
            t = {}
          },
        }
      }
      const Kg = {
        KHR_BINARY_GLTF: 'KHR_binary_glTF',
        KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
        KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
        KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
        KHR_MATERIALS_IOR: 'KHR_materials_ior',
        KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
          'KHR_materials_pbrSpecularGlossiness',
        KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
        KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
        KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
        KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
        KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
        KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
        KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
        EXT_TEXTURE_WEBP: 'EXT_texture_webp',
        EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',
      }
      class Qg {
        constructor(t) {
          ;(this.parser = t),
            (this.name = Kg.KHR_LIGHTS_PUNCTUAL),
            (this.cache = { refs: {}, uses: {} })
        }
        _markDefs() {
          const t = this.parser,
            e = this.parser.json.nodes || []
          for (let n = 0, i = e.length; n < i; n++) {
            const i = e[n]
            i.extensions &&
              i.extensions[this.name] &&
              void 0 !== i.extensions[this.name].light &&
              t._addNodeRef(this.cache, i.extensions[this.name].light)
          }
        }
        _loadLight(t) {
          const e = this.parser,
            n = 'light:' + t
          let i = e.cache.get(n)
          if (i) return i
          const r = e.json,
            s = (((r.extensions && r.extensions[this.name]) || {}).lights ||
              [])[t]
          let o
          const a = new Xc(16777215)
          void 0 !== s.color && a.fromArray(s.color)
          const l = void 0 !== s.range ? s.range : 0
          switch (s.type) {
            case 'directional':
              ;(o = new vg(a)), o.target.position.set(0, 0, -1), o.add(o.target)
              break
            case 'point':
              ;(o = new mg(a)), (o.distance = l)
              break
            case 'spot':
              ;(o = new ug(a)),
                (o.distance = l),
                (s.spot = s.spot || {}),
                (s.spot.innerConeAngle =
                  void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0),
                (s.spot.outerConeAngle =
                  void 0 !== s.spot.outerConeAngle
                    ? s.spot.outerConeAngle
                    : Math.PI / 4),
                (o.angle = s.spot.outerConeAngle),
                (o.penumbra =
                  1 - s.spot.innerConeAngle / s.spot.outerConeAngle),
                o.target.position.set(0, 0, -1),
                o.add(o.target)
              break
            default:
              throw new Error(
                'THREE.GLTFLoader: Unexpected light type: ' + s.type,
              )
          }
          return (
            o.position.set(0, 0, 0),
            (o.decay = 2),
            void 0 !== s.intensity && (o.intensity = s.intensity),
            (o.name = e.createUniqueName(s.name || 'light_' + t)),
            (i = Promise.resolve(o)),
            e.cache.add(n, i),
            i
          )
        }
        createNodeAttachment(t) {
          const e = this,
            n = this.parser,
            i = n.json.nodes[t],
            r = ((i.extensions && i.extensions[this.name]) || {}).light
          return void 0 === r
            ? null
            : this._loadLight(r).then(function (t) {
                return n._getNodeRef(e.cache, r, t)
              })
        }
      }
      class $g {
        constructor() {
          this.name = Kg.KHR_MATERIALS_UNLIT
        }
        getMaterialType() {
          return Yc
        }
        extendParams(t, e, n) {
          const i = []
          ;(t.color = new Xc(1, 1, 1)), (t.opacity = 1)
          const r = e.pbrMetallicRoughness
          if (r) {
            if (Array.isArray(r.baseColorFactor)) {
              const e = r.baseColorFactor
              t.color.fromArray(e), (t.opacity = e[3])
            }
            void 0 !== r.baseColorTexture &&
              i.push(n.assignTexture(t, 'map', r.baseColorTexture))
          }
          return Promise.all(i)
        }
      }
      class tv {
        constructor(t) {
          ;(this.parser = t), (this.name = Kg.KHR_MATERIALS_CLEARCOAT)
        }
        getMaterialType(t) {
          const e = this.parser.json.materials[t]
          return e.extensions && e.extensions[this.name] ? Fm : null
        }
        extendMaterialParams(t, e) {
          const n = this.parser,
            i = n.json.materials[t]
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve()
          const r = [],
            s = i.extensions[this.name]
          if (
            (void 0 !== s.clearcoatFactor && (e.clearcoat = s.clearcoatFactor),
            void 0 !== s.clearcoatTexture &&
              r.push(n.assignTexture(e, 'clearcoatMap', s.clearcoatTexture)),
            void 0 !== s.clearcoatRoughnessFactor &&
              (e.clearcoatRoughness = s.clearcoatRoughnessFactor),
            void 0 !== s.clearcoatRoughnessTexture &&
              r.push(
                n.assignTexture(
                  e,
                  'clearcoatRoughnessMap',
                  s.clearcoatRoughnessTexture,
                ),
              ),
            void 0 !== s.clearcoatNormalTexture &&
              (r.push(
                n.assignTexture(
                  e,
                  'clearcoatNormalMap',
                  s.clearcoatNormalTexture,
                ),
              ),
              void 0 !== s.clearcoatNormalTexture.scale))
          ) {
            const t = s.clearcoatNormalTexture.scale
            e.clearcoatNormalScale = new dl(t, t)
          }
          return Promise.all(r)
        }
      }
      class ev {
        constructor(t) {
          ;(this.parser = t), (this.name = Kg.KHR_MATERIALS_TRANSMISSION)
        }
        getMaterialType(t) {
          const e = this.parser.json.materials[t]
          return e.extensions && e.extensions[this.name] ? Fm : null
        }
        extendMaterialParams(t, e) {
          const n = this.parser,
            i = n.json.materials[t]
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve()
          const r = [],
            s = i.extensions[this.name]
          return (
            void 0 !== s.transmissionFactor &&
              (e.transmission = s.transmissionFactor),
            void 0 !== s.transmissionTexture &&
              r.push(
                n.assignTexture(e, 'transmissionMap', s.transmissionTexture),
              ),
            Promise.all(r)
          )
        }
      }
      class nv {
        constructor(t) {
          ;(this.parser = t), (this.name = Kg.KHR_MATERIALS_VOLUME)
        }
        getMaterialType(t) {
          const e = this.parser.json.materials[t]
          return e.extensions && e.extensions[this.name] ? Fm : null
        }
        extendMaterialParams(t, e) {
          const n = this.parser,
            i = n.json.materials[t]
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve()
          const r = [],
            s = i.extensions[this.name]
          ;(e.thickness = void 0 !== s.thicknessFactor ? s.thicknessFactor : 0),
            void 0 !== s.thicknessTexture &&
              r.push(n.assignTexture(e, 'thicknessMap', s.thicknessTexture)),
            (e.attenuationDistance = s.attenuationDistance || 0)
          const o = s.attenuationColor || [1, 1, 1]
          return (e.attenuationTint = new Xc(o[0], o[1], o[2])), Promise.all(r)
        }
      }
      class iv {
        constructor(t) {
          ;(this.parser = t), (this.name = Kg.KHR_MATERIALS_IOR)
        }
        getMaterialType(t) {
          const e = this.parser.json.materials[t]
          return e.extensions && e.extensions[this.name] ? Fm : null
        }
        extendMaterialParams(t, e) {
          const n = this.parser.json.materials[t]
          if (!n.extensions || !n.extensions[this.name])
            return Promise.resolve()
          const i = n.extensions[this.name]
          return (e.ior = void 0 !== i.ior ? i.ior : 1.5), Promise.resolve()
        }
      }
      class rv {
        constructor(t) {
          ;(this.parser = t), (this.name = Kg.KHR_MATERIALS_SPECULAR)
        }
        getMaterialType(t) {
          const e = this.parser.json.materials[t]
          return e.extensions && e.extensions[this.name] ? Fm : null
        }
        extendMaterialParams(t, e) {
          const n = this.parser,
            i = n.json.materials[t]
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve()
          const r = [],
            s = i.extensions[this.name]
          ;(e.specularIntensity =
            void 0 !== s.specularFactor ? s.specularFactor : 1),
            void 0 !== s.specularTexture &&
              r.push(
                n.assignTexture(e, 'specularIntensityMap', s.specularTexture),
              )
          const o = s.specularColorFactor || [1, 1, 1]
          return (
            (e.specularTint = new Xc(o[0], o[1], o[2])),
            void 0 !== s.specularColorTexture &&
              r.push(
                n
                  .assignTexture(e, 'specularTintMap', s.specularColorTexture)
                  .then(function (t) {
                    t.encoding = ja
                  }),
              ),
            Promise.all(r)
          )
        }
      }
      class sv {
        constructor(t) {
          ;(this.parser = t), (this.name = Kg.KHR_TEXTURE_BASISU)
        }
        loadTexture(t) {
          const e = this.parser,
            n = e.json,
            i = n.textures[t]
          if (!i.extensions || !i.extensions[this.name]) return null
          const r = i.extensions[this.name],
            s = n.images[r.source],
            o = e.options.ktx2Loader
          if (!o) {
            if (
              n.extensionsRequired &&
              n.extensionsRequired.indexOf(this.name) >= 0
            )
              throw new Error(
                'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures',
              )
            return null
          }
          return e.loadTextureImage(t, s, o)
        }
      }
      class ov {
        constructor(t) {
          ;(this.parser = t),
            (this.name = Kg.EXT_TEXTURE_WEBP),
            (this.isSupported = null)
        }
        loadTexture(t) {
          const e = this.name,
            n = this.parser,
            i = n.json,
            r = i.textures[t]
          if (!r.extensions || !r.extensions[e]) return null
          const s = r.extensions[e],
            o = i.images[s.source]
          let a = n.textureLoader
          if (o.uri) {
            const t = n.options.manager.getHandler(o.uri)
            null !== t && (a = t)
          }
          return this.detectSupport().then(function (r) {
            if (r) return n.loadTextureImage(t, o, a)
            if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0)
              throw new Error(
                'THREE.GLTFLoader: WebP required by asset but unsupported.',
              )
            return n.loadTexture(t)
          })
        }
        detectSupport() {
          return (
            this.isSupported ||
              (this.isSupported = new Promise(function (t) {
                const e = new Image()
                ;(e.src =
                  'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'),
                  (e.onload = e.onerror = function () {
                    t(1 === e.height)
                  })
              })),
            this.isSupported
          )
        }
      }
      class av {
        constructor(t) {
          ;(this.name = Kg.EXT_MESHOPT_COMPRESSION), (this.parser = t)
        }
        loadBufferView(t) {
          const e = this.parser.json,
            n = e.bufferViews[t]
          if (n.extensions && n.extensions[this.name]) {
            const t = n.extensions[this.name],
              i = this.parser.getDependency('buffer', t.buffer),
              r = this.parser.options.meshoptDecoder
            if (!r || !r.supported) {
              if (
                e.extensionsRequired &&
                e.extensionsRequired.indexOf(this.name) >= 0
              )
                throw new Error(
                  'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files',
                )
              return null
            }
            return Promise.all([i, r.ready]).then(function (e) {
              const n = t.byteOffset || 0,
                i = t.byteLength || 0,
                s = t.count,
                o = t.byteStride,
                a = new ArrayBuffer(s * o),
                l = new Uint8Array(e[0], n, i)
              return (
                r.decodeGltfBuffer(
                  new Uint8Array(a),
                  s,
                  o,
                  l,
                  t.mode,
                  t.filter,
                ),
                a
              )
            })
          }
          return null
        }
      }
      const lv = 'glTF'
      class cv {
        constructor(t) {
          ;(this.name = Kg.KHR_BINARY_GLTF),
            (this.content = null),
            (this.body = null)
          const e = new DataView(t, 0, 12)
          if (
            ((this.header = {
              magic: bg.decodeText(new Uint8Array(t.slice(0, 4))),
              version: e.getUint32(4, !0),
              length: e.getUint32(8, !0),
            }),
            this.header.magic !== lv)
          )
            throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.')
          if (this.header.version < 2)
            throw new Error('THREE.GLTFLoader: Legacy binary file detected.')
          const n = this.header.length - 12,
            i = new DataView(t, 12)
          let r = 0
          for (; r < n; ) {
            const e = i.getUint32(r, !0)
            r += 4
            const n = i.getUint32(r, !0)
            if (((r += 4), 1313821514 === n)) {
              const n = new Uint8Array(t, 12 + r, e)
              this.content = bg.decodeText(n)
            } else if (5130562 === n) {
              const n = 12 + r
              this.body = t.slice(n, n + e)
            }
            r += e
          }
          if (null === this.content)
            throw new Error('THREE.GLTFLoader: JSON content not found.')
        }
      }
      class uv {
        constructor(t, e) {
          if (!e)
            throw new Error(
              'THREE.GLTFLoader: No DRACOLoader instance provided.',
            )
          ;(this.name = Kg.KHR_DRACO_MESH_COMPRESSION),
            (this.json = t),
            (this.dracoLoader = e),
            this.dracoLoader.preload()
        }
        decodePrimitive(t, e) {
          const n = this.json,
            i = this.dracoLoader,
            r = t.extensions[this.name].bufferView,
            s = t.extensions[this.name].attributes,
            o = {},
            a = {},
            l = {}
          for (const t in s) {
            const e = wv[t] || t.toLowerCase()
            o[e] = s[t]
          }
          for (const e in t.attributes) {
            const i = wv[e] || e.toLowerCase()
            if (void 0 !== s[e]) {
              const r = n.accessors[t.attributes[e]],
                s = _v[r.componentType]
              ;(l[i] = s), (a[i] = !0 === r.normalized)
            }
          }
          return e.getDependency('bufferView', r).then(function (t) {
            return new Promise(function (e) {
              i.decodeDracoFile(
                t,
                function (t) {
                  for (const e in t.attributes) {
                    const n = t.attributes[e],
                      i = a[e]
                    void 0 !== i && (n.normalized = i)
                  }
                  e(t)
                },
                o,
                l,
              )
            })
          })
        }
      }
      class hv {
        constructor() {
          this.name = Kg.KHR_TEXTURE_TRANSFORM
        }
        extendTexture(t, e) {
          return (
            void 0 !== e.texCoord &&
              console.warn(
                'THREE.GLTFLoader: Custom UV sets in "' +
                  this.name +
                  '" extension not yet supported.',
              ),
            (void 0 === e.offset &&
              void 0 === e.rotation &&
              void 0 === e.scale) ||
              ((t = t.clone()),
              void 0 !== e.offset && t.offset.fromArray(e.offset),
              void 0 !== e.rotation && (t.rotation = e.rotation),
              void 0 !== e.scale && t.repeat.fromArray(e.scale),
              (t.needsUpdate = !0)),
            t
          )
        }
      }
      class dv extends Pm {
        constructor(t) {
          super(), (this.isGLTFSpecularGlossinessMaterial = !0)
          const e = [
              '#ifdef USE_SPECULARMAP',
              '\tuniform sampler2D specularMap;',
              '#endif',
            ].join('\n'),
            n = [
              '#ifdef USE_GLOSSINESSMAP',
              '\tuniform sampler2D glossinessMap;',
              '#endif',
            ].join('\n'),
            i = [
              'vec3 specularFactor = specular;',
              '#ifdef USE_SPECULARMAP',
              '\tvec4 texelSpecular = texture2D( specularMap, vUv );',
              '\ttexelSpecular = sRGBToLinear( texelSpecular );',
              '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
              '\tspecularFactor *= texelSpecular.rgb;',
              '#endif',
            ].join('\n'),
            r = [
              'float glossinessFactor = glossiness;',
              '#ifdef USE_GLOSSINESSMAP',
              '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );',
              '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
              '\tglossinessFactor *= texelGlossiness.a;',
              '#endif',
            ].join('\n'),
            s = [
              'PhysicalMaterial material;',
              'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',
              'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',
              'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',
              'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',
              'material.roughness += geometryRoughness;',
              'material.roughness = min( material.roughness, 1.0 );',
              'material.specularColor = specularFactor;',
            ].join('\n'),
            o = {
              specular: { value: new Xc().setHex(16777215) },
              glossiness: { value: 1 },
              specularMap: { value: null },
              glossinessMap: { value: null },
            }
          ;(this._extraUniforms = o),
            (this.onBeforeCompile = function (t) {
              for (const e in o) t.uniforms[e] = o[e]
              t.fragmentShader = t.fragmentShader
                .replace('uniform float roughness;', 'uniform vec3 specular;')
                .replace(
                  'uniform float metalness;',
                  'uniform float glossiness;',
                )
                .replace('#include <roughnessmap_pars_fragment>', e)
                .replace('#include <metalnessmap_pars_fragment>', n)
                .replace('#include <roughnessmap_fragment>', i)
                .replace('#include <metalnessmap_fragment>', r)
                .replace('#include <lights_physical_fragment>', s)
            }),
            Object.defineProperties(this, {
              specular: {
                get: function () {
                  return o.specular.value
                },
                set: function (t) {
                  o.specular.value = t
                },
              },
              specularMap: {
                get: function () {
                  return o.specularMap.value
                },
                set: function (t) {
                  ;(o.specularMap.value = t),
                    t
                      ? (this.defines.USE_SPECULARMAP = '')
                      : delete this.defines.USE_SPECULARMAP
                },
              },
              glossiness: {
                get: function () {
                  return o.glossiness.value
                },
                set: function (t) {
                  o.glossiness.value = t
                },
              },
              glossinessMap: {
                get: function () {
                  return o.glossinessMap.value
                },
                set: function (t) {
                  ;(o.glossinessMap.value = t),
                    t
                      ? ((this.defines.USE_GLOSSINESSMAP = ''),
                        (this.defines.USE_UV = ''))
                      : (delete this.defines.USE_GLOSSINESSMAP,
                        delete this.defines.USE_UV)
                },
              },
            }),
            delete this.metalness,
            delete this.roughness,
            delete this.metalnessMap,
            delete this.roughnessMap,
            this.setValues(t)
        }
        copy(t) {
          return (
            super.copy(t),
            (this.specularMap = t.specularMap),
            this.specular.copy(t.specular),
            (this.glossinessMap = t.glossinessMap),
            (this.glossiness = t.glossiness),
            delete this.metalness,
            delete this.roughness,
            delete this.metalnessMap,
            delete this.roughnessMap,
            this
          )
        }
      }
      class pv {
        constructor() {
          ;(this.name = Kg.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS),
            (this.specularGlossinessParams = [
              'color',
              'map',
              'lightMap',
              'lightMapIntensity',
              'aoMap',
              'aoMapIntensity',
              'emissive',
              'emissiveIntensity',
              'emissiveMap',
              'bumpMap',
              'bumpScale',
              'normalMap',
              'normalMapType',
              'displacementMap',
              'displacementScale',
              'displacementBias',
              'specularMap',
              'specular',
              'glossinessMap',
              'glossiness',
              'alphaMap',
              'envMap',
              'envMapIntensity',
              'refractionRatio',
            ])
        }
        getMaterialType() {
          return dv
        }
        extendParams(t, e, n) {
          const i = e.extensions[this.name]
          ;(t.color = new Xc(1, 1, 1)), (t.opacity = 1)
          const r = []
          if (Array.isArray(i.diffuseFactor)) {
            const e = i.diffuseFactor
            t.color.fromArray(e), (t.opacity = e[3])
          }
          if (
            (void 0 !== i.diffuseTexture &&
              r.push(n.assignTexture(t, 'map', i.diffuseTexture)),
            (t.emissive = new Xc(0, 0, 0)),
            (t.glossiness =
              void 0 !== i.glossinessFactor ? i.glossinessFactor : 1),
            (t.specular = new Xc(1, 1, 1)),
            Array.isArray(i.specularFactor) &&
              t.specular.fromArray(i.specularFactor),
            void 0 !== i.specularGlossinessTexture)
          ) {
            const e = i.specularGlossinessTexture
            r.push(n.assignTexture(t, 'glossinessMap', e)),
              r.push(n.assignTexture(t, 'specularMap', e))
          }
          return Promise.all(r)
        }
        createMaterial(t) {
          const e = new dv(t)
          return (
            (e.fog = !0),
            (e.color = t.color),
            (e.map = void 0 === t.map ? null : t.map),
            (e.lightMap = null),
            (e.lightMapIntensity = 1),
            (e.aoMap = void 0 === t.aoMap ? null : t.aoMap),
            (e.aoMapIntensity = 1),
            (e.emissive = t.emissive),
            (e.emissiveIntensity = 1),
            (e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap),
            (e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap),
            (e.bumpScale = 1),
            (e.normalMap = void 0 === t.normalMap ? null : t.normalMap),
            (e.normalMapType = 0),
            t.normalScale && (e.normalScale = t.normalScale),
            (e.displacementMap = null),
            (e.displacementScale = 1),
            (e.displacementBias = 0),
            (e.specularMap = void 0 === t.specularMap ? null : t.specularMap),
            (e.specular = t.specular),
            (e.glossinessMap =
              void 0 === t.glossinessMap ? null : t.glossinessMap),
            (e.glossiness = t.glossiness),
            (e.alphaMap = null),
            (e.envMap = void 0 === t.envMap ? null : t.envMap),
            (e.envMapIntensity = 1),
            (e.refractionRatio = 0.98),
            e
          )
        }
      }
      class fv {
        constructor() {
          this.name = Kg.KHR_MESH_QUANTIZATION
        }
      }
      class mv extends Nm {
        constructor(t, e, n, i) {
          super(t, e, n, i)
        }
        copySampleValue_(t) {
          const e = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            r = t * i * 3 + i
          for (let t = 0; t !== i; t++) e[t] = n[r + t]
          return e
        }
      }
      ;(mv.prototype.beforeStart_ = mv.prototype.copySampleValue_),
        (mv.prototype.afterEnd_ = mv.prototype.copySampleValue_),
        (mv.prototype.interpolate_ = function (t, e, n, i) {
          const r = this.resultBuffer,
            s = this.sampleValues,
            o = this.valueSize,
            a = 2 * o,
            l = 3 * o,
            c = i - e,
            u = (n - e) / c,
            h = u * u,
            d = h * u,
            p = t * l,
            f = p - l,
            m = -2 * d + 3 * h,
            g = d - h,
            v = 1 - m,
            _ = g - h + u
          for (let t = 0; t !== o; t++) {
            const e = s[f + t + o],
              n = s[f + t + a] * c,
              i = s[p + t + o],
              l = s[p + t] * c
            r[t] = v * e + _ * n + m * i + g * l
          }
          return r
        })
      const gv = new Sl()
      class vv extends mv {
        interpolate_(t, e, n, i) {
          const r = super.interpolate_(t, e, n, i)
          return gv.fromArray(r).normalize().toArray(r), r
        }
      }
      const _v = {
          5120: Int8Array,
          5121: Uint8Array,
          5122: Int16Array,
          5123: Uint16Array,
          5125: Uint32Array,
          5126: Float32Array,
        },
        yv = { 9728: Ma, 9729: Ea, 9984: Sa, 9985: 1007, 9986: Ta, 9987: Da },
        xv = { 33071: ba, 33648: wa, 10497: xa },
        bv = {
          SCALAR: 1,
          VEC2: 2,
          VEC3: 3,
          VEC4: 4,
          MAT2: 4,
          MAT3: 9,
          MAT4: 16,
        },
        wv = {
          POSITION: 'position',
          NORMAL: 'normal',
          TANGENT: 'tangent',
          TEXCOORD_0: 'uv',
          TEXCOORD_1: 'uv2',
          COLOR_0: 'color',
          WEIGHTS_0: 'skinWeight',
          JOINTS_0: 'skinIndex',
        },
        Mv = {
          scale: 'scale',
          translation: 'position',
          rotation: 'quaternion',
          weights: 'morphTargetInfluences',
        },
        Sv = { CUBICSPLINE: void 0, LINEAR: za, STEP: Ba }
      function Tv(t, e) {
        return 'string' != typeof t || '' === t
          ? ''
          : (/^https?:\/\//i.test(e) &&
              /^\//.test(t) &&
              (e = e.replace(/(^https?:\/\/[^\/]+).*/i, '$1')),
            /^(https?:)?\/\//i.test(t) ||
            /^data:.*,.*$/i.test(t) ||
            /^blob:.*$/i.test(t)
              ? t
              : e + t)
      }
      function Ev(t, e, n) {
        for (const i in n.extensions)
          void 0 === t[i] &&
            ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
            (e.userData.gltfExtensions[i] = n.extensions[i]))
      }
      function Dv(t, e) {
        void 0 !== e.extras &&
          ('object' == typeof e.extras
            ? Object.assign(t.userData, e.extras)
            : console.warn(
                'THREE.GLTFLoader: Ignoring primitive type .extras, ' +
                  e.extras,
              ))
      }
      function Av(t, e) {
        if ((t.updateMorphTargets(), void 0 !== e.weights))
          for (let n = 0, i = e.weights.length; n < i; n++)
            t.morphTargetInfluences[n] = e.weights[n]
        if (e.extras && Array.isArray(e.extras.targetNames)) {
          const n = e.extras.targetNames
          if (t.morphTargetInfluences.length === n.length) {
            t.morphTargetDictionary = {}
            for (let e = 0, i = n.length; e < i; e++)
              t.morphTargetDictionary[n[e]] = e
          } else
            console.warn(
              'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.',
            )
        }
      }
      function Cv(t) {
        const e = t.extensions && t.extensions[Kg.KHR_DRACO_MESH_COMPRESSION]
        let n
        return (
          (n = e
            ? 'draco:' + e.bufferView + ':' + e.indices + ':' + Lv(e.attributes)
            : t.indices + ':' + Lv(t.attributes) + ':' + t.mode),
          n
        )
      }
      function Lv(t) {
        let e = ''
        const n = Object.keys(t).sort()
        for (let i = 0, r = n.length; i < r; i++)
          e += n[i] + ':' + t[n[i]] + ';'
        return e
      }
      function Rv(t) {
        switch (t) {
          case Int8Array:
            return 1 / 127
          case Uint8Array:
            return 1 / 255
          case Int16Array:
            return 1 / 32767
          case Uint16Array:
            return 1 / 65535
          default:
            throw new Error(
              'THREE.GLTFLoader: Unsupported normalized accessor component type.',
            )
        }
      }
      class Pv {
        constructor(t = {}, e = {}) {
          ;(this.json = t),
            (this.extensions = {}),
            (this.plugins = {}),
            (this.options = e),
            (this.cache = new Zg()),
            (this.associations = new Map()),
            (this.primitiveCache = {}),
            (this.meshCache = { refs: {}, uses: {} }),
            (this.cameraCache = { refs: {}, uses: {} }),
            (this.lightCache = { refs: {}, uses: {} }),
            (this.textureCache = {}),
            (this.nodeNamesUsed = {}),
            'undefined' != typeof createImageBitmap &&
            !1 === /Firefox/.test(navigator.userAgent)
              ? (this.textureLoader = new wg(this.options.manager))
              : (this.textureLoader = new ig(this.options.manager)),
            this.textureLoader.setCrossOrigin(this.options.crossOrigin),
            this.textureLoader.setRequestHeader(this.options.requestHeader),
            (this.fileLoader = new tg(this.options.manager)),
            this.fileLoader.setResponseType('arraybuffer'),
            'use-credentials' === this.options.crossOrigin &&
              this.fileLoader.setWithCredentials(!0)
        }
        setExtensions(t) {
          this.extensions = t
        }
        setPlugins(t) {
          this.plugins = t
        }
        parse(t, e) {
          const n = this,
            i = this.json,
            r = this.extensions
          this.cache.removeAll(),
            this._invokeAll(function (t) {
              return t._markDefs && t._markDefs()
            }),
            Promise.all(
              this._invokeAll(function (t) {
                return t.beforeRoot && t.beforeRoot()
              }),
            )
              .then(function () {
                return Promise.all([
                  n.getDependencies('scene'),
                  n.getDependencies('animation'),
                  n.getDependencies('camera'),
                ])
              })
              .then(function (e) {
                const s = {
                  scene: e[0][i.scene || 0],
                  scenes: e[0],
                  animations: e[1],
                  cameras: e[2],
                  asset: i.asset,
                  parser: n,
                  userData: {},
                }
                Ev(r, s, i),
                  Dv(s, i),
                  Promise.all(
                    n._invokeAll(function (t) {
                      return t.afterRoot && t.afterRoot(s)
                    }),
                  ).then(function () {
                    t(s)
                  })
              })
              .catch(e)
        }
        _markDefs() {
          const t = this.json.nodes || [],
            e = this.json.skins || [],
            n = this.json.meshes || []
          for (let n = 0, i = e.length; n < i; n++) {
            const i = e[n].joints
            for (let e = 0, n = i.length; e < n; e++) t[i[e]].isBone = !0
          }
          for (let e = 0, i = t.length; e < i; e++) {
            const i = t[e]
            void 0 !== i.mesh &&
              (this._addNodeRef(this.meshCache, i.mesh),
              void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)),
              void 0 !== i.camera &&
                this._addNodeRef(this.cameraCache, i.camera)
          }
        }
        _addNodeRef(t, e) {
          void 0 !== e &&
            (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e]++)
        }
        _getNodeRef(t, e, n) {
          if (t.refs[e] <= 1) return n
          const i = n.clone(),
            r = (t, e) => {
              const n = this.associations.get(t)
              null != n && this.associations.set(e, n)
              for (const [n, i] of t.children.entries()) r(i, e.children[n])
            }
          return r(n, i), (i.name += '_instance_' + t.uses[e]++), i
        }
        _invokeOne(t) {
          const e = Object.values(this.plugins)
          e.push(this)
          for (let n = 0; n < e.length; n++) {
            const i = t(e[n])
            if (i) return i
          }
          return null
        }
        _invokeAll(t) {
          const e = Object.values(this.plugins)
          e.unshift(this)
          const n = []
          for (let i = 0; i < e.length; i++) {
            const r = t(e[i])
            r && n.push(r)
          }
          return n
        }
        getDependency(t, e) {
          const n = t + ':' + e
          let i = this.cache.get(n)
          if (!i) {
            switch (t) {
              case 'scene':
                i = this.loadScene(e)
                break
              case 'node':
                i = this.loadNode(e)
                break
              case 'mesh':
                i = this._invokeOne(function (t) {
                  return t.loadMesh && t.loadMesh(e)
                })
                break
              case 'accessor':
                i = this.loadAccessor(e)
                break
              case 'bufferView':
                i = this._invokeOne(function (t) {
                  return t.loadBufferView && t.loadBufferView(e)
                })
                break
              case 'buffer':
                i = this.loadBuffer(e)
                break
              case 'material':
                i = this._invokeOne(function (t) {
                  return t.loadMaterial && t.loadMaterial(e)
                })
                break
              case 'texture':
                i = this._invokeOne(function (t) {
                  return t.loadTexture && t.loadTexture(e)
                })
                break
              case 'skin':
                i = this.loadSkin(e)
                break
              case 'animation':
                i = this.loadAnimation(e)
                break
              case 'camera':
                i = this.loadCamera(e)
                break
              default:
                throw new Error('Unknown type: ' + t)
            }
            this.cache.add(n, i)
          }
          return i
        }
        getDependencies(t) {
          let e = this.cache.get(t)
          if (!e) {
            const n = this,
              i = this.json[t + ('mesh' === t ? 'es' : 's')] || []
            ;(e = Promise.all(
              i.map(function (e, i) {
                return n.getDependency(t, i)
              }),
            )),
              this.cache.add(t, e)
          }
          return e
        }
        loadBuffer(t) {
          const e = this.json.buffers[t],
            n = this.fileLoader
          if (e.type && 'arraybuffer' !== e.type)
            throw new Error(
              'THREE.GLTFLoader: ' + e.type + ' buffer type is not supported.',
            )
          if (void 0 === e.uri && 0 === t)
            return Promise.resolve(this.extensions[Kg.KHR_BINARY_GLTF].body)
          const i = this.options
          return new Promise(function (t, r) {
            n.load(Tv(e.uri, i.path), t, void 0, function () {
              r(
                new Error(
                  'THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".',
                ),
              )
            })
          })
        }
        loadBufferView(t) {
          const e = this.json.bufferViews[t]
          return this.getDependency('buffer', e.buffer).then(function (t) {
            const n = e.byteLength || 0,
              i = e.byteOffset || 0
            return t.slice(i, i + n)
          })
        }
        loadAccessor(t) {
          const e = this,
            n = this.json,
            i = this.json.accessors[t]
          if (void 0 === i.bufferView && void 0 === i.sparse)
            return Promise.resolve(null)
          const r = []
          return (
            void 0 !== i.bufferView
              ? r.push(this.getDependency('bufferView', i.bufferView))
              : r.push(null),
            void 0 !== i.sparse &&
              (r.push(
                this.getDependency('bufferView', i.sparse.indices.bufferView),
              ),
              r.push(
                this.getDependency('bufferView', i.sparse.values.bufferView),
              )),
            Promise.all(r).then(function (t) {
              const r = t[0],
                s = bv[i.type],
                o = _v[i.componentType],
                a = o.BYTES_PER_ELEMENT,
                l = a * s,
                c = i.byteOffset || 0,
                u =
                  void 0 !== i.bufferView
                    ? n.bufferViews[i.bufferView].byteStride
                    : void 0,
                h = !0 === i.normalized
              let d, p
              if (u && u !== l) {
                const t = Math.floor(c / u),
                  n =
                    'InterleavedBuffer:' +
                    i.bufferView +
                    ':' +
                    i.componentType +
                    ':' +
                    t +
                    ':' +
                    i.count
                let l = e.cache.get(n)
                l ||
                  ((d = new o(r, t * u, (i.count * u) / a)),
                  (l = new Ip(d, u / a)),
                  e.cache.add(n, l)),
                  (p = new Np(l, s, (c % u) / a, h))
              } else (d = null === r ? new o(i.count * s) : new o(r, c, i.count * s)), (p = new Kc(d, s, h))
              if (void 0 !== i.sparse) {
                const e = bv.SCALAR,
                  n = _v[i.sparse.indices.componentType],
                  a = i.sparse.indices.byteOffset || 0,
                  l = i.sparse.values.byteOffset || 0,
                  c = new n(t[1], a, i.sparse.count * e),
                  u = new o(t[2], l, i.sparse.count * s)
                null !== r &&
                  (p = new Kc(p.array.slice(), p.itemSize, p.normalized))
                for (let t = 0, e = c.length; t < e; t++) {
                  const e = c[t]
                  if (
                    (p.setX(e, u[t * s]),
                    s >= 2 && p.setY(e, u[t * s + 1]),
                    s >= 3 && p.setZ(e, u[t * s + 2]),
                    s >= 4 && p.setW(e, u[t * s + 3]),
                    s >= 5)
                  )
                    throw new Error(
                      'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.',
                    )
                }
              }
              return p
            })
          )
        }
        loadTexture(t) {
          const e = this.json,
            n = this.options,
            i = e.textures[t],
            r = e.images[i.source]
          let s = this.textureLoader
          if (r.uri) {
            const t = n.manager.getHandler(r.uri)
            null !== t && (s = t)
          }
          return this.loadTextureImage(t, r, s)
        }
        loadTextureImage(t, e, n) {
          const i = this,
            r = this.json,
            s = this.options,
            o = r.textures[t],
            a = (e.uri || e.bufferView) + ':' + o.sampler
          if (this.textureCache[a]) return this.textureCache[a]
          const l = self.URL || self.webkitURL
          let c = e.uri || '',
            u = !1
          if (void 0 !== e.bufferView)
            c = i.getDependency('bufferView', e.bufferView).then(function (t) {
              u = !0
              const n = new Blob([t], { type: e.mimeType })
              return (c = l.createObjectURL(n)), c
            })
          else if (void 0 === e.uri)
            throw new Error(
              'THREE.GLTFLoader: Image ' + t + ' is missing URI and bufferView',
            )
          const h = Promise.resolve(c)
            .then(function (t) {
              return new Promise(function (e, i) {
                let r = e
                !0 === n.isImageBitmapLoader &&
                  (r = function (t) {
                    const n = new yl(t)
                    ;(n.needsUpdate = !0), e(n)
                  }),
                  n.load(Tv(t, s.path), r, void 0, i)
              })
            })
            .then(function (e) {
              !0 === u && l.revokeObjectURL(c),
                (e.flipY = !1),
                o.name && (e.name = o.name)
              const n = (r.samplers || {})[o.sampler] || {}
              return (
                (e.magFilter = yv[n.magFilter] || Ea),
                (e.minFilter = yv[n.minFilter] || Da),
                (e.wrapS = xv[n.wrapS] || xa),
                (e.wrapT = xv[n.wrapT] || xa),
                i.associations.set(e, { textures: t }),
                e
              )
            })
            .catch(function () {
              return (
                console.error("THREE.GLTFLoader: Couldn't load texture", c),
                null
              )
            })
          return (this.textureCache[a] = h), h
        }
        assignTexture(t, e, n) {
          const i = this
          return this.getDependency('texture', n.index).then(function (r) {
            if (
              (void 0 === n.texCoord ||
                0 == n.texCoord ||
                ('aoMap' === e && 1 == n.texCoord) ||
                console.warn(
                  'THREE.GLTFLoader: Custom UV set ' +
                    n.texCoord +
                    ' for texture ' +
                    e +
                    ' not yet supported.',
                ),
              i.extensions[Kg.KHR_TEXTURE_TRANSFORM])
            ) {
              const t =
                void 0 !== n.extensions
                  ? n.extensions[Kg.KHR_TEXTURE_TRANSFORM]
                  : void 0
              if (t) {
                const e = i.associations.get(r)
                ;(r = i.extensions[Kg.KHR_TEXTURE_TRANSFORM].extendTexture(
                  r,
                  t,
                )),
                  i.associations.set(r, e)
              }
            }
            return (t[e] = r), r
          })
        }
        assignFinalMaterial(t) {
          const e = t.geometry
          let n = t.material
          const i = void 0 === e.attributes.tangent,
            r = void 0 !== e.attributes.color,
            s = void 0 === e.attributes.normal
          if (t.isPoints) {
            const t = 'PointsMaterial:' + n.uuid
            let e = this.cache.get(t)
            e ||
              ((e = new Ef()),
              Uc.prototype.copy.call(e, n),
              e.color.copy(n.color),
              (e.map = n.map),
              (e.sizeAttenuation = !1),
              this.cache.add(t, e)),
              (n = e)
          } else if (t.isLine) {
            const t = 'LineBasicMaterial:' + n.uuid
            let e = this.cache.get(t)
            e ||
              ((e = new mf()),
              Uc.prototype.copy.call(e, n),
              e.color.copy(n.color),
              this.cache.add(t, e)),
              (n = e)
          }
          if (i || r || s) {
            let t = 'ClonedMaterial:' + n.uuid + ':'
            n.isGLTFSpecularGlossinessMaterial && (t += 'specular-glossiness:'),
              i && (t += 'derivative-tangents:'),
              r && (t += 'vertex-colors:'),
              s && (t += 'flat-shading:')
            let e = this.cache.get(t)
            e ||
              ((e = n.clone()),
              r && (e.vertexColors = !0),
              s && (e.flatShading = !0),
              i &&
                (e.normalScale && (e.normalScale.y *= -1),
                e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)),
              this.cache.add(t, e),
              this.associations.set(e, this.associations.get(n))),
              (n = e)
          }
          n.aoMap &&
            void 0 === e.attributes.uv2 &&
            void 0 !== e.attributes.uv &&
            e.setAttribute('uv2', e.attributes.uv),
            (t.material = n)
        }
        getMaterialType() {
          return Pm
        }
        loadMaterial(t) {
          const e = this,
            n = this.json,
            i = this.extensions,
            r = n.materials[t]
          let s
          const o = {},
            a = r.extensions || {},
            l = []
          if (a[Kg.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
            const t = i[Kg.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]
            ;(s = t.getMaterialType()), l.push(t.extendParams(o, r, e))
          } else if (a[Kg.KHR_MATERIALS_UNLIT]) {
            const t = i[Kg.KHR_MATERIALS_UNLIT]
            ;(s = t.getMaterialType()), l.push(t.extendParams(o, r, e))
          } else {
            const n = r.pbrMetallicRoughness || {}
            if (
              ((o.color = new Xc(1, 1, 1)),
              (o.opacity = 1),
              Array.isArray(n.baseColorFactor))
            ) {
              const t = n.baseColorFactor
              o.color.fromArray(t), (o.opacity = t[3])
            }
            void 0 !== n.baseColorTexture &&
              l.push(e.assignTexture(o, 'map', n.baseColorTexture)),
              (o.metalness =
                void 0 !== n.metallicFactor ? n.metallicFactor : 1),
              (o.roughness =
                void 0 !== n.roughnessFactor ? n.roughnessFactor : 1),
              void 0 !== n.metallicRoughnessTexture &&
                (l.push(
                  e.assignTexture(
                    o,
                    'metalnessMap',
                    n.metallicRoughnessTexture,
                  ),
                ),
                l.push(
                  e.assignTexture(
                    o,
                    'roughnessMap',
                    n.metallicRoughnessTexture,
                  ),
                )),
              (s = this._invokeOne(function (e) {
                return e.getMaterialType && e.getMaterialType(t)
              })),
              l.push(
                Promise.all(
                  this._invokeAll(function (e) {
                    return (
                      e.extendMaterialParams && e.extendMaterialParams(t, o)
                    )
                  }),
                ),
              )
          }
          !0 === r.doubleSided && (o.side = 2)
          const c = r.alphaMode || 'OPAQUE'
          if (
            ('BLEND' === c
              ? ((o.transparent = !0), (o.depthWrite = !1))
              : ((o.format = Ia),
                (o.transparent = !1),
                'MASK' === c &&
                  (o.alphaTest =
                    void 0 !== r.alphaCutoff ? r.alphaCutoff : 0.5)),
            void 0 !== r.normalTexture &&
              s !== Yc &&
              (l.push(e.assignTexture(o, 'normalMap', r.normalTexture)),
              (o.normalScale = new dl(1, 1)),
              void 0 !== r.normalTexture.scale))
          ) {
            const t = r.normalTexture.scale
            o.normalScale.set(t, t)
          }
          return (
            void 0 !== r.occlusionTexture &&
              s !== Yc &&
              (l.push(e.assignTexture(o, 'aoMap', r.occlusionTexture)),
              void 0 !== r.occlusionTexture.strength &&
                (o.aoMapIntensity = r.occlusionTexture.strength)),
            void 0 !== r.emissiveFactor &&
              s !== Yc &&
              (o.emissive = new Xc().fromArray(r.emissiveFactor)),
            void 0 !== r.emissiveTexture &&
              s !== Yc &&
              l.push(e.assignTexture(o, 'emissiveMap', r.emissiveTexture)),
            Promise.all(l).then(function () {
              let n
              return (
                (n =
                  s === dv
                    ? i[
                        Kg.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS
                      ].createMaterial(o)
                    : new s(o)),
                r.name && (n.name = r.name),
                n.map && (n.map.encoding = ja),
                n.emissiveMap && (n.emissiveMap.encoding = ja),
                Dv(n, r),
                e.associations.set(n, { materials: t }),
                r.extensions && Ev(i, n, r),
                n
              )
            })
          )
        }
        createUniqueName(t) {
          const e = Og.sanitizeNodeName(t || '')
          let n = e
          for (let t = 1; this.nodeNamesUsed[n]; ++t) n = e + '_' + t
          return (this.nodeNamesUsed[n] = !0), n
        }
        loadGeometries(t) {
          const e = this,
            n = this.extensions,
            i = this.primitiveCache
          function r(t) {
            return n[Kg.KHR_DRACO_MESH_COMPRESSION]
              .decodePrimitive(t, e)
              .then(function (n) {
                return Iv(n, t, e)
              })
          }
          const s = []
          for (let n = 0, o = t.length; n < o; n++) {
            const o = t[n],
              a = Cv(o),
              l = i[a]
            if (l) s.push(l.promise)
            else {
              let t
              ;(t =
                o.extensions && o.extensions[Kg.KHR_DRACO_MESH_COMPRESSION]
                  ? r(o)
                  : Iv(new lu(), o, e)),
                (i[a] = { primitive: o, promise: t }),
                s.push(t)
            }
          }
          return Promise.all(s)
        }
        loadMesh(t) {
          const e = this,
            n = this.json,
            i = this.extensions,
            r = n.meshes[t],
            s = r.primitives,
            o = []
          for (let t = 0, e = s.length; t < e; t++) {
            const e =
              void 0 === s[t].material
                ? (void 0 === (a = this.cache).DefaultMaterial &&
                    (a.DefaultMaterial = new Pm({
                      color: 16777215,
                      emissive: 0,
                      metalness: 1,
                      roughness: 1,
                      transparent: !1,
                      depthTest: !0,
                      side: 0,
                    })),
                  a.DefaultMaterial)
                : this.getDependency('material', s[t].material)
            o.push(e)
          }
          var a
          return (
            o.push(e.loadGeometries(s)),
            Promise.all(o).then(function (n) {
              const o = n.slice(0, n.length - 1),
                a = n[n.length - 1],
                l = []
              for (let n = 0, c = a.length; n < c; n++) {
                const c = a[n],
                  u = s[n]
                let h
                const d = o[n]
                if (
                  4 === u.mode ||
                  5 === u.mode ||
                  6 === u.mode ||
                  void 0 === u.mode
                )
                  (h = !0 === r.isSkinnedMesh ? new rf(c, d) : new Eu(c, d)),
                    !0 !== h.isSkinnedMesh ||
                      h.geometry.attributes.skinWeight.normalized ||
                      h.normalizeSkinWeights(),
                    5 === u.mode
                      ? (h.geometry = Ov(h.geometry, 1))
                      : 6 === u.mode && (h.geometry = Ov(h.geometry, 2))
                else if (1 === u.mode) h = new Sf(c, d)
                else if (3 === u.mode) h = new bf(c, d)
                else if (2 === u.mode) h = new Tf(c, d)
                else {
                  if (0 !== u.mode)
                    throw new Error(
                      'THREE.GLTFLoader: Primitive mode unsupported: ' + u.mode,
                    )
                  h = new Rf(c, d)
                }
                Object.keys(h.geometry.morphAttributes).length > 0 && Av(h, r),
                  (h.name = e.createUniqueName(r.name || 'mesh_' + t)),
                  Dv(h, r),
                  u.extensions && Ev(i, h, u),
                  e.assignFinalMaterial(h),
                  l.push(h)
              }
              for (let n = 0, i = l.length; n < i; n++)
                e.associations.set(l[n], { meshes: t, primitives: n })
              if (1 === l.length) return l[0]
              const c = new Tp()
              e.associations.set(c, { meshes: t })
              for (let t = 0, e = l.length; t < e; t++) c.add(l[t])
              return c
            })
          )
        }
        loadCamera(t) {
          let e
          const n = this.json.cameras[t],
            i = n[n.type]
          if (i)
            return (
              'perspective' === n.type
                ? (e = new Iu(
                    hl.radToDeg(i.yfov),
                    i.aspectRatio || 1,
                    i.znear || 1,
                    i.zfar || 2e6,
                  ))
                : 'orthographic' === n.type &&
                  (e = new rh(
                    -i.xmag,
                    i.xmag,
                    i.ymag,
                    -i.ymag,
                    i.znear,
                    i.zfar,
                  )),
              n.name && (e.name = this.createUniqueName(n.name)),
              Dv(e, n),
              Promise.resolve(e)
            )
          console.warn('THREE.GLTFLoader: Missing camera parameters.')
        }
        loadSkin(t) {
          const e = this.json.skins[t],
            n = { joints: e.joints }
          return void 0 === e.inverseBindMatrices
            ? Promise.resolve(n)
            : this.getDependency('accessor', e.inverseBindMatrices).then(
                function (t) {
                  return (n.inverseBindMatrices = t), n
                },
              )
        }
        loadAnimation(t) {
          const e = this.json.animations[t],
            n = [],
            i = [],
            r = [],
            s = [],
            o = []
          for (let t = 0, a = e.channels.length; t < a; t++) {
            const a = e.channels[t],
              l = e.samplers[a.sampler],
              c = a.target,
              u = void 0 !== c.node ? c.node : c.id,
              h = void 0 !== e.parameters ? e.parameters[l.input] : l.input,
              d = void 0 !== e.parameters ? e.parameters[l.output] : l.output
            n.push(this.getDependency('node', u)),
              i.push(this.getDependency('accessor', h)),
              r.push(this.getDependency('accessor', d)),
              s.push(l),
              o.push(c)
          }
          return Promise.all([
            Promise.all(n),
            Promise.all(i),
            Promise.all(r),
            Promise.all(s),
            Promise.all(o),
          ]).then(function (n) {
            const i = n[0],
              r = n[1],
              s = n[2],
              o = n[3],
              a = n[4],
              l = []
            for (let t = 0, e = i.length; t < e; t++) {
              const e = i[t],
                n = r[t],
                c = s[t],
                u = o[t],
                h = a[t]
              if (void 0 === e) continue
              let d
              switch (
                (e.updateMatrix(), (e.matrixAutoUpdate = !0), Mv[h.path])
              ) {
                case Mv.weights:
                  d = Vm
                  break
                case Mv.rotation:
                  d = jm
                  break
                default:
                  d = Xm
              }
              const p = e.name ? e.name : e.uuid,
                f = void 0 !== u.interpolation ? Sv[u.interpolation] : za,
                m = []
              Mv[h.path] === Mv.weights
                ? e.traverse(function (t) {
                    !0 === t.isMesh &&
                      t.morphTargetInfluences &&
                      m.push(t.name ? t.name : t.uuid)
                  })
                : m.push(p)
              let g = c.array
              if (c.normalized) {
                const t = Rv(g.constructor),
                  e = new Float32Array(g.length)
                for (let n = 0, i = g.length; n < i; n++) e[n] = g[n] * t
                g = e
              }
              for (let t = 0, e = m.length; t < e; t++) {
                const e = new d(m[t] + '.' + Mv[h.path], n.array, g, f)
                'CUBICSPLINE' === u.interpolation &&
                  ((e.createInterpolant = function (t) {
                    return new (this instanceof jm ? vv : mv)(
                      this.times,
                      this.values,
                      this.getValueSize() / 3,
                      t,
                    )
                  }),
                  (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0)),
                  l.push(e)
              }
            }
            const c = e.name ? e.name : 'animation_' + t
            return new Ym(c, void 0, l)
          })
        }
        createNodeMesh(t) {
          const e = this.json,
            n = this,
            i = e.nodes[t]
          return void 0 === i.mesh
            ? null
            : n.getDependency('mesh', i.mesh).then(function (t) {
                const e = n._getNodeRef(n.meshCache, i.mesh, t)
                return (
                  void 0 !== i.weights &&
                    e.traverse(function (t) {
                      if (t.isMesh)
                        for (let e = 0, n = i.weights.length; e < n; e++)
                          t.morphTargetInfluences[e] = i.weights[e]
                    }),
                  e
                )
              })
        }
        loadNode(t) {
          const e = this.json,
            n = this.extensions,
            i = this,
            r = e.nodes[t],
            s = r.name ? i.createUniqueName(r.name) : ''
          return (function () {
            const e = [],
              n = i._invokeOne(function (e) {
                return e.createNodeMesh && e.createNodeMesh(t)
              })
            return (
              n && e.push(n),
              void 0 !== r.camera &&
                e.push(
                  i.getDependency('camera', r.camera).then(function (t) {
                    return i._getNodeRef(i.cameraCache, r.camera, t)
                  }),
                ),
              i
                ._invokeAll(function (e) {
                  return e.createNodeAttachment && e.createNodeAttachment(t)
                })
                .forEach(function (t) {
                  e.push(t)
                }),
              Promise.all(e)
            )
          })().then(function (e) {
            let o
            if (
              ((o =
                !0 === r.isBone
                  ? new sf()
                  : e.length > 1
                  ? new Tp()
                  : 1 === e.length
                  ? e[0]
                  : new Dc()),
              o !== e[0])
            )
              for (let t = 0, n = e.length; t < n; t++) o.add(e[t])
            if (
              (r.name && ((o.userData.name = r.name), (o.name = s)),
              Dv(o, r),
              r.extensions && Ev(n, o, r),
              void 0 !== r.matrix)
            ) {
              const t = new nc()
              t.fromArray(r.matrix), o.applyMatrix4(t)
            } else void 0 !== r.translation && o.position.fromArray(r.translation), void 0 !== r.rotation && o.quaternion.fromArray(r.rotation), void 0 !== r.scale && o.scale.fromArray(r.scale)
            return (
              i.associations.has(o) || i.associations.set(o, {}),
              (i.associations.get(o).nodes = t),
              o
            )
          })
        }
        loadScene(t) {
          const e = this.json,
            n = this.extensions,
            i = this.json.scenes[t],
            r = this,
            s = new Tp()
          i.name && (s.name = r.createUniqueName(i.name)),
            Dv(s, i),
            i.extensions && Ev(n, s, i)
          const o = i.nodes || [],
            a = []
          for (let t = 0, n = o.length; t < n; t++) a.push(Fv(o[t], s, e, r))
          return Promise.all(a).then(function () {
            return (
              (r.associations = ((t) => {
                const e = new Map()
                for (const [t, n] of r.associations)
                  (t instanceof Uc || t instanceof yl) && e.set(t, n)
                return (
                  t.traverse((t) => {
                    const n = r.associations.get(t)
                    null != n && e.set(t, n)
                  }),
                  e
                )
              })(s)),
              s
            )
          })
        }
      }
      function Fv(t, e, n, i) {
        const r = n.nodes[t]
        return i
          .getDependency('node', t)
          .then(function (t) {
            if (void 0 === r.skin) return t
            let e
            return i
              .getDependency('skin', r.skin)
              .then(function (t) {
                e = t
                const n = []
                for (let t = 0, r = e.joints.length; t < r; t++)
                  n.push(i.getDependency('node', e.joints[t]))
                return Promise.all(n)
              })
              .then(function (n) {
                return (
                  t.traverse(function (t) {
                    if (!t.isMesh) return
                    const i = [],
                      r = []
                    for (let t = 0, s = n.length; t < s; t++) {
                      const s = n[t]
                      if (s) {
                        i.push(s)
                        const n = new nc()
                        void 0 !== e.inverseBindMatrices &&
                          n.fromArray(e.inverseBindMatrices.array, 16 * t),
                          r.push(n)
                      } else
                        console.warn(
                          'THREE.GLTFLoader: Joint "%s" could not be found.',
                          e.joints[t],
                        )
                    }
                    t.bind(new cf(i, r), t.matrixWorld)
                  }),
                  t
                )
              })
          })
          .then(function (t) {
            e.add(t)
            const s = []
            if (r.children) {
              const e = r.children
              for (let r = 0, o = e.length; r < o; r++) {
                const o = e[r]
                s.push(Fv(o, t, n, i))
              }
            }
            return Promise.all(s)
          })
      }
      function Iv(t, e, n) {
        const i = e.attributes,
          r = []
        function s(e, i) {
          return n.getDependency('accessor', e).then(function (e) {
            t.setAttribute(i, e)
          })
        }
        for (const e in i) {
          const n = wv[e] || e.toLowerCase()
          n in t.attributes || r.push(s(i[e], n))
        }
        if (void 0 !== e.indices && !t.index) {
          const i = n.getDependency('accessor', e.indices).then(function (e) {
            t.setIndex(e)
          })
          r.push(i)
        }
        return (
          Dv(t, e),
          (function (t, e, n) {
            const i = e.attributes,
              r = new Al()
            if (void 0 === i.POSITION) return
            {
              const t = n.json.accessors[i.POSITION],
                e = t.min,
                s = t.max
              if (void 0 === e || void 0 === s)
                return void console.warn(
                  'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.',
                )
              if (
                (r.set(new Tl(e[0], e[1], e[2]), new Tl(s[0], s[1], s[2])),
                t.normalized)
              ) {
                const e = Rv(_v[t.componentType])
                r.min.multiplyScalar(e), r.max.multiplyScalar(e)
              }
            }
            const s = e.targets
            if (void 0 !== s) {
              const t = new Tl(),
                e = new Tl()
              for (let i = 0, r = s.length; i < r; i++) {
                const r = s[i]
                if (void 0 !== r.POSITION) {
                  const i = n.json.accessors[r.POSITION],
                    s = i.min,
                    o = i.max
                  if (void 0 !== s && void 0 !== o) {
                    if (
                      (e.setX(Math.max(Math.abs(s[0]), Math.abs(o[0]))),
                      e.setY(Math.max(Math.abs(s[1]), Math.abs(o[1]))),
                      e.setZ(Math.max(Math.abs(s[2]), Math.abs(o[2]))),
                      i.normalized)
                    ) {
                      const t = Rv(_v[i.componentType])
                      e.multiplyScalar(t)
                    }
                    t.max(e)
                  } else
                    console.warn(
                      'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.',
                    )
                }
              }
              r.expandByVector(t)
            }
            t.boundingBox = r
            const o = new Xl()
            r.getCenter(o.center),
              (o.radius = r.min.distanceTo(r.max) / 2),
              (t.boundingSphere = o)
          })(t, e, n),
          Promise.all(r).then(function () {
            return void 0 !== e.targets
              ? (function (t, e, n) {
                  let i = !1,
                    r = !1
                  for (let t = 0, n = e.length; t < n; t++) {
                    const n = e[t]
                    if (
                      (void 0 !== n.POSITION && (i = !0),
                      void 0 !== n.NORMAL && (r = !0),
                      i && r)
                    )
                      break
                  }
                  if (!i && !r) return Promise.resolve(t)
                  const s = [],
                    o = []
                  for (let a = 0, l = e.length; a < l; a++) {
                    const l = e[a]
                    if (i) {
                      const e =
                        void 0 !== l.POSITION
                          ? n.getDependency('accessor', l.POSITION)
                          : t.attributes.position
                      s.push(e)
                    }
                    if (r) {
                      const e =
                        void 0 !== l.NORMAL
                          ? n.getDependency('accessor', l.NORMAL)
                          : t.attributes.normal
                      o.push(e)
                    }
                  }
                  return Promise.all([Promise.all(s), Promise.all(o)]).then(
                    function (e) {
                      const n = e[0],
                        s = e[1]
                      return (
                        i && (t.morphAttributes.position = n),
                        r && (t.morphAttributes.normal = s),
                        (t.morphTargetsRelative = !0),
                        t
                      )
                    },
                  )
                })(t, e.targets, n)
              : t
          })
        )
      }
      function Ov(t, e) {
        let n = t.getIndex()
        if (null === n) {
          const e = [],
            i = t.getAttribute('position')
          if (void 0 === i)
            return (
              console.error(
                'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.',
              ),
              t
            )
          for (let t = 0; t < i.count; t++) e.push(t)
          t.setIndex(e), (n = t.getIndex())
        }
        const i = n.count - 2,
          r = []
        if (2 === e)
          for (let t = 1; t <= i; t++)
            r.push(n.getX(0)), r.push(n.getX(t)), r.push(n.getX(t + 1))
        else
          for (let t = 0; t < i; t++)
            t % 2 == 0
              ? (r.push(n.getX(t)),
                r.push(n.getX(t + 1)),
                r.push(n.getX(t + 2)))
              : (r.push(n.getX(t + 2)),
                r.push(n.getX(t + 1)),
                r.push(n.getX(t)))
        r.length / 3 !== i &&
          console.error(
            'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.',
          )
        const s = t.clone()
        return s.setIndex(r), s
      }
      const Nv = new WeakMap()
      class kv extends Qm {
        constructor(t) {
          super(t),
            (this.decoderPath = ''),
            (this.decoderConfig = {}),
            (this.decoderBinary = null),
            (this.decoderPending = null),
            (this.workerLimit = 4),
            (this.workerPool = []),
            (this.workerNextTaskID = 1),
            (this.workerSourceURL = ''),
            (this.defaultAttributeIDs = {
              position: 'POSITION',
              normal: 'NORMAL',
              color: 'COLOR',
              uv: 'TEX_COORD',
            }),
            (this.defaultAttributeTypes = {
              position: 'Float32Array',
              normal: 'Float32Array',
              color: 'Float32Array',
              uv: 'Float32Array',
            })
        }
        setDecoderPath(t) {
          return (this.decoderPath = t), this
        }
        setDecoderConfig(t) {
          return (this.decoderConfig = t), this
        }
        setWorkerLimit(t) {
          return (this.workerLimit = t), this
        }
        load(t, e, n, i) {
          const r = new tg(this.manager)
          r.setPath(this.path),
            r.setResponseType('arraybuffer'),
            r.setRequestHeader(this.requestHeader),
            r.setWithCredentials(this.withCredentials),
            r.load(
              t,
              (t) => {
                const n = {
                  attributeIDs: this.defaultAttributeIDs,
                  attributeTypes: this.defaultAttributeTypes,
                  useUniqueIDs: !1,
                }
                this.decodeGeometry(t, n).then(e).catch(i)
              },
              n,
              i,
            )
        }
        decodeDracoFile(t, e, n, i) {
          const r = {
            attributeIDs: n || this.defaultAttributeIDs,
            attributeTypes: i || this.defaultAttributeTypes,
            useUniqueIDs: !!n,
          }
          this.decodeGeometry(t, r).then(e)
        }
        decodeGeometry(t, e) {
          for (const t in e.attributeTypes) {
            const n = e.attributeTypes[t]
            void 0 !== n.BYTES_PER_ELEMENT && (e.attributeTypes[t] = n.name)
          }
          const n = JSON.stringify(e)
          if (Nv.has(t)) {
            const e = Nv.get(t)
            if (e.key === n) return e.promise
            if (0 === t.byteLength)
              throw new Error(
                'THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.',
              )
          }
          let i
          const r = this.workerNextTaskID++,
            s = t.byteLength,
            o = this._getWorker(r, s)
              .then(
                (n) => (
                  (i = n),
                  new Promise((n, s) => {
                    ;(i._callbacks[r] = { resolve: n, reject: s }),
                      i.postMessage(
                        { type: 'decode', id: r, taskConfig: e, buffer: t },
                        [t],
                      )
                  })
                ),
              )
              .then((t) => this._createGeometry(t.geometry))
          return (
            o
              .catch(() => !0)
              .then(() => {
                i && r && this._releaseTask(i, r)
              }),
            Nv.set(t, { key: n, promise: o }),
            o
          )
        }
        _createGeometry(t) {
          const e = new lu()
          t.index && e.setIndex(new Kc(t.index.array, 1))
          for (let n = 0; n < t.attributes.length; n++) {
            const i = t.attributes[n],
              r = i.name,
              s = i.array,
              o = i.itemSize
            e.setAttribute(r, new Kc(s, o))
          }
          return e
        }
        _loadLibrary(t, e) {
          const n = new tg(this.manager)
          return (
            n.setPath(this.decoderPath),
            n.setResponseType(e),
            n.setWithCredentials(this.withCredentials),
            new Promise((e, i) => {
              n.load(t, e, void 0, i)
            })
          )
        }
        preload() {
          return this._initDecoder(), this
        }
        _initDecoder() {
          if (this.decoderPending) return this.decoderPending
          const t =
              'object' != typeof WebAssembly ||
              'js' === this.decoderConfig.type,
            e = []
          return (
            t
              ? e.push(this._loadLibrary('draco_decoder.js', 'text'))
              : (e.push(this._loadLibrary('draco_wasm_wrapper.js', 'text')),
                e.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'))),
            (this.decoderPending = Promise.all(e).then((e) => {
              const n = e[0]
              t || (this.decoderConfig.wasmBinary = e[1])
              const i = Bv.toString(),
                r = [
                  '/* draco decoder */',
                  n,
                  '',
                  '/* worker */',
                  i.substring(i.indexOf('{') + 1, i.lastIndexOf('}')),
                ].join('\n')
              this.workerSourceURL = URL.createObjectURL(new Blob([r]))
            })),
            this.decoderPending
          )
        }
        _getWorker(t, e) {
          return this._initDecoder().then(() => {
            if (this.workerPool.length < this.workerLimit) {
              const t = new Worker(this.workerSourceURL)
              ;(t._callbacks = {}),
                (t._taskCosts = {}),
                (t._taskLoad = 0),
                t.postMessage({
                  type: 'init',
                  decoderConfig: this.decoderConfig,
                }),
                (t.onmessage = function (e) {
                  const n = e.data
                  switch (n.type) {
                    case 'decode':
                      t._callbacks[n.id].resolve(n)
                      break
                    case 'error':
                      t._callbacks[n.id].reject(n)
                      break
                    default:
                      console.error(
                        'THREE.DRACOLoader: Unexpected message, "' +
                          n.type +
                          '"',
                      )
                  }
                }),
                this.workerPool.push(t)
            } else
              this.workerPool.sort(function (t, e) {
                return t._taskLoad > e._taskLoad ? -1 : 1
              })
            const n = this.workerPool[this.workerPool.length - 1]
            return (n._taskCosts[t] = e), (n._taskLoad += e), n
          })
        }
        _releaseTask(t, e) {
          ;(t._taskLoad -= t._taskCosts[e]),
            delete t._callbacks[e],
            delete t._taskCosts[e]
        }
        debug() {
          console.log(
            'Task load: ',
            this.workerPool.map((t) => t._taskLoad),
          )
        }
        dispose() {
          for (let t = 0; t < this.workerPool.length; ++t)
            this.workerPool[t].terminate()
          return (this.workerPool.length = 0), this
        }
      }
      function Bv() {
        let t, e
        function n(t, e, n, i, r, s) {
          const o = s.num_components(),
            a = n.num_points() * o,
            l = a * r.BYTES_PER_ELEMENT,
            c = (function (t, e) {
              switch (e) {
                case Float32Array:
                  return t.DT_FLOAT32
                case Int8Array:
                  return t.DT_INT8
                case Int16Array:
                  return t.DT_INT16
                case Int32Array:
                  return t.DT_INT32
                case Uint8Array:
                  return t.DT_UINT8
                case Uint16Array:
                  return t.DT_UINT16
                case Uint32Array:
                  return t.DT_UINT32
              }
            })(t, r),
            u = t._malloc(l)
          e.GetAttributeDataArrayForAllPoints(n, s, c, l, u)
          const h = new r(t.HEAPF32.buffer, u, a).slice()
          return t._free(u), { name: i, array: h, itemSize: o }
        }
        onmessage = function (i) {
          const r = i.data
          switch (r.type) {
            case 'init':
              ;(t = r.decoderConfig),
                (e = new Promise(function (e) {
                  ;(t.onModuleLoaded = function (t) {
                    e({ draco: t })
                  }),
                    DracoDecoderModule(t)
                }))
              break
            case 'decode':
              const i = r.buffer,
                s = r.taskConfig
              e.then((t) => {
                const e = t.draco,
                  o = new e.Decoder(),
                  a = new e.DecoderBuffer()
                a.Init(new Int8Array(i), i.byteLength)
                try {
                  const t = (function (t, e, i, r) {
                      const s = r.attributeIDs,
                        o = r.attributeTypes
                      let a, l
                      const c = e.GetEncodedGeometryType(i)
                      if (c === t.TRIANGULAR_MESH)
                        (a = new t.Mesh()), (l = e.DecodeBufferToMesh(i, a))
                      else {
                        if (c !== t.POINT_CLOUD)
                          throw new Error(
                            'THREE.DRACOLoader: Unexpected geometry type.',
                          )
                        ;(a = new t.PointCloud()),
                          (l = e.DecodeBufferToPointCloud(i, a))
                      }
                      if (!l.ok() || 0 === a.ptr)
                        throw new Error(
                          'THREE.DRACOLoader: Decoding failed: ' +
                            l.error_msg(),
                        )
                      const u = { index: null, attributes: [] }
                      for (const i in s) {
                        const l = self[o[i]]
                        let c, h
                        if (r.useUniqueIDs)
                          (h = s[i]), (c = e.GetAttributeByUniqueId(a, h))
                        else {
                          if (((h = e.GetAttributeId(a, t[s[i]])), -1 === h))
                            continue
                          c = e.GetAttribute(a, h)
                        }
                        u.attributes.push(n(t, e, a, i, l, c))
                      }
                      return (
                        c === t.TRIANGULAR_MESH &&
                          (u.index = (function (t, e, n) {
                            const i = 3 * n.num_faces(),
                              r = 4 * i,
                              s = t._malloc(r)
                            e.GetTrianglesUInt32Array(n, r, s)
                            const o = new Uint32Array(
                              t.HEAPF32.buffer,
                              s,
                              i,
                            ).slice()
                            return t._free(s), { array: o, itemSize: 1 }
                          })(t, e, a)),
                        t.destroy(a),
                        u
                      )
                    })(e, o, a, s),
                    i = t.attributes.map((t) => t.array.buffer)
                  t.index && i.push(t.index.array.buffer),
                    self.postMessage(
                      { type: 'decode', id: r.id, geometry: t },
                      i,
                    )
                } catch (t) {
                  console.error(t),
                    self.postMessage({
                      type: 'error',
                      id: r.id,
                      error: t.message,
                    })
                } finally {
                  e.destroy(a), e.destroy(o)
                }
              })
          }
        }
      }
      var zv = n(564),
        Uv = n.n(zv)
      function Hv(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n]
          ;(i.enumerable = i.enumerable || !1),
            (i.configurable = !0),
            'value' in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i)
        }
      }
      _i.registerPlugin(no, wo, qo, ia)
      var Gv = (function () {
        function t(e) {
          !(function (t, e) {
            if (!(t instanceof e))
              throw new TypeError('Cannot call a class as a function')
          })(this, t),
            (this.smooth = e.scrl),
            (this.params = {
              baseFirstP: [6, 175, 217],
              baseSecondP: [255, 255, 105],
              baseAccent: [0, 0, 0],
              divider: 1700,
              speed: 0.4,
              basePatterOffset: 0.5,
              secondPatternOffset: 0,
              xMult: 10,
              rotation: 1.5,
              noiseScale: 1,
              noiseDistA: 0.5,
              noiseDistB: 5.8,
              opacity: 0.8,
            }),
            document.body.classList.contains('darkmode') &&
              ((this.params.baseAccent = [255, 255, 255]),
              console.log(this.params.baseAccent)),
            (this.time = 0),
            (this.devicePixelRatio = 1),
            (this.container = e.dom),
            (this.scene = new Fp()),
            (this.width = this.container.offsetWidth),
            (this.height = this.container.offsetHeight),
            (this.camera = new Iu(70, this.width / this.height, 100, 2e3)),
            (this.camera.position.z = 600),
            (this.camera.fov =
              2 * Math.atan(this.height / 2 / 600) * (180 / Math.PI)),
            (this.renderer = new Lp({ antialias: !0, alpha: !0 })),
            this.renderer.setPixelRatio(this.devicePixelRatio),
            this.container.appendChild(this.renderer.domElement),
            (this.loader = new Jg()),
            (this.dracoLoader = new kv()),
            this.dracoLoader.setDecoderPath(window.basePath + 'static/draco/'),
            this.loader.setDRACOLoader(this.dracoLoader)
          var n = new _g(0)
          this.scene.add(n)
          var i = new mg(16777215, 0.5, 0)
          i.position.set(0, 200, 0),
            window.matchMedia('(max-width: 992px)').matches &&
              i.position.set(0, 400, 0),
            this.scene.add(i),
            (this.light2 = new mg(13161552, 0.35, 0)),
            this.light2.position.set(100, 200, 100),
            window.matchMedia('(max-width: 992px)').matches &&
              this.light2.position.set(180, 300, 420),
            this.scene.add(this.light2),
            (this.light3 = new mg(1796905, 0.15, 0)),
            this.light3.position.set(-100, -200, -100),
            window.matchMedia('(max-width: 992px)').matches &&
              this.light3.position.set(-100, -400, -100),
            this.scene.add(this.light3)
        }
        var e, i
        return (
          (e = t),
          (i = [
            {
              key: 'start',
              value: function () {
                var t = this,
                  e = [
                    new Promise(function (t, e) {
                      Uv()(
                        document.querySelectorAll('img'),
                        { background: !0 },
                        t,
                      )
                    }),
                  ]
                Promise.all(e).then(function () {
                  ;(t.oDavid = document.querySelector(
                    '.hworkflow__gallery-ditem',
                  )),
                    (t.loadTL = _i.timeline({
                      paused: !0,
                      onComplete: function () {
                        document.querySelector('.loader').classList.add('end'),
                          window.dispatchEvent(new Event('resize'))
                      },
                    })),
                    _i.set('.hero__t', { autoAlpha: 1 }),
                    new qo('.hero__t', { type: 'words', wordsClass: 'hide' })
                  var e = new qo('.hero__t', {
                    type: 'words',
                    wordsClass: 'words',
                  })
                  t.loadTL
                    .add('showin')
                    .to(
                      '#canvas-container',
                      {
                        duration: 0.5,
                        opacity: 1,
                        ease: 'power3.out',
                        onUpdate: function () {}.bind(t),
                      },
                      'showin',
                    )
                    .to(
                      '#wrapper',
                      {
                        duration: 0.5,
                        opacity: 1,
                        ease: 'power3.out',
                        onUpdate: function () {}.bind(t),
                      },
                      'showin',
                    )
                    .to(
                      t.params,
                      {
                        secondPatternOffset: 0,
                        duration: 1,
                        delay: 0.25,
                        ease: 'power3.out',
                        onUpdate: function () {
                          this.material.uniforms.secondPatternOffset.value = this.params.secondPatternOffset
                        }.bind(t),
                      },
                      'showin',
                    )
                    .to(
                      t.params,
                      {
                        noiseDistA: -0.6,
                        duration: 1.5,
                        delay: 0.25,
                        ease: 'power3.out',
                        onUpdate: function () {
                          this.material.uniforms.noiseDistA.value = this.params.noiseDistA
                        }.bind(t),
                      },
                      'showin+=0.5',
                    )
                    .from(
                      e.words,
                      {
                        duration: 1.2,
                        yPercent: 100,
                        ease: 'power3.out',
                        stagger: 0.04,
                        delay: 0.25,
                      },
                      'showin',
                    )
                    .from(
                      '.hero .arrow-start',
                      {
                        duration: 1.2,
                        opacity: 0,
                        yPercent: 100,
                        ease: 'power3.out',
                        delay: 0.25,
                      },
                      'showin',
                    )
                    .from(
                      '.hero__scroll',
                      {
                        duration: 1.2,
                        opacity: 0,
                        yPercent: 100,
                        ease: 'power3.out',
                        delay: 0.25,
                      },
                      'showin',
                    )
                    .from(
                      '.hero__marquee-txt',
                      {
                        duration: 1,
                        xPercent: 55,
                        skewX: -30,
                        ease: 'power3.out',
                        clearProps: !0,
                      },
                      'showin',
                    )
                    .add(function () {
                      window.dispatchEvent(new Event('resize')),
                        document
                          .querySelectorAll('.hero__marquee-txt')
                          .forEach(function (t) {
                            t.classList.add('ani')
                          })
                    }, '-=1.1'),
                    t.loadTL.play(),
                    t.setupResize(),
                    t.addObjects(),
                    t.resize(),
                    t.render()
                })
              },
            },
            {
              key: 'destroy',
              value: function () {
                ;(this.container.innerHTML = ''), cancelAnimationFrame(this.raf)
              },
            },
            {
              key: 'setDavidPositions',
              value: function () {
                if (this.dmodel) {
                  var t = this.oDavid.getBoundingClientRect(),
                    e =
                      (this.smooth.scrollTop(),
                      window.scrollY,
                      t.top + this.smooth.scrollTop())
                  ;(this.dmodel.position.y =
                    this.smooth.scrollTop() -
                    e +
                    this.height / 2 -
                    this.oDavid.clientHeight / 2),
                    (this.dmodel.position.x =
                      t.left - this.width / 2 + t.width / 2)
                }
              },
            },
            {
              key: 'setDavidSize',
              value: function () {
                this.dmodel &&
                  this.dmodel.scale.set(
                    this.oDavid.clientWidth / 2,
                    this.oDavid.clientWidth / 2,
                    this.oDavid.clientWidth / 2,
                  )
              },
            },
            {
              key: 'setupResize',
              value: function () {
                window.addEventListener('resize', this.resize.bind(this))
              },
            },
            {
              key: 'resize',
              value: function () {
                ;(this.width = this.container.offsetWidth),
                  (this.height = this.container.offsetHeight),
                  this.renderer.setSize(this.width, this.height),
                  (this.camera.aspect = this.width / this.height),
                  (this.camera.fov =
                    2 * Math.atan(this.height / 2 / 600) * (180 / Math.PI)),
                  this.camera.updateProjectionMatrix(),
                  this.setDavidSize(),
                  this.setDavidPositions()
              },
            },
            {
              key: 'addImage',
              value: function () {
                var t = new Au(),
                  e = new Yc({ color: 65280 })
                this.cube = new Eu(t, e)
                var n = document
                  .querySelector('.exampleImg')
                  .getBoundingClientRect()
                this.cube.scale.set(n.width, n.height, 1),
                  this.scene.add(this.cube)
              },
            },
            {
              key: 'updateImagePosition',
              value: function () {
                var t = document.querySelector('.exampleImg'),
                  e = t.getBoundingClientRect(),
                  n = this.smooth.scrollTop() - window.scrollY,
                  i = e.top + this.smooth.scrollTop() + 0.1 * n
                ;(this.cube.position.y =
                  this.smooth.scrollTop() - i + this.height / 2 - t.height / 2),
                  (this.cube.position.x = e.left - this.width / 2 + e.width / 2)
              },
            },
            {
              key: 'addObjects',
              value: function () {
                var t = n(73),
                  e = n(411)
                this.material = new Pu({
                  uniforms: {
                    time: { value: 0 },
                    baseFirstP: { value: this.params.baseFirstP },
                    baseSecondP: { value: this.params.baseSecondP },
                    baseAccent: { value: this.params.baseAccent },
                    divider: { value: this.params.divider },
                    speed: { value: this.params.speed },
                    basePatterOffset: { value: this.params.basePatterOffset },
                    secondPatternOffset: {
                      value: this.params.secondPatternOffset,
                    },
                    xMult: { value: this.params.xMult },
                    rotation: { value: this.params.rotation },
                    noiseScale: { value: this.params.noiseScale },
                    noiseDistA: { value: this.params.noiseDistA },
                    noiseDistB: { value: this.params.noiseDistB },
                    opacity: { value: this.params.opacity },
                  },
                  side: 2,
                  vertexShader: t,
                  fragmentShader: e,
                })
                var i = 600
                window.matchMedia('(min-width: 992px)').matches && (i = 800),
                  window.matchMedia('(min-width: 1800px)').matches && (i = 1e3)
                var r = new Rm(i, 32, 32),
                  s = new Eu(r, this.material)
                this.scene.add(s),
                  this.loader.load(
                    window.basePath + 'static/models/david.glb',
                    function (t) {
                      ;(this.dmesh = t.scene.children[0]),
                        (this.dmaterial = new Im({ color: 16777215 })),
                        (this.dgeometry = this.dmesh.geometry),
                        (this.dmodel = new Eu(this.dgeometry, this.dmaterial)),
                        this.scene.add(this.dmodel),
                        this.setDavidSize(),
                        this.setDavidPositions()
                    }.bind(this),
                  )
              },
            },
            {
              key: 'render',
              value: function () {
                ;(this.time += 0.015),
                  (this.material.uniforms.time.value = this.time),
                  this.dmodel && (this.dmodel.rotation.y += 0.01),
                  this.renderer.render(this.scene, this.camera),
                  (this.raf = requestAnimationFrame(this.render.bind(this)))
              },
            },
          ]),
          i && Hv(e.prototype, i),
          Object.defineProperty(e, 'prototype', { writable: !1 }),
          t
        )
      })()
      class Vv extends Qm {
        constructor(t) {
          super(t)
        }
        load(t, e, n, i) {
          const r = this,
            s = new tg(this.manager)
          s.setPath(this.path),
            s.setRequestHeader(this.requestHeader),
            s.setWithCredentials(r.withCredentials),
            s.load(
              t,
              function (t) {
                let n
                try {
                  n = JSON.parse(t)
                } catch (e) {
                  console.warn(
                    'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.',
                  ),
                    (n = JSON.parse(t.substring(65, t.length - 2)))
                }
                const i = r.parse(n)
                e && e(i)
              },
              n,
              i,
            )
        }
        parse(t) {
          return new Wv(t)
        }
      }
      class Wv {
        constructor(t) {
          ;(this.type = 'Font'), (this.data = t)
        }
        generateShapes(t, e = 100) {
          const n = [],
            i = (function (t, e, n) {
              const i = Array.from(t),
                r = e / n.resolution,
                s =
                  (n.boundingBox.yMax -
                    n.boundingBox.yMin +
                    n.underlineThickness) *
                  r,
                o = []
              let a = 0,
                l = 0
              for (let t = 0; t < i.length; t++) {
                const e = i[t]
                if ('\n' === e) (a = 0), (l -= s)
                else {
                  const t = jv(e, r, a, l, n)
                  ;(a += t.offsetX), o.push(t.path)
                }
              }
              return o
            })(t, e, this.data)
          for (let t = 0, e = i.length; t < e; t++)
            Array.prototype.push.apply(n, i[t].toShapes())
          return n
        }
      }
      function jv(t, e, n, i, r) {
        const s = r.glyphs[t] || r.glyphs['?']
        if (!s)
          return void console.error(
            'THREE.Font: character "' +
              t +
              '" does not exists in font family ' +
              r.familyName +
              '.',
          )
        const o = new Xg()
        let a, l, c, u, h, d, p, f
        if (s.o) {
          const t = s._cachedOutline || (s._cachedOutline = s.o.split(' '))
          for (let r = 0, s = t.length; r < s; )
            switch (t[r++]) {
              case 'm':
                ;(a = t[r++] * e + n), (l = t[r++] * e + i), o.moveTo(a, l)
                break
              case 'l':
                ;(a = t[r++] * e + n), (l = t[r++] * e + i), o.lineTo(a, l)
                break
              case 'q':
                ;(c = t[r++] * e + n),
                  (u = t[r++] * e + i),
                  (h = t[r++] * e + n),
                  (d = t[r++] * e + i),
                  o.quadraticCurveTo(h, d, c, u)
                break
              case 'b':
                ;(c = t[r++] * e + n),
                  (u = t[r++] * e + i),
                  (h = t[r++] * e + n),
                  (d = t[r++] * e + i),
                  (p = t[r++] * e + n),
                  (f = t[r++] * e + i),
                  o.bezierCurveTo(h, d, p, f, c, u)
            }
        }
        return { offsetX: s.ha * e, path: o }
      }
      Wv.prototype.isFont = !0
      var qv = n(796),
        Xv = n.n(qv)
      class Yv {
        constructor(t = null) {
          ;(this.nodeType = t), (this.updateType = 'none')
        }
        get type() {
          return this.constructor.name
        }
        getUpdateType() {
          return this.updateType
        }
        getNodeType() {
          return this.nodeType
        }
        getTypeLength(t) {
          return t.getTypeLength(this.getNodeType(t))
        }
        update() {
          console.warn('Abstract function.')
        }
        generate() {
          console.warn('Abstract function.')
        }
        build(t, e = null) {
          if ((t.addNode(this), 1 === this.generate.length)) {
            const n = this.getNodeType(t),
              i = t.getDataFromNode(this)
            let r = i.snippet
            return (
              void 0 === r && ((r = this.generate(t)), (i.snippet = r)),
              t.format(r, n, e)
            )
          }
          return this.generate(t, e)
        }
      }
      Yv.prototype.isNode = !0
      var Jv = Yv,
        Zv = class extends Jv {
          constructor(t = '', e = 'code') {
            super(e),
              (this.code = t),
              (this.useKeywords = !1),
              (this._includes = []),
              Object.defineProperty(this, 'isCodeNode', { value: !0 })
          }
          setIncludes(t) {
            return (this._includes = t), this
          }
          getIncludes() {
            return this._includes
          }
          generate(t) {
            if (!0 === this.useKeywords) {
              const e = t.getContextValue('keywords')
              if (void 0 !== e) {
                const n = t.getDataFromNode(this, t.shaderStage)
                void 0 === n.keywords && (n.keywords = []),
                  -1 === n.keywords.indexOf(e) &&
                    (e.include(t, this.code), n.keywords.push(e))
              }
            }
            const e = this.getIncludes(t)
            for (const n of e) n.build(t)
            const n = t.getCodeFromNode(this, this.getNodeType(t))
            return (n.code = this.code), n.code
          }
        },
        Kv = class extends Zv {
          constructor(t = '', e = '', n = '') {
            super(t, e), (this.includes = []), (this.name = n)
          }
          generate(t) {
            const e = super.generate(t),
              n = t.getCodeFromNode(this, this.getNodeType(t))
            '' !== this.name && (n.name = this.name)
            const i = t.getPropertyName(n)
            return (n.code = `#define ${i} ${e}`), i
          }
        }
      const Qv = new Kv('3.141592653589793', 'float', 'PI')
      new Kv('0.3183098861837907', 'float', 'RECIPROCAL_PI'),
        new Kv('1e-6', 'float', 'EPSILON'),
        new Kv('0.04', 'float', 'DEFAULT_SPECULAR_COEFFICIENT')
      var $v = class {
          constructor(t, e, n = '', i = !1, r = 0) {
            ;(this.type = t),
              (this.name = e),
              (this.qualifier = n),
              (this.isConst = i),
              (this.count = r),
              Object.defineProperty(this, 'isNodeFunction', { value: !0 })
          }
        },
        t_ = class extends Jv {
          constructor(t) {
            super(t)
          }
          build(t, e) {
            const n = t.getVectorType(this.getNodeType(t))
            if ('void' !== n) {
              const i = t.getVarFromNode(this, n),
                r = t.getPropertyName(i),
                s = t.getDataFromNode(this)
              let o = s.snippet
              return (
                void 0 === o &&
                  ((o = super.build(t, n)),
                  t.addFlowCode(`${r} = ${o}`),
                  (s.snippet = o)),
                t.format(r, n, e)
              )
            }
            return super.build(t, e)
          }
        },
        e_ = class extends t_ {
          constructor(t = null, e = {}) {
            super(), (this.functionNode = t), (this.parameters = e)
          }
          setParameters(t) {
            return (this.parameters = t), this
          }
          getParameters() {
            return this.parameters
          }
          getNodeType(t) {
            return this.functionNode.getNodeType(t)
          }
          generate(t) {
            const e = [],
              n = this.functionNode,
              i = n.getInputs(t),
              r = this.parameters
            for (const n of i) {
              const i = r[n.name]
              if (void 0 === i)
                throw new Error(
                  `FunctionCallNode: Input '${n.name}' not found in FunctionNode.`,
                )
              e.push(i.build(t, n.type))
            }
            return `${n.build(t, 'property')}( ${e.join(', ')} )`
          }
        }
      const n_ = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\((.*?)\)/i,
        i_ = /[a-z_0-9]+/gi,
        r_ = '#pragma main'
      var s_ = class extends Zv {
        constructor(t = '') {
          super(t),
            (this.inputs = []),
            (this.name = ''),
            (this.needsUpdate = !0),
            (this.useKeywords = !0),
            (this.presicion = ''),
            (this._includeCode = ''),
            (this._internalCode = '')
        }
        getNodeType(t) {
          return !0 === this.needsUpdate && this.parse(), super.getNodeType(t)
        }
        getInputs() {
          return !0 === this.needsUpdate && this.parse(), this.inputs
        }
        parse() {
          const t = this.code,
            e = t.indexOf(r_),
            n = -1 !== e ? t.substr(e + r_.length) : t,
            i = n.match(n_)
          if (null === i || 5 !== i.length)
            throw new Error('FunctionNode: Function is not a GLSL code.')
          {
            const r = i[4],
              s = []
            let o = null
            for (; null !== (o = i_.exec(r)); ) s.push(o)
            const a = []
            let l = 0
            for (; l < s.length; ) {
              const t = 'const' === s[l][0]
              !0 === t && l++
              let e = s[l][0]
              'in' === e || 'out' === e || 'inout' === e ? l++ : (e = '')
              const n = s[l++][0]
              let i = Number.parseInt(s[l][0])
              !1 === Number.isNaN(i) ? l++ : (i = 0)
              const r = s[l++][0]
              a.push(new $v(n, r, e, t, i))
            }
            const c = n.substring(i[0].length)
            ;(this.name = void 0 !== i[3] ? i[3] : ''),
              (this.nodeType = i[2]),
              (this.presicion = void 0 !== i[1] ? i[1] : ''),
              (this.inputs = a),
              (this._includeCode = -1 !== e ? t.substr(0, e) : ''),
              (this._internalCode = `( ${r} ) ${c}`)
          }
          ;(this.code = t), (this.needsUpdate = !1)
        }
        call(t = {}) {
          return new e_(this, t)
        }
        generate(t, e) {
          super.generate(t)
          const n = this.getNodeType(t),
            i = t.getCodeFromNode(this, n)
          '' !== this.name && (i.name = this.name)
          const r = t.getPropertyName(i),
            s = this.presicion,
            o = this._includeCode
          let a = `${n} ${r} ${this._internalCode}`
          return (
            '' !== s && (a = `${s} ${a}`),
            '' !== o && (a = `${o} ${a}`),
            (i.code = a),
            'property' === e ? r : t.format(`${r}()`, n, e)
          )
        }
      }
      function o_(t, e) {
        ;(null == e || e > t.length) && (e = t.length)
        for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n]
        return i
      }
      function a_(t, e) {
        if (!(t instanceof e))
          throw new TypeError('Cannot call a class as a function')
      }
      function l_(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n]
          ;(i.enumerable = i.enumerable || !1),
            (i.configurable = !0),
            'value' in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i)
        }
      }
      function c_(t, e, n) {
        return (
          e && l_(t.prototype, e),
          n && l_(t, n),
          Object.defineProperty(t, 'prototype', { writable: !1 }),
          t
        )
      }
      new Zv('#define saturate(a) clamp( a, 0.0, 1.0 )'),
        new Zv('#define whiteComplement(a) ( 1.0 - saturate( a ) )'),
        new s_(
          '\nvec3 ( in vec3 dir, in mat4 matrix ) {\n\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n}',
        ),
        new s_(
          '\nvec3 ( in vec3 dir, in mat4 matrix ) {\n\n\t// dir can be either a direction vector or a normal vector\n\t// upper-left 3x3 of matrix is assumed to be orthogonal\n\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n\n}',
        ),
        new s_('float pow2( const in float x ) { return x*x; }'),
        new s_('float pow3( const in float x ) { return x*x*x; }'),
        new s_(
          'float pow4( const in float x ) { float x2 = x*x; return x2*x2; }',
        ),
        new s_(
          'float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }',
        ),
        new s_('float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }'),
        new s_(
          '\nhighp float rand( const in vec2 uv ) {\n\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, 3.141592653589793 );\n\n\treturn fract(sin(sn) * c);\n\n}',
        ).setIncludes([Qv]),
        new s_('float precisionSafeLength( vec3 v ) { return length( v ); }'),
        n(73),
        n(411)
      var u_ = (function () {
          function t() {
            a_(this, t),
              (function (t, { include: e, exclude: n } = {}) {
                const i = (t) => {
                  const i = (e) => ('string' == typeof e ? t === e : e.test(t))
                  return e ? e.some(i) : !n || !n.some(i)
                }
                for (const [e, n] of ((t) => {
                  const e = new Set()
                  do {
                    for (const n of Reflect.ownKeys(t)) e.add([t, n])
                  } while (
                    (t = Reflect.getPrototypeOf(t)) &&
                    t !== Object.prototype
                  )
                  return e
                })(t.constructor.prototype)) {
                  if ('constructor' === n || !i(n)) continue
                  const r = Reflect.getOwnPropertyDescriptor(e, n)
                  r && 'function' == typeof r.value && (t[n] = t[n].bind(t))
                }
              })(this),
              (this.slider = document.querySelector('.slider')),
              (this.sliderFirst = document.querySelector('.first-slider')),
              (this.sliderSecond = document.querySelector('.second-slider')),
              (this.scroll = { current: 0, target: 0, ease: 0.1, delta: 0 }),
              this.addEvents(),
              this.onResize(),
              this.update()
          }
          return (
            c_(t, [
              {
                key: 'addEvents',
                value: function () {
                  window.addEventListener(
                    'wheel',
                    this.onMouseWheel.bind(this),
                  ),
                    window.addEventListener(
                      'mousedown',
                      this.onTouchDown.bind(this),
                    ),
                    window.addEventListener(
                      'mousemove',
                      this.onTouchMove.bind(this),
                    ),
                    window.addEventListener(
                      'mouseup',
                      this.onTouchUp.bind(this),
                    ),
                    window.addEventListener(
                      'touchstart',
                      this.onTouchDown.bind(this),
                    ),
                    window.addEventListener(
                      'touchmove',
                      this.onTouchMove.bind(this),
                    ),
                    window.addEventListener(
                      'touchend',
                      this.onTouchUp.bind(this),
                    ),
                    window.addEventListener('resize', this.onResize)
                },
              },
              {
                key: 'destroy',
                value: function () {
                  cancelAnimationFrame(this.raf)
                },
              },
              {
                key: 'onTouchDown',
                value: function (t) {
                  ;(this.isDown = !0),
                    (this.scroll.position = this.scroll.current),
                    (this.start = t.touches ? t.touches[0].clientY : t.clientY)
                },
              },
              {
                key: 'onTouchMove',
                value: function (t) {
                  if (this.isDown) {
                    var e = t.touches ? t.touches[0].clientY : t.clientY,
                      n = 2 * (this.start - e)
                    this.scroll.target = this.scroll.position - n
                  }
                },
              },
              {
                key: 'onTouchUp',
                value: function (t) {
                  this.isDown = !1
                },
              },
              {
                key: 'onMouseWheel',
                value: function (t) {
                  var e = Xv()(t).pixelY
                  this.scroll.target -= e
                },
              },
              {
                key: 'onResize',
                value: function () {
                  this.sliderBounds = this.slider.getBoundingClientRect()
                },
              },
              {
                key: 'update',
                value: function () {
                  ;(this.scroll.current +=
                    (this.scroll.target - this.scroll.current) *
                    this.scroll.ease),
                    (this.scroll.delta =
                      (this.scroll.target - this.scroll.current) *
                      this.scroll.ease)
                  var t = 1.5 * this.scroll.current,
                    e = (t / this.sliderBounds.height) * 2
                  ;(this.multiplier = Math.floor(e)),
                    (this.sliderFirst.style.transform = 'translateY('.concat(
                      -t + (this.multiplier * this.sliderBounds.height) / 2,
                      'px)',
                    )),
                    (this.sliderSecond.style.transform = 'translateY('.concat(
                      -t + (this.multiplier * this.sliderBounds.height) / 2,
                      'px)',
                    )),
                    (this.raf = requestAnimationFrame(this.update))
                },
              },
            ]),
            t
          )
        })(),
        h_ = (function () {
          function t(e) {
            var n
            a_(this, t),
              (this.params = {
                baseSecondP: [249, 79, 57],
                baseFirstP: [43, 80, 170],
                baseAccent: [0, 0, 0],
                divider: 1700,
                speed: 0.4,
                basePatterOffset: 0.5,
                secondPatternOffset: 3.5,
                xMult: 10,
                rotation: 1.5,
                noiseScale: 1,
                noiseDistA: 0.5,
                noiseDistB: 5.8,
                opacity: 0,
              }),
              (this.meshStore = []),
              (this.mouse = new dl()),
              (this.mousePerspective = new dl()),
              (this.ani = !1),
              (this.images =
                (function (t) {
                  if (Array.isArray(t)) return o_(t)
                })((n = document.querySelectorAll('img'))) ||
                (function (t) {
                  if (
                    ('undefined' != typeof Symbol &&
                      null != t[Symbol.iterator]) ||
                    null != t['@@iterator']
                  )
                    return Array.from(t)
                })(n) ||
                (function (t, e) {
                  if (t) {
                    if ('string' == typeof t) return o_(t, e)
                    var n = Object.prototype.toString.call(t).slice(8, -1)
                    return (
                      'Object' === n &&
                        t.constructor &&
                        (n = t.constructor.name),
                      'Map' === n || 'Set' === n
                        ? Array.from(t)
                        : 'Arguments' === n ||
                          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                        ? o_(t, e)
                        : void 0
                    )
                  }
                })(n) ||
                (function () {
                  throw new TypeError(
                    'Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
                  )
                })()),
              (this.time = 0),
              (this.devicePixelRatio = 1),
              (this.container = e.dom),
              (this.scene = new Fp()),
              (this.width = this.container.offsetWidth),
              (this.height = this.container.offsetHeight),
              (this.camera = new Iu(70, this.width / this.height, 100, 2e3)),
              (this.camera.position.z = 600),
              (this.camera.fov =
                2 * Math.atan(this.height / 2 / 600) * (180 / Math.PI)),
              (this.raycaster = new Bg()),
              (this.int = null),
              (this.intClick = null),
              (this.renderer = new Lp({ antialias: !0, alpha: !0 })),
              this.renderer.setPixelRatio(this.devicePixelRatio),
              this.container.appendChild(this.renderer.domElement)
            var i = new _g(0)
            this.scene.add(i)
            var r = new mg(16777215, 0.5, 0)
            r.position.set(0, 200, 0),
              this.scene.add(r),
              (this.light2 = new mg(13161552, 0.35, 0)),
              this.light2.position.set(100, 200, 100),
              this.scene.add(this.light2),
              (this.light3 = new mg(1796905, 0.15, 0)),
              this.light3.position.set(-100, -200, -100),
              this.scene.add(this.light3)
          }
          return (
            c_(t, [
              {
                key: 'destroy',
                value: function () {
                  ;(this.container.innerHTML = ''),
                    cancelAnimationFrame(this.raf),
                    this.slider.destroy()
                },
              },
              {
                key: 'start',
                value: function () {
                  var t = this,
                    e = [
                      new Promise(function (t, e) {
                        Uv()(
                          document.querySelectorAll('img'),
                          { background: !0 },
                          t,
                        )
                      }),
                    ]
                  Promise.all(e).then(function () {
                    ;(t.slider = new u_()),
                      new Vv().load(
                        window.basePath +
                          'static/fonts/Druk_Cond_Web_Super_Regular.json',
                        function (t) {
                          var e = 16777215
                          document.body.classList.contains('darkmode') &&
                            (e = 0),
                            (this.matDark = new mf({ color: e, side: 2 })),
                            (this.matDark.needsUpdate = !0)
                          var n = 'PORTALS',
                            i = t.generateShapes(n, 96)
                          window.matchMedia('(min-width: 1201px)').matches &&
                            (i = t.generateShapes(n, 240))
                          var r = new Lm(i)
                          r.computeBoundingBox()
                          var s =
                              -0.5 *
                              (r.boundingBox.max.x - r.boundingBox.min.x),
                            o =
                              -0.5 * (r.boundingBox.max.y - r.boundingBox.min.y)
                          r.translate(s, o, 0)
                          for (var a = [], l = 0; l < i.length; l++) {
                            var c = i[l]
                            if (c.holes && c.holes.length > 0)
                              for (var u = 0; u < c.holes.length; u++) {
                                var h = c.holes[u]
                                a.push(h)
                              }
                          }
                          i.push.apply(i, a)
                          for (var d = new Dc(), p = 0; p < i.length; p++) {
                            var f = i[p].getPoints(),
                              m = new lu().setFromPoints(f)
                            m.translate(s, o, 0)
                            var g = new bf(m, this.matDark)
                            d.add(g)
                          }
                          this.scene.add(d)
                        }.bind(t),
                      ),
                      _i
                        .timeline({
                          onComplete: function () {
                            document
                              .querySelector('.loader')
                              .classList.add('end')
                          },
                          onStart: function () {
                            var t = document.createEvent('MouseEvents')
                            t.initEvent('wheel', !0, !0),
                              (t.deltaY = 120),
                              window.dispatchEvent(t)
                          },
                        })
                        .add('showin')
                        .to(
                          '#wrapper',
                          {
                            duration: 0.5,
                            opacity: 1,
                            ease: 'power3.out',
                            onUpdate: function () {}.bind(t),
                          },
                          'showin',
                        )
                        .to(
                          '#canvas-container',
                          { duration: 0.5, opacity: 1, ease: 'power3.out' },
                          'bg',
                        )
                        .add('showin')
                        .to(
                          t.params,
                          {
                            secondPatternOffset: 0,
                            duration: 1,
                            delay: 0.25,
                            ease: 'power3.out',
                            onUpdate: function () {
                              this.material.uniforms.secondPatternOffset.value = this.params.secondPatternOffset
                            }.bind(t),
                          },
                          'bg',
                        )
                        .to(
                          t.params,
                          {
                            noiseDistA: -0.6,
                            duration: 1.5,
                            delay: 0.25,
                            ease: 'power3.out',
                            onUpdate: function () {
                              this.material.uniforms.noiseDistA.value = this.params.noiseDistA
                            }.bind(t),
                          },
                          'bg',
                        )
                        .from(
                          '.portfolio__text',
                          {
                            duration: 1,
                            yPercent: 100,
                            opacity: 0,
                            ease: 'power3.out',
                            clearProps: !0,
                          },
                          'showin',
                        ),
                      t.setupEvents(),
                      t.addImages(),
                      t.addObjects(),
                      t.resize(),
                      t.render()
                  })
                },
              },
              {
                key: 'addObjects',
                value: function () {
                  var t = n(73),
                    e = n(411)
                  this.material = new Pu({
                    uniforms: {
                      time: { value: 0 },
                      baseFirstP: { value: this.params.baseFirstP },
                      baseSecondP: { value: this.params.baseSecondP },
                      baseAccent: { value: this.params.baseAccent },
                      divider: { value: this.params.divider },
                      speed: { value: this.params.speed },
                      basePatterOffset: { value: this.params.basePatterOffset },
                      secondPatternOffset: {
                        value: this.params.secondPatternOffset,
                      },
                      xMult: { value: this.params.xMult },
                      rotation: { value: this.params.rotation },
                      noiseScale: { value: this.params.noiseScale },
                      noiseDistA: { value: this.params.noiseDistA },
                      noiseDistB: { value: this.params.noiseDistB },
                      opacity: { value: this.params.opacity },
                    },
                    side: 2,
                    vertexShader: t,
                    fragmentShader: e,
                  })
                  var i = new Rm(hl.clamp(this.width / 1.5, 1200, 3e3), 32, 32),
                    r = new Eu(i, this.material)
                  this.scene.add(r)
                },
              },
              {
                key: 'mouseMove',
                value: function (t) {
                  ;(this.mousePerspective.x =
                    t.clientX / window.innerWidth - 0.5),
                    (this.mousePerspective.y =
                      t.clientY / window.innerHeight - 0.5),
                    (this.updatingPerspective = !0),
                    (this.mouse.x =
                      (t.clientX / this.renderer.domElement.clientWidth) * 2 -
                      1),
                    (this.mouse.y =
                      (-t.clientY / this.renderer.domElement.clientHeight) * 2 +
                      1)
                },
              },
              {
                key: 'updatePerspective',
                value: function () {
                  _i.to(this.camera.rotation, {
                    duration: 4,
                    x: 0.5 * -this.mousePerspective.y,
                    y: 0.5 * -this.mousePerspective.x,
                    ease: 'power3.out',
                  }),
                    (this.updatingPerspective = !1)
                },
              },
              {
                key: 'setupEvents',
                value: function () {
                  document.querySelector('.header').addEventListener(
                    'mouseover',
                    function () {
                      this.raycaster.layers.disableAll()
                    }.bind(this),
                  ),
                    document.querySelector('.header').addEventListener(
                      'mouseout',
                      function () {
                        this.raycaster.layers.enableAll()
                      }.bind(this),
                    ),
                    window.addEventListener('resize', this.resize.bind(this)),
                    window.addEventListener('click', this.findInt.bind(this)),
                    window.addEventListener(
                      'touchend',
                      this.onDocumentTouchEnd.bind(this),
                      !1,
                    ),
                    window.matchMedia('(min-width: 1201px)').matches &&
                      window.addEventListener(
                        'mousemove',
                        this.mouseMove.bind(this),
                      )
                },
              },
              {
                key: 'resize',
                value: function () {
                  ;(this.width = this.container.offsetWidth),
                    (this.height = this.container.offsetHeight),
                    this.renderer.setSize(this.width, this.height),
                    (this.camera.aspect = this.width / this.height),
                    (this.camera.fov =
                      2 * Math.atan(this.height / 2 / 600) * (180 / Math.PI)),
                    this.camera.updateProjectionMatrix(),
                    this.setImagesSizes()
                },
              },
              {
                key: 'addImages',
                value: function () {
                  var t = this,
                    e = n(965),
                    i = n(144)
                  ;(this.material = new Pu({
                    uniforms: {
                      time: { value: 0 },
                      uImage: { value: 0 },
                      hoverState: { value: 1 },
                      uPlaneSizes: { value: [0, 0] },
                      uImageSizes: { value: [0, 0] },
                      uViewportSizes: { value: [this.width, this.height] },
                      uStrength: { value: 0 },
                    },
                    side: 2,
                    vertexShader: e,
                    fragmentShader: i,
                    wireframe: !1,
                  })),
                    (this.materials = []),
                    (this.imagesStore = this.images.map(function (e) {
                      e.crossOrigin = 'anonymous'
                      var n = e.getBoundingClientRect(),
                        i = new Yu(1, 1),
                        r = new yl(e)
                      ;(r.needsUpdate = !0), (r.magFilter = Ma)
                      var s = t.material.clone()
                      t.materials.push(s),
                        (s.uniforms.uImage.value = r),
                        (s.uniforms.uImageSizes.value = [
                          e.naturalWidth,
                          e.naturalHeight,
                        ])
                      var o = new Eu(i, s)
                      return (
                        void 0 !== e.dataset.title &&
                          (o.title = e.dataset.title),
                        void 0 !== e.dataset.link && (o.link = e.dataset.link),
                        (o.position.z = hl.randInt(-5, 5)),
                        t.meshStore.push(o),
                        t.scene.add(o),
                        {
                          img: e,
                          mesh: o,
                          top: n.top,
                          left: n.left,
                          width: n.width,
                          height: n.height,
                        }
                      )
                    }))
                },
              },
              {
                key: 'setImagesPositions',
                value: function () {
                  var t = this
                  this.imagesStore.forEach(function (e) {
                    var n = e.img.getBoundingClientRect()
                    ;(e.mesh.position.y = n.top - t.height / 2 + n.height / 2),
                      (e.mesh.position.x = n.left - t.width / 2 + n.width / 2),
                      (e.mesh.material.uniforms.time.value = t.time),
                      (e.mesh.material.uniforms.uStrength.value =
                        t.slider.scroll.delta)
                  })
                },
              },
              {
                key: 'setImagesSizes',
                value: function () {
                  var t = this
                  this.imagesStore.forEach(function (e) {
                    var n = e.img.getBoundingClientRect()
                    ;(e.width = n.width),
                      (e.height = n.height),
                      (e.mesh.material.uniforms.uPlaneSizes.value = [
                        e.width,
                        e.height,
                      ]),
                      (e.mesh.material.uniforms.uViewportSizes.value = [
                        t.width,
                        t.height,
                      ]),
                      e.mesh.scale.set(e.width, e.height, 1)
                  })
                },
              },
              {
                key: 'getParents',
                value: function (t) {
                  for (var e = []; t && t !== document; t = t.parentNode)
                    e.push(t)
                  return e
                },
              },
              {
                key: 'onDocumentTouchEnd',
                value: function (t) {
                  var e = !1
                  if (
                    (this.getParents(t.target).forEach(function (t, n) {
                      ;(t.classList.contains('header') ||
                        t.classList.contains('menu-mobile')) &&
                        (e = !0)
                    }),
                    0 == e)
                  ) {
                    t.preventDefault()
                    var n = new dl()
                    ;(n.x =
                      (t.changedTouches[0].clientX / window.innerWidth) * 2 -
                      1),
                      (n.y =
                        (-t.changedTouches[0].clientY / window.innerHeight) *
                          2 +
                        1),
                      this.raycaster.setFromCamera(n, this.camera)
                    var i = this.raycaster.intersectObjects(this.meshStore)
                    i.length > 0
                      ? this.intClick != i[0].object &&
                        ((this.intClick = i[0].object),
                        '' != this.intClick.link &&
                          window.open(this.intClick.link, '_blank').focus())
                      : (this.intClick = null)
                  }
                },
              },
              {
                key: 'findInt',
                value: function () {
                  this.raycaster.setFromCamera(this.mouse, this.camera)
                  var t = this.raycaster.intersectObjects(this.meshStore, !1)
                  t.length > 0
                    ? this.intClick != t[0].object &&
                      ((this.intClick = t[0].object),
                      '' != this.intClick.link &&
                        window.open(this.intClick.link, '_blank').focus())
                    : (this.intClick = null)
                },
              },
              {
                key: 'hoverEffect',
                value: function () {
                  var t = this
                  if (window.matchMedia('(min-width: 992px)').matches) {
                    this.raycaster.setFromCamera(this.mouse, this.camera)
                    var e = this.raycaster.intersectObjects(this.meshStore, !1)
                    e.length > 0
                      ? this.int != e[0].object &&
                        ((this.int = e[0].object),
                        0 == this.ani &&
                          ((this.ani = !0),
                          document.body.classList.add('pointer'),
                          _i.set('.gmarquee__txt span', {
                            innerHTML: this.int.title,
                          }),
                          this.imagesStore.forEach(function (e) {
                            e.mesh.uuid != t.int.uuid &&
                              _i.to(e.mesh.material.uniforms.hoverState, {
                                duration: 0.25,
                                value: 0.35,
                                overwrite: !0,
                                ease: 'power3.out',
                              })
                          }),
                          setTimeout(
                            function () {
                              ;(this.int = null), (this.ani = !1)
                            }.bind(this),
                            250,
                          )))
                      : null != this.int &&
                        (document.body.classList.remove('pointer'),
                        _i.set('.gmarquee__txt span', { innerHTML: 'SCROLL' }),
                        this.imagesStore.forEach(function (t) {
                          _i.to(t.mesh.material.uniforms.hoverState, {
                            duration: 0.25,
                            value: 1,
                            overwrite: !0,
                            ease: 'power3.out',
                          })
                        }),
                        (this.int = null))
                  } else
                    _i.set('.gmarquee__txt span', { innerHTML: 'COMING SOON' })
                },
              },
              {
                key: 'render',
                value: function () {
                  ;(this.time += 0.015),
                    (this.material.uniforms.time.value = this.time),
                    this.renderer.render(this.scene, this.camera),
                    this.setImagesPositions(),
                    this.hoverEffect(),
                    this.updatingPerspective &&
                      (this.updatePerspective(),
                      (this.updatingPerspective = !1)),
                    (this.raf = window.requestAnimationFrame(
                      this.render.bind(this),
                    ))
                },
              },
            ]),
            t
          )
        })()
      function d_(t, e) {
        var n = t.__state.conversionName.toString(),
          i = Math.round(t.r),
          r = Math.round(t.g),
          s = Math.round(t.b),
          o = t.a,
          a = Math.round(t.h),
          l = t.s.toFixed(1),
          c = t.v.toFixed(1)
        if (e || 'THREE_CHAR_HEX' === n || 'SIX_CHAR_HEX' === n) {
          for (var u = t.hex.toString(16); u.length < 6; ) u = '0' + u
          return '#' + u
        }
        return 'CSS_RGB' === n
          ? 'rgb(' + i + ',' + r + ',' + s + ')'
          : 'CSS_RGBA' === n
          ? 'rgba(' + i + ',' + r + ',' + s + ',' + o + ')'
          : 'HEX' === n
          ? '0x' + t.hex.toString(16)
          : 'RGB_ARRAY' === n
          ? '[' + i + ',' + r + ',' + s + ']'
          : 'RGBA_ARRAY' === n
          ? '[' + i + ',' + r + ',' + s + ',' + o + ']'
          : 'RGB_OBJ' === n
          ? '{r:' + i + ',g:' + r + ',b:' + s + '}'
          : 'RGBA_OBJ' === n
          ? '{r:' + i + ',g:' + r + ',b:' + s + ',a:' + o + '}'
          : 'HSV_OBJ' === n
          ? '{h:' + a + ',s:' + l + ',v:' + c + '}'
          : 'HSVA_OBJ' === n
          ? '{h:' + a + ',s:' + l + ',v:' + c + ',a:' + o + '}'
          : 'unknown format'
      }
      var p_ = Array.prototype.forEach,
        f_ = Array.prototype.slice,
        m_ = {
          BREAK: {},
          extend: function (t) {
            return (
              this.each(
                f_.call(arguments, 1),
                function (e) {
                  ;(this.isObject(e) ? Object.keys(e) : []).forEach(
                    function (n) {
                      this.isUndefined(e[n]) || (t[n] = e[n])
                    }.bind(this),
                  )
                },
                this,
              ),
              t
            )
          },
          defaults: function (t) {
            return (
              this.each(
                f_.call(arguments, 1),
                function (e) {
                  ;(this.isObject(e) ? Object.keys(e) : []).forEach(
                    function (n) {
                      this.isUndefined(t[n]) && (t[n] = e[n])
                    }.bind(this),
                  )
                },
                this,
              ),
              t
            )
          },
          compose: function () {
            var t = f_.call(arguments)
            return function () {
              for (var e = f_.call(arguments), n = t.length - 1; n >= 0; n--)
                e = [t[n].apply(this, e)]
              return e[0]
            }
          },
          each: function (t, e, n) {
            if (t)
              if (p_ && t.forEach && t.forEach === p_) t.forEach(e, n)
              else if (t.length === t.length + 0) {
                var i,
                  r = void 0
                for (r = 0, i = t.length; r < i; r++)
                  if (r in t && e.call(n, t[r], r) === this.BREAK) return
              } else
                for (var s in t) if (e.call(n, t[s], s) === this.BREAK) return
          },
          defer: function (t) {
            setTimeout(t, 0)
          },
          debounce: function (t, e, n) {
            var i = void 0
            return function () {
              var r = this,
                s = arguments
              function o() {
                ;(i = null), n || t.apply(r, s)
              }
              var a = n || !i
              clearTimeout(i), (i = setTimeout(o, e)), a && t.apply(r, s)
            }
          },
          toArray: function (t) {
            return t.toArray ? t.toArray() : f_.call(t)
          },
          isUndefined: function (t) {
            return void 0 === t
          },
          isNull: function (t) {
            return null === t
          },
          isNaN: (function (t) {
            function e(e) {
              return t.apply(this, arguments)
            }
            return (
              (e.toString = function () {
                return t.toString()
              }),
              e
            )
          })(function (t) {
            return isNaN(t)
          }),
          isArray:
            Array.isArray ||
            function (t) {
              return t.constructor === Array
            },
          isObject: function (t) {
            return t === Object(t)
          },
          isNumber: function (t) {
            return t === t + 0
          },
          isString: function (t) {
            return t === t + ''
          },
          isBoolean: function (t) {
            return !1 === t || !0 === t
          },
          isFunction: function (t) {
            return t instanceof Function
          },
        },
        g_ = [
          {
            litmus: m_.isString,
            conversions: {
              THREE_CHAR_HEX: {
                read: function (t) {
                  var e = t.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i)
                  return (
                    null !== e && {
                      space: 'HEX',
                      hex: parseInt(
                        '0x' +
                          e[1].toString() +
                          e[1].toString() +
                          e[2].toString() +
                          e[2].toString() +
                          e[3].toString() +
                          e[3].toString(),
                        0,
                      ),
                    }
                  )
                },
                write: d_,
              },
              SIX_CHAR_HEX: {
                read: function (t) {
                  var e = t.match(/^#([A-F0-9]{6})$/i)
                  return (
                    null !== e && {
                      space: 'HEX',
                      hex: parseInt('0x' + e[1].toString(), 0),
                    }
                  )
                },
                write: d_,
              },
              CSS_RGB: {
                read: function (t) {
                  var e = t.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/)
                  return (
                    null !== e && {
                      space: 'RGB',
                      r: parseFloat(e[1]),
                      g: parseFloat(e[2]),
                      b: parseFloat(e[3]),
                    }
                  )
                },
                write: d_,
              },
              CSS_RGBA: {
                read: function (t) {
                  var e = t.match(
                    /^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/,
                  )
                  return (
                    null !== e && {
                      space: 'RGB',
                      r: parseFloat(e[1]),
                      g: parseFloat(e[2]),
                      b: parseFloat(e[3]),
                      a: parseFloat(e[4]),
                    }
                  )
                },
                write: d_,
              },
            },
          },
          {
            litmus: m_.isNumber,
            conversions: {
              HEX: {
                read: function (t) {
                  return { space: 'HEX', hex: t, conversionName: 'HEX' }
                },
                write: function (t) {
                  return t.hex
                },
              },
            },
          },
          {
            litmus: m_.isArray,
            conversions: {
              RGB_ARRAY: {
                read: function (t) {
                  return (
                    3 === t.length && {
                      space: 'RGB',
                      r: t[0],
                      g: t[1],
                      b: t[2],
                    }
                  )
                },
                write: function (t) {
                  return [t.r, t.g, t.b]
                },
              },
              RGBA_ARRAY: {
                read: function (t) {
                  return (
                    4 === t.length && {
                      space: 'RGB',
                      r: t[0],
                      g: t[1],
                      b: t[2],
                      a: t[3],
                    }
                  )
                },
                write: function (t) {
                  return [t.r, t.g, t.b, t.a]
                },
              },
            },
          },
          {
            litmus: m_.isObject,
            conversions: {
              RGBA_OBJ: {
                read: function (t) {
                  return (
                    !!(
                      m_.isNumber(t.r) &&
                      m_.isNumber(t.g) &&
                      m_.isNumber(t.b) &&
                      m_.isNumber(t.a)
                    ) && { space: 'RGB', r: t.r, g: t.g, b: t.b, a: t.a }
                  )
                },
                write: function (t) {
                  return { r: t.r, g: t.g, b: t.b, a: t.a }
                },
              },
              RGB_OBJ: {
                read: function (t) {
                  return (
                    !!(
                      m_.isNumber(t.r) &&
                      m_.isNumber(t.g) &&
                      m_.isNumber(t.b)
                    ) && { space: 'RGB', r: t.r, g: t.g, b: t.b }
                  )
                },
                write: function (t) {
                  return { r: t.r, g: t.g, b: t.b }
                },
              },
              HSVA_OBJ: {
                read: function (t) {
                  return (
                    !!(
                      m_.isNumber(t.h) &&
                      m_.isNumber(t.s) &&
                      m_.isNumber(t.v) &&
                      m_.isNumber(t.a)
                    ) && { space: 'HSV', h: t.h, s: t.s, v: t.v, a: t.a }
                  )
                },
                write: function (t) {
                  return { h: t.h, s: t.s, v: t.v, a: t.a }
                },
              },
              HSV_OBJ: {
                read: function (t) {
                  return (
                    !!(
                      m_.isNumber(t.h) &&
                      m_.isNumber(t.s) &&
                      m_.isNumber(t.v)
                    ) && { space: 'HSV', h: t.h, s: t.s, v: t.v }
                  )
                },
                write: function (t) {
                  return { h: t.h, s: t.s, v: t.v }
                },
              },
            },
          },
        ],
        v_ = void 0,
        __ = void 0,
        y_ = function () {
          __ = !1
          var t = arguments.length > 1 ? m_.toArray(arguments) : arguments[0]
          return (
            m_.each(g_, function (e) {
              if (e.litmus(t))
                return (
                  m_.each(e.conversions, function (e, n) {
                    if (((v_ = e.read(t)), !1 === __ && !1 !== v_))
                      return (
                        (__ = v_),
                        (v_.conversionName = n),
                        (v_.conversion = e),
                        m_.BREAK
                      )
                  }),
                  m_.BREAK
                )
            }),
            __
          )
        },
        x_ = void 0,
        b_ = {
          hsv_to_rgb: function (t, e, n) {
            var i = Math.floor(t / 60) % 6,
              r = t / 60 - Math.floor(t / 60),
              s = n * (1 - e),
              o = n * (1 - r * e),
              a = n * (1 - (1 - r) * e),
              l = [
                [n, a, s],
                [o, n, s],
                [s, n, a],
                [s, o, n],
                [a, s, n],
                [n, s, o],
              ][i]
            return { r: 255 * l[0], g: 255 * l[1], b: 255 * l[2] }
          },
          rgb_to_hsv: function (t, e, n) {
            var i = Math.min(t, e, n),
              r = Math.max(t, e, n),
              s = r - i,
              o = void 0
            return 0 === r
              ? { h: NaN, s: 0, v: 0 }
              : ((o =
                  t === r
                    ? (e - n) / s
                    : e === r
                    ? 2 + (n - t) / s
                    : 4 + (t - e) / s),
                (o /= 6) < 0 && (o += 1),
                { h: 360 * o, s: s / r, v: r / 255 })
          },
          rgb_to_hex: function (t, e, n) {
            var i = this.hex_with_component(0, 2, t)
            return (
              (i = this.hex_with_component(i, 1, e)),
              this.hex_with_component(i, 0, n)
            )
          },
          component_from_hex: function (t, e) {
            return (t >> (8 * e)) & 255
          },
          hex_with_component: function (t, e, n) {
            return (n << (x_ = 8 * e)) | (t & ~(255 << x_))
          },
        },
        w_ =
          'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
            ? function (t) {
                return typeof t
              }
            : function (t) {
                return t &&
                  'function' == typeof Symbol &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t
              },
        M_ = function (t, e) {
          if (!(t instanceof e))
            throw new TypeError('Cannot call a class as a function')
        },
        S_ = (function () {
          function t(t, e) {
            for (var n = 0; n < e.length; n++) {
              var i = e[n]
              ;(i.enumerable = i.enumerable || !1),
                (i.configurable = !0),
                'value' in i && (i.writable = !0),
                Object.defineProperty(t, i.key, i)
            }
          }
          return function (e, n, i) {
            return n && t(e.prototype, n), i && t(e, i), e
          }
        })(),
        T_ = function t(e, n, i) {
          null === e && (e = Function.prototype)
          var r = Object.getOwnPropertyDescriptor(e, n)
          if (void 0 === r) {
            var s = Object.getPrototypeOf(e)
            return null === s ? void 0 : t(s, n, i)
          }
          if ('value' in r) return r.value
          var o = r.get
          return void 0 !== o ? o.call(i) : void 0
        },
        E_ = function (t, e) {
          if ('function' != typeof e && null !== e)
            throw new TypeError(
              'Super expression must either be null or a function, not ' +
                typeof e,
            )
          ;(t.prototype = Object.create(e && e.prototype, {
            constructor: {
              value: t,
              enumerable: !1,
              writable: !0,
              configurable: !0,
            },
          })),
            e &&
              (Object.setPrototypeOf
                ? Object.setPrototypeOf(t, e)
                : (t.__proto__ = e))
        },
        D_ = function (t, e) {
          if (!t)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called",
            )
          return !e || ('object' != typeof e && 'function' != typeof e) ? t : e
        },
        A_ = (function () {
          function t() {
            if (
              (M_(this, t),
              (this.__state = y_.apply(this, arguments)),
              !1 === this.__state)
            )
              throw new Error('Failed to interpret color arguments')
            this.__state.a = this.__state.a || 1
          }
          return (
            S_(t, [
              {
                key: 'toString',
                value: function () {
                  return d_(this)
                },
              },
              {
                key: 'toHexString',
                value: function () {
                  return d_(this, !0)
                },
              },
              {
                key: 'toOriginal',
                value: function () {
                  return this.__state.conversion.write(this)
                },
              },
            ]),
            t
          )
        })()
      function C_(t, e, n) {
        Object.defineProperty(t, e, {
          get: function () {
            return (
              'RGB' === this.__state.space || A_.recalculateRGB(this, e, n),
              this.__state[e]
            )
          },
          set: function (t) {
            'RGB' !== this.__state.space &&
              (A_.recalculateRGB(this, e, n), (this.__state.space = 'RGB')),
              (this.__state[e] = t)
          },
        })
      }
      function L_(t, e) {
        Object.defineProperty(t, e, {
          get: function () {
            return (
              'HSV' === this.__state.space || A_.recalculateHSV(this),
              this.__state[e]
            )
          },
          set: function (t) {
            'HSV' !== this.__state.space &&
              (A_.recalculateHSV(this), (this.__state.space = 'HSV')),
              (this.__state[e] = t)
          },
        })
      }
      ;(A_.recalculateRGB = function (t, e, n) {
        if ('HEX' === t.__state.space)
          t.__state[e] = b_.component_from_hex(t.__state.hex, n)
        else {
          if ('HSV' !== t.__state.space)
            throw new Error('Corrupted color state')
          m_.extend(
            t.__state,
            b_.hsv_to_rgb(t.__state.h, t.__state.s, t.__state.v),
          )
        }
      }),
        (A_.recalculateHSV = function (t) {
          var e = b_.rgb_to_hsv(t.r, t.g, t.b)
          m_.extend(t.__state, { s: e.s, v: e.v }),
            m_.isNaN(e.h)
              ? m_.isUndefined(t.__state.h) && (t.__state.h = 0)
              : (t.__state.h = e.h)
        }),
        (A_.COMPONENTS = ['r', 'g', 'b', 'h', 's', 'v', 'hex', 'a']),
        C_(A_.prototype, 'r', 2),
        C_(A_.prototype, 'g', 1),
        C_(A_.prototype, 'b', 0),
        L_(A_.prototype, 'h'),
        L_(A_.prototype, 's'),
        L_(A_.prototype, 'v'),
        Object.defineProperty(A_.prototype, 'a', {
          get: function () {
            return this.__state.a
          },
          set: function (t) {
            this.__state.a = t
          },
        }),
        Object.defineProperty(A_.prototype, 'hex', {
          get: function () {
            return (
              'HEX' !== this.__state.space &&
                ((this.__state.hex = b_.rgb_to_hex(this.r, this.g, this.b)),
                (this.__state.space = 'HEX')),
              this.__state.hex
            )
          },
          set: function (t) {
            ;(this.__state.space = 'HEX'), (this.__state.hex = t)
          },
        })
      var R_ = (function () {
          function t(e, n) {
            M_(this, t),
              (this.initialValue = e[n]),
              (this.domElement = document.createElement('div')),
              (this.object = e),
              (this.property = n),
              (this.__onChange = void 0),
              (this.__onFinishChange = void 0)
          }
          return (
            S_(t, [
              {
                key: 'onChange',
                value: function (t) {
                  return (this.__onChange = t), this
                },
              },
              {
                key: 'onFinishChange',
                value: function (t) {
                  return (this.__onFinishChange = t), this
                },
              },
              {
                key: 'setValue',
                value: function (t) {
                  return (
                    (this.object[this.property] = t),
                    this.__onChange && this.__onChange.call(this, t),
                    this.updateDisplay(),
                    this
                  )
                },
              },
              {
                key: 'getValue',
                value: function () {
                  return this.object[this.property]
                },
              },
              {
                key: 'updateDisplay',
                value: function () {
                  return this
                },
              },
              {
                key: 'isModified',
                value: function () {
                  return this.initialValue !== this.getValue()
                },
              },
            ]),
            t
          )
        })(),
        P_ = {}
      m_.each(
        {
          HTMLEvents: ['change'],
          MouseEvents: [
            'click',
            'mousemove',
            'mousedown',
            'mouseup',
            'mouseover',
          ],
          KeyboardEvents: ['keydown'],
        },
        function (t, e) {
          m_.each(t, function (t) {
            P_[t] = e
          })
        },
      )
      var F_ = /(\d+(\.\d+)?)px/
      function I_(t) {
        if ('0' === t || m_.isUndefined(t)) return 0
        var e = t.match(F_)
        return m_.isNull(e) ? 0 : parseFloat(e[1])
      }
      var O_ = {
          makeSelectable: function (t, e) {
            void 0 !== t &&
              void 0 !== t.style &&
              ((t.onselectstart = e
                ? function () {
                    return !1
                  }
                : function () {}),
              (t.style.MozUserSelect = e ? 'auto' : 'none'),
              (t.style.KhtmlUserSelect = e ? 'auto' : 'none'),
              (t.unselectable = e ? 'on' : 'off'))
          },
          makeFullscreen: function (t, e, n) {
            var i = n,
              r = e
            m_.isUndefined(r) && (r = !0),
              m_.isUndefined(i) && (i = !0),
              (t.style.position = 'absolute'),
              r && ((t.style.left = 0), (t.style.right = 0)),
              i && ((t.style.top = 0), (t.style.bottom = 0))
          },
          fakeEvent: function (t, e, n, i) {
            var r = n || {},
              s = P_[e]
            if (!s) throw new Error('Event type ' + e + ' not supported.')
            var o = document.createEvent(s)
            switch (s) {
              case 'MouseEvents':
                var a = r.x || r.clientX || 0,
                  l = r.y || r.clientY || 0
                o.initMouseEvent(
                  e,
                  r.bubbles || !1,
                  r.cancelable || !0,
                  window,
                  r.clickCount || 1,
                  0,
                  0,
                  a,
                  l,
                  !1,
                  !1,
                  !1,
                  !1,
                  0,
                  null,
                )
                break
              case 'KeyboardEvents':
                var c = o.initKeyboardEvent || o.initKeyEvent
                m_.defaults(r, {
                  cancelable: !0,
                  ctrlKey: !1,
                  altKey: !1,
                  shiftKey: !1,
                  metaKey: !1,
                  keyCode: void 0,
                  charCode: void 0,
                }),
                  c(
                    e,
                    r.bubbles || !1,
                    r.cancelable,
                    window,
                    r.ctrlKey,
                    r.altKey,
                    r.shiftKey,
                    r.metaKey,
                    r.keyCode,
                    r.charCode,
                  )
                break
              default:
                o.initEvent(e, r.bubbles || !1, r.cancelable || !0)
            }
            m_.defaults(o, i), t.dispatchEvent(o)
          },
          bind: function (t, e, n, i) {
            var r = i || !1
            return (
              t.addEventListener
                ? t.addEventListener(e, n, r)
                : t.attachEvent && t.attachEvent('on' + e, n),
              O_
            )
          },
          unbind: function (t, e, n, i) {
            var r = i || !1
            return (
              t.removeEventListener
                ? t.removeEventListener(e, n, r)
                : t.detachEvent && t.detachEvent('on' + e, n),
              O_
            )
          },
          addClass: function (t, e) {
            if (void 0 === t.className) t.className = e
            else if (t.className !== e) {
              var n = t.className.split(/ +/)
              ;-1 === n.indexOf(e) &&
                (n.push(e),
                (t.className = n
                  .join(' ')
                  .replace(/^\s+/, '')
                  .replace(/\s+$/, '')))
            }
            return O_
          },
          removeClass: function (t, e) {
            if (e)
              if (t.className === e) t.removeAttribute('class')
              else {
                var n = t.className.split(/ +/),
                  i = n.indexOf(e)
                ;-1 !== i && (n.splice(i, 1), (t.className = n.join(' ')))
              }
            else t.className = void 0
            return O_
          },
          hasClass: function (t, e) {
            return (
              new RegExp('(?:^|\\s+)' + e + '(?:\\s+|$)').test(t.className) ||
              !1
            )
          },
          getWidth: function (t) {
            var e = getComputedStyle(t)
            return (
              I_(e['border-left-width']) +
              I_(e['border-right-width']) +
              I_(e['padding-left']) +
              I_(e['padding-right']) +
              I_(e.width)
            )
          },
          getHeight: function (t) {
            var e = getComputedStyle(t)
            return (
              I_(e['border-top-width']) +
              I_(e['border-bottom-width']) +
              I_(e['padding-top']) +
              I_(e['padding-bottom']) +
              I_(e.height)
            )
          },
          getOffset: function (t) {
            var e = t,
              n = { left: 0, top: 0 }
            if (e.offsetParent)
              do {
                ;(n.left += e.offsetLeft),
                  (n.top += e.offsetTop),
                  (e = e.offsetParent)
              } while (e)
            return n
          },
          isActive: function (t) {
            return t === document.activeElement && (t.type || t.href)
          },
        },
        N_ = (function (t) {
          function e(t, n) {
            M_(this, e)
            var i = D_(
                this,
                (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n),
              ),
              r = i
            return (
              (i.__prev = i.getValue()),
              (i.__checkbox = document.createElement('input')),
              i.__checkbox.setAttribute('type', 'checkbox'),
              O_.bind(
                i.__checkbox,
                'change',
                function () {
                  r.setValue(!r.__prev)
                },
                !1,
              ),
              i.domElement.appendChild(i.__checkbox),
              i.updateDisplay(),
              i
            )
          }
          return (
            E_(e, t),
            S_(e, [
              {
                key: 'setValue',
                value: function (t) {
                  var n = T_(
                    e.prototype.__proto__ || Object.getPrototypeOf(e.prototype),
                    'setValue',
                    this,
                  ).call(this, t)
                  return (
                    this.__onFinishChange &&
                      this.__onFinishChange.call(this, this.getValue()),
                    (this.__prev = this.getValue()),
                    n
                  )
                },
              },
              {
                key: 'updateDisplay',
                value: function () {
                  return (
                    !0 === this.getValue()
                      ? (this.__checkbox.setAttribute('checked', 'checked'),
                        (this.__checkbox.checked = !0),
                        (this.__prev = !0))
                      : ((this.__checkbox.checked = !1), (this.__prev = !1)),
                    T_(
                      e.prototype.__proto__ ||
                        Object.getPrototypeOf(e.prototype),
                      'updateDisplay',
                      this,
                    ).call(this)
                  )
                },
              },
            ]),
            e
          )
        })(R_),
        k_ = (function (t) {
          function e(t, n, i) {
            M_(this, e)
            var r = D_(
                this,
                (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n),
              ),
              s = i,
              o = r
            if (
              ((r.__select = document.createElement('select')), m_.isArray(s))
            ) {
              var a = {}
              m_.each(s, function (t) {
                a[t] = t
              }),
                (s = a)
            }
            return (
              m_.each(s, function (t, e) {
                var n = document.createElement('option')
                ;(n.innerHTML = e),
                  n.setAttribute('value', t),
                  o.__select.appendChild(n)
              }),
              r.updateDisplay(),
              O_.bind(r.__select, 'change', function () {
                var t = this.options[this.selectedIndex].value
                o.setValue(t)
              }),
              r.domElement.appendChild(r.__select),
              r
            )
          }
          return (
            E_(e, t),
            S_(e, [
              {
                key: 'setValue',
                value: function (t) {
                  var n = T_(
                    e.prototype.__proto__ || Object.getPrototypeOf(e.prototype),
                    'setValue',
                    this,
                  ).call(this, t)
                  return (
                    this.__onFinishChange &&
                      this.__onFinishChange.call(this, this.getValue()),
                    n
                  )
                },
              },
              {
                key: 'updateDisplay',
                value: function () {
                  return O_.isActive(this.__select)
                    ? this
                    : ((this.__select.value = this.getValue()),
                      T_(
                        e.prototype.__proto__ ||
                          Object.getPrototypeOf(e.prototype),
                        'updateDisplay',
                        this,
                      ).call(this))
                },
              },
            ]),
            e
          )
        })(R_),
        B_ = (function (t) {
          function e(t, n) {
            M_(this, e)
            var i = D_(
                this,
                (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n),
              ),
              r = i
            function s() {
              r.setValue(r.__input.value)
            }
            return (
              (i.__input = document.createElement('input')),
              i.__input.setAttribute('type', 'text'),
              O_.bind(i.__input, 'keyup', s),
              O_.bind(i.__input, 'change', s),
              O_.bind(i.__input, 'blur', function () {
                r.__onFinishChange && r.__onFinishChange.call(r, r.getValue())
              }),
              O_.bind(i.__input, 'keydown', function (t) {
                13 === t.keyCode && this.blur()
              }),
              i.updateDisplay(),
              i.domElement.appendChild(i.__input),
              i
            )
          }
          return (
            E_(e, t),
            S_(e, [
              {
                key: 'updateDisplay',
                value: function () {
                  return (
                    O_.isActive(this.__input) ||
                      (this.__input.value = this.getValue()),
                    T_(
                      e.prototype.__proto__ ||
                        Object.getPrototypeOf(e.prototype),
                      'updateDisplay',
                      this,
                    ).call(this)
                  )
                },
              },
            ]),
            e
          )
        })(R_)
      function z_(t) {
        var e = t.toString()
        return e.indexOf('.') > -1 ? e.length - e.indexOf('.') - 1 : 0
      }
      var U_ = (function (t) {
          function e(t, n, i) {
            M_(this, e)
            var r = D_(
                this,
                (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n),
              ),
              s = i || {}
            return (
              (r.__min = s.min),
              (r.__max = s.max),
              (r.__step = s.step),
              m_.isUndefined(r.__step)
                ? 0 === r.initialValue
                  ? (r.__impliedStep = 1)
                  : (r.__impliedStep =
                      Math.pow(
                        10,
                        Math.floor(
                          Math.log(Math.abs(r.initialValue)) / Math.LN10,
                        ),
                      ) / 10)
                : (r.__impliedStep = r.__step),
              (r.__precision = z_(r.__impliedStep)),
              r
            )
          }
          return (
            E_(e, t),
            S_(e, [
              {
                key: 'setValue',
                value: function (t) {
                  var n = t
                  return (
                    void 0 !== this.__min && n < this.__min
                      ? (n = this.__min)
                      : void 0 !== this.__max &&
                        n > this.__max &&
                        (n = this.__max),
                    void 0 !== this.__step &&
                      n % this.__step != 0 &&
                      (n = Math.round(n / this.__step) * this.__step),
                    T_(
                      e.prototype.__proto__ ||
                        Object.getPrototypeOf(e.prototype),
                      'setValue',
                      this,
                    ).call(this, n)
                  )
                },
              },
              {
                key: 'min',
                value: function (t) {
                  return (this.__min = t), this
                },
              },
              {
                key: 'max',
                value: function (t) {
                  return (this.__max = t), this
                },
              },
              {
                key: 'step',
                value: function (t) {
                  return (
                    (this.__step = t),
                    (this.__impliedStep = t),
                    (this.__precision = z_(t)),
                    this
                  )
                },
              },
            ]),
            e
          )
        })(R_),
        H_ = (function (t) {
          function e(t, n, i) {
            M_(this, e)
            var r = D_(
              this,
              (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n, i),
            )
            r.__truncationSuspended = !1
            var s = r,
              o = void 0
            function a() {
              s.__onFinishChange && s.__onFinishChange.call(s, s.getValue())
            }
            function l(t) {
              var e = o - t.clientY
              s.setValue(s.getValue() + e * s.__impliedStep), (o = t.clientY)
            }
            function c() {
              O_.unbind(window, 'mousemove', l),
                O_.unbind(window, 'mouseup', c),
                a()
            }
            return (
              (r.__input = document.createElement('input')),
              r.__input.setAttribute('type', 'text'),
              O_.bind(r.__input, 'change', function () {
                var t = parseFloat(s.__input.value)
                m_.isNaN(t) || s.setValue(t)
              }),
              O_.bind(r.__input, 'blur', function () {
                a()
              }),
              O_.bind(r.__input, 'mousedown', function (t) {
                O_.bind(window, 'mousemove', l),
                  O_.bind(window, 'mouseup', c),
                  (o = t.clientY)
              }),
              O_.bind(r.__input, 'keydown', function (t) {
                13 === t.keyCode &&
                  ((s.__truncationSuspended = !0),
                  this.blur(),
                  (s.__truncationSuspended = !1),
                  a())
              }),
              r.updateDisplay(),
              r.domElement.appendChild(r.__input),
              r
            )
          }
          return (
            E_(e, t),
            S_(e, [
              {
                key: 'updateDisplay',
                value: function () {
                  var t, n, i
                  return (
                    (this.__input.value = this.__truncationSuspended
                      ? this.getValue()
                      : ((t = this.getValue()),
                        (n = this.__precision),
                        (i = Math.pow(10, n)),
                        Math.round(t * i) / i)),
                    T_(
                      e.prototype.__proto__ ||
                        Object.getPrototypeOf(e.prototype),
                      'updateDisplay',
                      this,
                    ).call(this)
                  )
                },
              },
            ]),
            e
          )
        })(U_)
      function G_(t, e, n, i, r) {
        return i + ((t - e) / (n - e)) * (r - i)
      }
      var V_ = (function (t) {
          function e(t, n, i, r, s) {
            M_(this, e)
            var o = D_(
                this,
                (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n, {
                  min: i,
                  max: r,
                  step: s,
                }),
              ),
              a = o
            function l(t) {
              t.preventDefault()
              var e = a.__background.getBoundingClientRect()
              return (
                a.setValue(G_(t.clientX, e.left, e.right, a.__min, a.__max)), !1
              )
            }
            function c() {
              O_.unbind(window, 'mousemove', l),
                O_.unbind(window, 'mouseup', c),
                a.__onFinishChange && a.__onFinishChange.call(a, a.getValue())
            }
            function u(t) {
              var e = t.touches[0].clientX,
                n = a.__background.getBoundingClientRect()
              a.setValue(G_(e, n.left, n.right, a.__min, a.__max))
            }
            function h() {
              O_.unbind(window, 'touchmove', u),
                O_.unbind(window, 'touchend', h),
                a.__onFinishChange && a.__onFinishChange.call(a, a.getValue())
            }
            return (
              (o.__background = document.createElement('div')),
              (o.__foreground = document.createElement('div')),
              O_.bind(o.__background, 'mousedown', function (t) {
                document.activeElement.blur(),
                  O_.bind(window, 'mousemove', l),
                  O_.bind(window, 'mouseup', c),
                  l(t)
              }),
              O_.bind(o.__background, 'touchstart', function (t) {
                1 === t.touches.length &&
                  (O_.bind(window, 'touchmove', u),
                  O_.bind(window, 'touchend', h),
                  u(t))
              }),
              O_.addClass(o.__background, 'slider'),
              O_.addClass(o.__foreground, 'slider-fg'),
              o.updateDisplay(),
              o.__background.appendChild(o.__foreground),
              o.domElement.appendChild(o.__background),
              o
            )
          }
          return (
            E_(e, t),
            S_(e, [
              {
                key: 'updateDisplay',
                value: function () {
                  var t =
                    (this.getValue() - this.__min) / (this.__max - this.__min)
                  return (
                    (this.__foreground.style.width = 100 * t + '%'),
                    T_(
                      e.prototype.__proto__ ||
                        Object.getPrototypeOf(e.prototype),
                      'updateDisplay',
                      this,
                    ).call(this)
                  )
                },
              },
            ]),
            e
          )
        })(U_),
        W_ = (function (t) {
          function e(t, n, i) {
            M_(this, e)
            var r = D_(
                this,
                (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n),
              ),
              s = r
            return (
              (r.__button = document.createElement('div')),
              (r.__button.innerHTML = void 0 === i ? 'Fire' : i),
              O_.bind(r.__button, 'click', function (t) {
                return t.preventDefault(), s.fire(), !1
              }),
              O_.addClass(r.__button, 'button'),
              r.domElement.appendChild(r.__button),
              r
            )
          }
          return (
            E_(e, t),
            S_(e, [
              {
                key: 'fire',
                value: function () {
                  this.__onChange && this.__onChange.call(this),
                    this.getValue().call(this.object),
                    this.__onFinishChange &&
                      this.__onFinishChange.call(this, this.getValue())
                },
              },
            ]),
            e
          )
        })(R_),
        j_ = (function (t) {
          function e(t, n) {
            M_(this, e)
            var i = D_(
              this,
              (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n),
            )
            ;(i.__color = new A_(i.getValue())), (i.__temp = new A_(0))
            var r = i
            ;(i.domElement = document.createElement('div')),
              O_.makeSelectable(i.domElement, !1),
              (i.__selector = document.createElement('div')),
              (i.__selector.className = 'selector'),
              (i.__saturation_field = document.createElement('div')),
              (i.__saturation_field.className = 'saturation-field'),
              (i.__field_knob = document.createElement('div')),
              (i.__field_knob.className = 'field-knob'),
              (i.__field_knob_border = '2px solid '),
              (i.__hue_knob = document.createElement('div')),
              (i.__hue_knob.className = 'hue-knob'),
              (i.__hue_field = document.createElement('div')),
              (i.__hue_field.className = 'hue-field'),
              (i.__input = document.createElement('input')),
              (i.__input.type = 'text'),
              (i.__input_textShadow = '0 1px 1px '),
              O_.bind(i.__input, 'keydown', function (t) {
                13 === t.keyCode && h.call(this)
              }),
              O_.bind(i.__input, 'blur', h),
              O_.bind(i.__selector, 'mousedown', function () {
                O_.addClass(this, 'drag').bind(window, 'mouseup', function () {
                  O_.removeClass(r.__selector, 'drag')
                })
              }),
              O_.bind(i.__selector, 'touchstart', function () {
                O_.addClass(this, 'drag').bind(window, 'touchend', function () {
                  O_.removeClass(r.__selector, 'drag')
                })
              })
            var s,
              o = document.createElement('div')
            function a(t) {
              p(t),
                O_.bind(window, 'mousemove', p),
                O_.bind(window, 'touchmove', p),
                O_.bind(window, 'mouseup', c),
                O_.bind(window, 'touchend', c)
            }
            function l(t) {
              f(t),
                O_.bind(window, 'mousemove', f),
                O_.bind(window, 'touchmove', f),
                O_.bind(window, 'mouseup', u),
                O_.bind(window, 'touchend', u)
            }
            function c() {
              O_.unbind(window, 'mousemove', p),
                O_.unbind(window, 'touchmove', p),
                O_.unbind(window, 'mouseup', c),
                O_.unbind(window, 'touchend', c),
                d()
            }
            function u() {
              O_.unbind(window, 'mousemove', f),
                O_.unbind(window, 'touchmove', f),
                O_.unbind(window, 'mouseup', u),
                O_.unbind(window, 'touchend', u),
                d()
            }
            function h() {
              var t = y_(this.value)
              !1 !== t
                ? ((r.__color.__state = t), r.setValue(r.__color.toOriginal()))
                : (this.value = r.__color.toString())
            }
            function d() {
              r.__onFinishChange &&
                r.__onFinishChange.call(r, r.__color.toOriginal())
            }
            function p(t) {
              ;-1 === t.type.indexOf('touch') && t.preventDefault()
              var e = r.__saturation_field.getBoundingClientRect(),
                n = (t.touches && t.touches[0]) || t,
                i = n.clientX,
                s = n.clientY,
                o = (i - e.left) / (e.right - e.left),
                a = 1 - (s - e.top) / (e.bottom - e.top)
              return (
                a > 1 ? (a = 1) : a < 0 && (a = 0),
                o > 1 ? (o = 1) : o < 0 && (o = 0),
                (r.__color.v = a),
                (r.__color.s = o),
                r.setValue(r.__color.toOriginal()),
                !1
              )
            }
            function f(t) {
              ;-1 === t.type.indexOf('touch') && t.preventDefault()
              var e = r.__hue_field.getBoundingClientRect(),
                n =
                  1 -
                  (((t.touches && t.touches[0]) || t).clientY - e.top) /
                    (e.bottom - e.top)
              return (
                n > 1 ? (n = 1) : n < 0 && (n = 0),
                (r.__color.h = 360 * n),
                r.setValue(r.__color.toOriginal()),
                !1
              )
            }
            return (
              m_.extend(i.__selector.style, {
                width: '122px',
                height: '102px',
                padding: '3px',
                backgroundColor: '#222',
                boxShadow: '0px 1px 3px rgba(0,0,0,0.3)',
              }),
              m_.extend(i.__field_knob.style, {
                position: 'absolute',
                width: '12px',
                height: '12px',
                border:
                  i.__field_knob_border + (i.__color.v < 0.5 ? '#fff' : '#000'),
                boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
                borderRadius: '12px',
                zIndex: 1,
              }),
              m_.extend(i.__hue_knob.style, {
                position: 'absolute',
                width: '15px',
                height: '2px',
                borderRight: '4px solid #fff',
                zIndex: 1,
              }),
              m_.extend(i.__saturation_field.style, {
                width: '100px',
                height: '100px',
                border: '1px solid #555',
                marginRight: '3px',
                display: 'inline-block',
                cursor: 'pointer',
              }),
              m_.extend(o.style, {
                width: '100%',
                height: '100%',
                background: 'none',
              }),
              X_(o, 'top', 'rgba(0,0,0,0)', '#000'),
              m_.extend(i.__hue_field.style, {
                width: '15px',
                height: '100px',
                border: '1px solid #555',
                cursor: 'ns-resize',
                position: 'absolute',
                top: '3px',
                right: '3px',
              }),
              ((s = i.__hue_field).style.background = ''),
              (s.style.cssText +=
                'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);'),
              (s.style.cssText +=
                'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'),
              (s.style.cssText +=
                'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'),
              (s.style.cssText +=
                'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'),
              (s.style.cssText +=
                'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'),
              m_.extend(i.__input.style, {
                outline: 'none',
                textAlign: 'center',
                color: '#fff',
                border: 0,
                fontWeight: 'bold',
                textShadow: i.__input_textShadow + 'rgba(0,0,0,0.7)',
              }),
              O_.bind(i.__saturation_field, 'mousedown', a),
              O_.bind(i.__saturation_field, 'touchstart', a),
              O_.bind(i.__field_knob, 'mousedown', a),
              O_.bind(i.__field_knob, 'touchstart', a),
              O_.bind(i.__hue_field, 'mousedown', l),
              O_.bind(i.__hue_field, 'touchstart', l),
              i.__saturation_field.appendChild(o),
              i.__selector.appendChild(i.__field_knob),
              i.__selector.appendChild(i.__saturation_field),
              i.__selector.appendChild(i.__hue_field),
              i.__hue_field.appendChild(i.__hue_knob),
              i.domElement.appendChild(i.__input),
              i.domElement.appendChild(i.__selector),
              i.updateDisplay(),
              i
            )
          }
          return (
            E_(e, t),
            S_(e, [
              {
                key: 'updateDisplay',
                value: function () {
                  var t = y_(this.getValue())
                  if (!1 !== t) {
                    var e = !1
                    m_.each(
                      A_.COMPONENTS,
                      function (n) {
                        if (
                          !m_.isUndefined(t[n]) &&
                          !m_.isUndefined(this.__color.__state[n]) &&
                          t[n] !== this.__color.__state[n]
                        )
                          return (e = !0), {}
                      },
                      this,
                    ),
                      e && m_.extend(this.__color.__state, t)
                  }
                  m_.extend(this.__temp.__state, this.__color.__state),
                    (this.__temp.a = 1)
                  var n =
                      this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0,
                    i = 255 - n
                  m_.extend(this.__field_knob.style, {
                    marginLeft: 100 * this.__color.s - 7 + 'px',
                    marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
                    backgroundColor: this.__temp.toHexString(),
                    border:
                      this.__field_knob_border +
                      'rgb(' +
                      n +
                      ',' +
                      n +
                      ',' +
                      n +
                      ')',
                  }),
                    (this.__hue_knob.style.marginTop =
                      100 * (1 - this.__color.h / 360) + 'px'),
                    (this.__temp.s = 1),
                    (this.__temp.v = 1),
                    X_(
                      this.__saturation_field,
                      'left',
                      '#fff',
                      this.__temp.toHexString(),
                    ),
                    (this.__input.value = this.__color.toString()),
                    m_.extend(this.__input.style, {
                      backgroundColor: this.__color.toHexString(),
                      color: 'rgb(' + n + ',' + n + ',' + n + ')',
                      textShadow:
                        this.__input_textShadow +
                        'rgba(' +
                        i +
                        ',' +
                        i +
                        ',' +
                        i +
                        ',.7)',
                    })
                },
              },
            ]),
            e
          )
        })(R_),
        q_ = ['-moz-', '-o-', '-webkit-', '-ms-', '']
      function X_(t, e, n, i) {
        ;(t.style.background = ''),
          m_.each(q_, function (r) {
            t.style.cssText +=
              'background: ' +
              r +
              'linear-gradient(' +
              e +
              ', ' +
              n +
              ' 0%, ' +
              i +
              ' 100%); '
          })
      }
      var Y_ =
          '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>',
        J_ = function (t, e) {
          var n = t[e]
          return m_.isArray(arguments[2]) || m_.isObject(arguments[2])
            ? new k_(t, e, arguments[2])
            : m_.isNumber(n)
            ? m_.isNumber(arguments[2]) && m_.isNumber(arguments[3])
              ? m_.isNumber(arguments[4])
                ? new V_(t, e, arguments[2], arguments[3], arguments[4])
                : new V_(t, e, arguments[2], arguments[3])
              : m_.isNumber(arguments[4])
              ? new H_(t, e, {
                  min: arguments[2],
                  max: arguments[3],
                  step: arguments[4],
                })
              : new H_(t, e, { min: arguments[2], max: arguments[3] })
            : m_.isString(n)
            ? new B_(t, e)
            : m_.isFunction(n)
            ? new W_(t, e, '')
            : m_.isBoolean(n)
            ? new N_(t, e)
            : null
        },
        Z_ =
          window.requestAnimationFrame ||
          window.webkitRequestAnimationFrame ||
          window.mozRequestAnimationFrame ||
          window.oRequestAnimationFrame ||
          window.msRequestAnimationFrame ||
          function (t) {
            setTimeout(t, 1e3 / 60)
          },
        K_ = (function () {
          function t() {
            M_(this, t),
              (this.backgroundElement = document.createElement('div')),
              m_.extend(this.backgroundElement.style, {
                backgroundColor: 'rgba(0,0,0,0.8)',
                top: 0,
                left: 0,
                display: 'none',
                zIndex: '1000',
                opacity: 0,
                WebkitTransition: 'opacity 0.2s linear',
                transition: 'opacity 0.2s linear',
              }),
              O_.makeFullscreen(this.backgroundElement),
              (this.backgroundElement.style.position = 'fixed'),
              (this.domElement = document.createElement('div')),
              m_.extend(this.domElement.style, {
                position: 'fixed',
                display: 'none',
                zIndex: '1001',
                opacity: 0,
                WebkitTransition:
                  '-webkit-transform 0.2s ease-out, opacity 0.2s linear',
                transition: 'transform 0.2s ease-out, opacity 0.2s linear',
              }),
              document.body.appendChild(this.backgroundElement),
              document.body.appendChild(this.domElement)
            var e = this
            O_.bind(this.backgroundElement, 'click', function () {
              e.hide()
            })
          }
          return (
            S_(t, [
              {
                key: 'show',
                value: function () {
                  var t = this
                  ;(this.backgroundElement.style.display = 'block'),
                    (this.domElement.style.display = 'block'),
                    (this.domElement.style.opacity = 0),
                    (this.domElement.style.webkitTransform = 'scale(1.1)'),
                    this.layout(),
                    m_.defer(function () {
                      ;(t.backgroundElement.style.opacity = 1),
                        (t.domElement.style.opacity = 1),
                        (t.domElement.style.webkitTransform = 'scale(1)')
                    })
                },
              },
              {
                key: 'hide',
                value: function () {
                  var t = this,
                    e = function e() {
                      ;(t.domElement.style.display = 'none'),
                        (t.backgroundElement.style.display = 'none'),
                        O_.unbind(t.domElement, 'webkitTransitionEnd', e),
                        O_.unbind(t.domElement, 'transitionend', e),
                        O_.unbind(t.domElement, 'oTransitionEnd', e)
                    }
                  O_.bind(this.domElement, 'webkitTransitionEnd', e),
                    O_.bind(this.domElement, 'transitionend', e),
                    O_.bind(this.domElement, 'oTransitionEnd', e),
                    (this.backgroundElement.style.opacity = 0),
                    (this.domElement.style.opacity = 0),
                    (this.domElement.style.webkitTransform = 'scale(1.1)')
                },
              },
              {
                key: 'layout',
                value: function () {
                  ;(this.domElement.style.left =
                    window.innerWidth / 2 -
                    O_.getWidth(this.domElement) / 2 +
                    'px'),
                    (this.domElement.style.top =
                      window.innerHeight / 2 -
                      O_.getHeight(this.domElement) / 2 +
                      'px')
                },
              },
            ]),
            t
          )
        })()
      !(function (t, e) {
        var n = e || document,
          i = document.createElement('style')
        ;(i.type = 'text/css'), (i.innerHTML = t)
        var r = n.getElementsByTagName('head')[0]
        try {
          r.appendChild(i)
        } catch (t) {}
      })(
        (function (t) {
          if ('undefined' != typeof window) {
            var e = document.createElement('style')
            return (
              e.setAttribute('type', 'text/css'),
              (e.innerHTML = t),
              document.head.appendChild(e),
              t
            )
          }
        })(
          ".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n",
        ),
      )
      var Q_ = 'Default',
        $_ = (function () {
          try {
            return !!window.localStorage
          } catch (t) {
            return !1
          }
        })(),
        ty = void 0,
        ey = !0,
        ny = void 0,
        iy = !1,
        ry = [],
        sy = function t(e) {
          var n = this,
            i = e || {}
          ;(this.domElement = document.createElement('div')),
            (this.__ul = document.createElement('ul')),
            this.domElement.appendChild(this.__ul),
            O_.addClass(this.domElement, 'dg'),
            (this.__folders = {}),
            (this.__controllers = []),
            (this.__rememberedObjects = []),
            (this.__rememberedObjectIndecesToControllers = []),
            (this.__listening = []),
            (i = m_.defaults(i, {
              closeOnTop: !1,
              autoPlace: !0,
              width: t.DEFAULT_WIDTH,
            })),
            (i = m_.defaults(i, {
              resizable: i.autoPlace,
              hideable: i.autoPlace,
            })),
            m_.isUndefined(i.load)
              ? (i.load = { preset: Q_ })
              : i.preset && (i.load.preset = i.preset),
            m_.isUndefined(i.parent) && i.hideable && ry.push(this),
            (i.resizable = m_.isUndefined(i.parent) && i.resizable),
            i.autoPlace && m_.isUndefined(i.scrollable) && (i.scrollable = !0)
          var r,
            s = $_ && 'true' === localStorage.getItem(hy(0, 'isLocal')),
            o = void 0,
            a = void 0
          if (
            (Object.defineProperties(this, {
              parent: {
                get: function () {
                  return i.parent
                },
              },
              scrollable: {
                get: function () {
                  return i.scrollable
                },
              },
              autoPlace: {
                get: function () {
                  return i.autoPlace
                },
              },
              closeOnTop: {
                get: function () {
                  return i.closeOnTop
                },
              },
              preset: {
                get: function () {
                  return n.parent ? n.getRoot().preset : i.load.preset
                },
                set: function (t) {
                  n.parent ? (n.getRoot().preset = t) : (i.load.preset = t),
                    (function (t) {
                      for (var e = 0; e < t.__preset_select.length; e++)
                        t.__preset_select[e].value === t.preset &&
                          (t.__preset_select.selectedIndex = e)
                    })(this),
                    n.revert()
                },
              },
              width: {
                get: function () {
                  return i.width
                },
                set: function (t) {
                  ;(i.width = t), gy(n, t)
                },
              },
              name: {
                get: function () {
                  return i.name
                },
                set: function (t) {
                  ;(i.name = t), a && (a.innerHTML = i.name)
                },
              },
              closed: {
                get: function () {
                  return i.closed
                },
                set: function (e) {
                  ;(i.closed = e),
                    i.closed
                      ? O_.addClass(n.__ul, t.CLASS_CLOSED)
                      : O_.removeClass(n.__ul, t.CLASS_CLOSED),
                    this.onResize(),
                    n.__closeButton &&
                      (n.__closeButton.innerHTML = e
                        ? t.TEXT_OPEN
                        : t.TEXT_CLOSED)
                },
              },
              load: {
                get: function () {
                  return i.load
                },
              },
              useLocalStorage: {
                get: function () {
                  return s
                },
                set: function (t) {
                  $_ &&
                    ((s = t),
                    t
                      ? O_.bind(window, 'unload', o)
                      : O_.unbind(window, 'unload', o),
                    localStorage.setItem(hy(0, 'isLocal'), t))
                },
              },
            }),
            m_.isUndefined(i.parent))
          ) {
            if (
              ((this.closed = i.closed || !1),
              O_.addClass(this.domElement, t.CLASS_MAIN),
              O_.makeSelectable(this.domElement, !1),
              $_ && s)
            ) {
              n.useLocalStorage = !0
              var l = localStorage.getItem(hy(0, 'gui'))
              l && (i.load = JSON.parse(l))
            }
            ;(this.__closeButton = document.createElement('div')),
              (this.__closeButton.innerHTML = t.TEXT_CLOSED),
              O_.addClass(this.__closeButton, t.CLASS_CLOSE_BUTTON),
              i.closeOnTop
                ? (O_.addClass(this.__closeButton, t.CLASS_CLOSE_TOP),
                  this.domElement.insertBefore(
                    this.__closeButton,
                    this.domElement.childNodes[0],
                  ))
                : (O_.addClass(this.__closeButton, t.CLASS_CLOSE_BOTTOM),
                  this.domElement.appendChild(this.__closeButton)),
              O_.bind(this.__closeButton, 'click', function () {
                n.closed = !n.closed
              })
          } else {
            void 0 === i.closed && (i.closed = !0)
            var c = document.createTextNode(i.name)
            O_.addClass(c, 'controller-name'),
              (a = oy(n, c)),
              O_.addClass(this.__ul, t.CLASS_CLOSED),
              O_.addClass(a, 'title'),
              O_.bind(a, 'click', function (t) {
                return t.preventDefault(), (n.closed = !n.closed), !1
              }),
              i.closed || (this.closed = !1)
          }
          i.autoPlace &&
            (m_.isUndefined(i.parent) &&
              (ey &&
                ((ny = document.createElement('div')),
                O_.addClass(ny, 'dg'),
                O_.addClass(ny, t.CLASS_AUTO_PLACE_CONTAINER),
                document.body.appendChild(ny),
                (ey = !1)),
              ny.appendChild(this.domElement),
              O_.addClass(this.domElement, t.CLASS_AUTO_PLACE)),
            this.parent || gy(n, i.width)),
            (this.__resizeHandler = function () {
              n.onResizeDebounced()
            }),
            O_.bind(window, 'resize', this.__resizeHandler),
            O_.bind(this.__ul, 'webkitTransitionEnd', this.__resizeHandler),
            O_.bind(this.__ul, 'transitionend', this.__resizeHandler),
            O_.bind(this.__ul, 'oTransitionEnd', this.__resizeHandler),
            this.onResize(),
            i.resizable && my(this),
            (o = function () {
              $_ &&
                'true' === localStorage.getItem(hy(0, 'isLocal')) &&
                localStorage.setItem(
                  hy(0, 'gui'),
                  JSON.stringify(n.getSaveObject()),
                )
            }),
            (this.saveToLocalStorageIfPossible = o),
            i.parent ||
              (((r = n.getRoot()).width += 1),
              m_.defer(function () {
                r.width -= 1
              }))
        }
      function oy(t, e, n) {
        var i = document.createElement('li')
        return (
          e && i.appendChild(e),
          n ? t.__ul.insertBefore(i, n) : t.__ul.appendChild(i),
          t.onResize(),
          i
        )
      }
      function ay(t) {
        O_.unbind(window, 'resize', t.__resizeHandler),
          t.saveToLocalStorageIfPossible &&
            O_.unbind(window, 'unload', t.saveToLocalStorageIfPossible)
      }
      function ly(t, e) {
        var n = t.__preset_select[t.__preset_select.selectedIndex]
        n.innerHTML = e ? n.value + '*' : n.value
      }
      function cy(t, e) {
        var n = t.getRoot(),
          i = n.__rememberedObjects.indexOf(e.object)
        if (-1 !== i) {
          var r = n.__rememberedObjectIndecesToControllers[i]
          if (
            (void 0 === r &&
              ((r = {}), (n.__rememberedObjectIndecesToControllers[i] = r)),
            (r[e.property] = e),
            n.load && n.load.remembered)
          ) {
            var s = n.load.remembered,
              o = void 0
            if (s[t.preset]) o = s[t.preset]
            else {
              if (!s.Default) return
              o = s.Default
            }
            if (o[i] && void 0 !== o[i][e.property]) {
              var a = o[i][e.property]
              ;(e.initialValue = a), e.setValue(a)
            }
          }
        }
      }
      function uy(t, e, n, i) {
        if (void 0 === e[n])
          throw new Error('Object "' + e + '" has no property "' + n + '"')
        var r = void 0
        if (i.color) r = new j_(e, n)
        else {
          var s = [e, n].concat(i.factoryArgs)
          r = J_.apply(t, s)
        }
        i.before instanceof R_ && (i.before = i.before.__li),
          cy(t, r),
          O_.addClass(r.domElement, 'c')
        var o = document.createElement('span')
        O_.addClass(o, 'property-name'), (o.innerHTML = r.property)
        var a = document.createElement('div')
        a.appendChild(o), a.appendChild(r.domElement)
        var l = oy(t, a, i.before)
        return (
          O_.addClass(l, sy.CLASS_CONTROLLER_ROW),
          r instanceof j_
            ? O_.addClass(l, 'color')
            : O_.addClass(l, w_(r.getValue())),
          (function (t, e, n) {
            if (
              ((n.__li = e),
              (n.__gui = t),
              m_.extend(n, {
                options: function (e) {
                  if (arguments.length > 1) {
                    var i = n.__li.nextElementSibling
                    return (
                      n.remove(),
                      uy(t, n.object, n.property, {
                        before: i,
                        factoryArgs: [m_.toArray(arguments)],
                      })
                    )
                  }
                  if (m_.isArray(e) || m_.isObject(e)) {
                    var r = n.__li.nextElementSibling
                    return (
                      n.remove(),
                      uy(t, n.object, n.property, {
                        before: r,
                        factoryArgs: [e],
                      })
                    )
                  }
                },
                name: function (t) {
                  return (
                    (n.__li.firstElementChild.firstElementChild.innerHTML = t),
                    n
                  )
                },
                listen: function () {
                  return n.__gui.listen(n), n
                },
                remove: function () {
                  return n.__gui.remove(n), n
                },
              }),
              n instanceof V_)
            ) {
              var i = new H_(n.object, n.property, {
                min: n.__min,
                max: n.__max,
                step: n.__step,
              })
              m_.each(
                [
                  'updateDisplay',
                  'onChange',
                  'onFinishChange',
                  'step',
                  'min',
                  'max',
                ],
                function (t) {
                  var e = n[t],
                    r = i[t]
                  n[t] = i[t] = function () {
                    var t = Array.prototype.slice.call(arguments)
                    return r.apply(i, t), e.apply(n, t)
                  }
                },
              ),
                O_.addClass(e, 'has-slider'),
                n.domElement.insertBefore(
                  i.domElement,
                  n.domElement.firstElementChild,
                )
            } else if (n instanceof H_) {
              var r = function (e) {
                if (m_.isNumber(n.__min) && m_.isNumber(n.__max)) {
                  var i = n.__li.firstElementChild.firstElementChild.innerHTML,
                    r = n.__gui.__listening.indexOf(n) > -1
                  n.remove()
                  var s = uy(t, n.object, n.property, {
                    before: n.__li.nextElementSibling,
                    factoryArgs: [n.__min, n.__max, n.__step],
                  })
                  return s.name(i), r && s.listen(), s
                }
                return e
              }
              ;(n.min = m_.compose(r, n.min)), (n.max = m_.compose(r, n.max))
            } else
              n instanceof N_
                ? (O_.bind(e, 'click', function () {
                    O_.fakeEvent(n.__checkbox, 'click')
                  }),
                  O_.bind(n.__checkbox, 'click', function (t) {
                    t.stopPropagation()
                  }))
                : n instanceof W_
                ? (O_.bind(e, 'click', function () {
                    O_.fakeEvent(n.__button, 'click')
                  }),
                  O_.bind(e, 'mouseover', function () {
                    O_.addClass(n.__button, 'hover')
                  }),
                  O_.bind(e, 'mouseout', function () {
                    O_.removeClass(n.__button, 'hover')
                  }))
                : n instanceof j_ &&
                  (O_.addClass(e, 'color'),
                  (n.updateDisplay = m_.compose(function (t) {
                    return (e.style.borderLeftColor = n.__color.toString()), t
                  }, n.updateDisplay)),
                  n.updateDisplay())
            n.setValue = m_.compose(function (e) {
              return (
                t.getRoot().__preset_select &&
                  n.isModified() &&
                  ly(t.getRoot(), !0),
                e
              )
            }, n.setValue)
          })(t, l, r),
          t.__controllers.push(r),
          r
        )
      }
      function hy(t, e) {
        return document.location.href + '.' + e
      }
      function dy(t, e, n) {
        var i = document.createElement('option')
        ;(i.innerHTML = e),
          (i.value = e),
          t.__preset_select.appendChild(i),
          n && (t.__preset_select.selectedIndex = t.__preset_select.length - 1)
      }
      function py(t, e) {
        e.style.display = t.useLocalStorage ? 'block' : 'none'
      }
      function fy(t) {
        var e = (t.__save_row = document.createElement('li'))
        O_.addClass(t.domElement, 'has-save'),
          t.__ul.insertBefore(e, t.__ul.firstChild),
          O_.addClass(e, 'save-row')
        var n = document.createElement('span')
        ;(n.innerHTML = '&nbsp;'), O_.addClass(n, 'button gears')
        var i = document.createElement('span')
        ;(i.innerHTML = 'Save'),
          O_.addClass(i, 'button'),
          O_.addClass(i, 'save')
        var r = document.createElement('span')
        ;(r.innerHTML = 'New'),
          O_.addClass(r, 'button'),
          O_.addClass(r, 'save-as')
        var s = document.createElement('span')
        ;(s.innerHTML = 'Revert'),
          O_.addClass(s, 'button'),
          O_.addClass(s, 'revert')
        var o = (t.__preset_select = document.createElement('select'))
        if (
          (t.load && t.load.remembered
            ? m_.each(t.load.remembered, function (e, n) {
                dy(t, n, n === t.preset)
              })
            : dy(t, Q_, !1),
          O_.bind(o, 'change', function () {
            for (var e = 0; e < t.__preset_select.length; e++)
              t.__preset_select[e].innerHTML = t.__preset_select[e].value
            t.preset = this.value
          }),
          e.appendChild(o),
          e.appendChild(n),
          e.appendChild(i),
          e.appendChild(r),
          e.appendChild(s),
          $_)
        ) {
          var a = document.getElementById('dg-local-explain'),
            l = document.getElementById('dg-local-storage')
          ;(document.getElementById('dg-save-locally').style.display = 'block'),
            'true' === localStorage.getItem(hy(0, 'isLocal')) &&
              l.setAttribute('checked', 'checked'),
            py(t, a),
            O_.bind(l, 'change', function () {
              ;(t.useLocalStorage = !t.useLocalStorage), py(t, a)
            })
        }
        var c = document.getElementById('dg-new-constructor')
        O_.bind(c, 'keydown', function (t) {
          !t.metaKey || (67 !== t.which && 67 !== t.keyCode) || ty.hide()
        }),
          O_.bind(n, 'click', function () {
            ;(c.innerHTML = JSON.stringify(t.getSaveObject(), void 0, 2)),
              ty.show(),
              c.focus(),
              c.select()
          }),
          O_.bind(i, 'click', function () {
            t.save()
          }),
          O_.bind(r, 'click', function () {
            var e = prompt('Enter a new preset name.')
            e && t.saveAs(e)
          }),
          O_.bind(s, 'click', function () {
            t.revert()
          })
      }
      function my(t) {
        var e = void 0
        function n(n) {
          return (
            n.preventDefault(),
            (t.width += e - n.clientX),
            t.onResize(),
            (e = n.clientX),
            !1
          )
        }
        function i() {
          O_.removeClass(t.__closeButton, sy.CLASS_DRAG),
            O_.unbind(window, 'mousemove', n),
            O_.unbind(window, 'mouseup', i)
        }
        function r(r) {
          return (
            r.preventDefault(),
            (e = r.clientX),
            O_.addClass(t.__closeButton, sy.CLASS_DRAG),
            O_.bind(window, 'mousemove', n),
            O_.bind(window, 'mouseup', i),
            !1
          )
        }
        ;(t.__resize_handle = document.createElement('div')),
          m_.extend(t.__resize_handle.style, {
            width: '6px',
            marginLeft: '-3px',
            height: '200px',
            cursor: 'ew-resize',
            position: 'absolute',
          }),
          O_.bind(t.__resize_handle, 'mousedown', r),
          O_.bind(t.__closeButton, 'mousedown', r),
          t.domElement.insertBefore(
            t.__resize_handle,
            t.domElement.firstElementChild,
          )
      }
      function gy(t, e) {
        ;(t.domElement.style.width = e + 'px'),
          t.__save_row && t.autoPlace && (t.__save_row.style.width = e + 'px'),
          t.__closeButton && (t.__closeButton.style.width = e + 'px')
      }
      function vy(t, e) {
        var n = {}
        return (
          m_.each(t.__rememberedObjects, function (i, r) {
            var s = {},
              o = t.__rememberedObjectIndecesToControllers[r]
            m_.each(o, function (t, n) {
              s[n] = e ? t.initialValue : t.getValue()
            }),
              (n[r] = s)
          }),
          n
        )
      }
      function _y(t) {
        0 !== t.length &&
          Z_.call(window, function () {
            _y(t)
          }),
          m_.each(t, function (t) {
            t.updateDisplay()
          })
      }
      function yy(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n]
          ;(i.enumerable = i.enumerable || !1),
            (i.configurable = !0),
            'value' in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i)
        }
      }
      ;(sy.toggleHide = function () {
        ;(iy = !iy),
          m_.each(ry, function (t) {
            t.domElement.style.display = iy ? 'none' : ''
          })
      }),
        (sy.CLASS_AUTO_PLACE = 'a'),
        (sy.CLASS_AUTO_PLACE_CONTAINER = 'ac'),
        (sy.CLASS_MAIN = 'main'),
        (sy.CLASS_CONTROLLER_ROW = 'cr'),
        (sy.CLASS_TOO_TALL = 'taller-than-window'),
        (sy.CLASS_CLOSED = 'closed'),
        (sy.CLASS_CLOSE_BUTTON = 'close-button'),
        (sy.CLASS_CLOSE_TOP = 'close-top'),
        (sy.CLASS_CLOSE_BOTTOM = 'close-bottom'),
        (sy.CLASS_DRAG = 'drag'),
        (sy.DEFAULT_WIDTH = 245),
        (sy.TEXT_CLOSED = 'Close Controls'),
        (sy.TEXT_OPEN = 'Open Controls'),
        (sy._keydownHandler = function (t) {
          'text' === document.activeElement.type ||
            (72 !== t.which && 72 !== t.keyCode) ||
            sy.toggleHide()
        }),
        O_.bind(window, 'keydown', sy._keydownHandler, !1),
        m_.extend(sy.prototype, {
          add: function (t, e) {
            return uy(this, t, e, {
              factoryArgs: Array.prototype.slice.call(arguments, 2),
            })
          },
          addColor: function (t, e) {
            return uy(this, t, e, { color: !0 })
          },
          remove: function (t) {
            this.__ul.removeChild(t.__li),
              this.__controllers.splice(this.__controllers.indexOf(t), 1)
            var e = this
            m_.defer(function () {
              e.onResize()
            })
          },
          destroy: function () {
            if (this.parent)
              throw new Error(
                'Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.',
              )
            this.autoPlace && ny.removeChild(this.domElement)
            var t = this
            m_.each(this.__folders, function (e) {
              t.removeFolder(e)
            }),
              O_.unbind(window, 'keydown', sy._keydownHandler, !1),
              ay(this)
          },
          addFolder: function (t) {
            if (void 0 !== this.__folders[t])
              throw new Error(
                'You already have a folder in this GUI by the name "' + t + '"',
              )
            var e = { name: t, parent: this }
            ;(e.autoPlace = this.autoPlace),
              this.load &&
                this.load.folders &&
                this.load.folders[t] &&
                ((e.closed = this.load.folders[t].closed),
                (e.load = this.load.folders[t]))
            var n = new sy(e)
            this.__folders[t] = n
            var i = oy(this, n.domElement)
            return O_.addClass(i, 'folder'), n
          },
          removeFolder: function (t) {
            this.__ul.removeChild(t.domElement.parentElement),
              delete this.__folders[t.name],
              this.load &&
                this.load.folders &&
                this.load.folders[t.name] &&
                delete this.load.folders[t.name],
              ay(t)
            var e = this
            m_.each(t.__folders, function (e) {
              t.removeFolder(e)
            }),
              m_.defer(function () {
                e.onResize()
              })
          },
          open: function () {
            this.closed = !1
          },
          close: function () {
            this.closed = !0
          },
          hide: function () {
            this.domElement.style.display = 'none'
          },
          show: function () {
            this.domElement.style.display = ''
          },
          onResize: function () {
            var t = this.getRoot()
            if (t.scrollable) {
              var e = O_.getOffset(t.__ul).top,
                n = 0
              m_.each(t.__ul.childNodes, function (e) {
                ;(t.autoPlace && e === t.__save_row) || (n += O_.getHeight(e))
              }),
                window.innerHeight - e - 20 < n
                  ? (O_.addClass(t.domElement, sy.CLASS_TOO_TALL),
                    (t.__ul.style.height = window.innerHeight - e - 20 + 'px'))
                  : (O_.removeClass(t.domElement, sy.CLASS_TOO_TALL),
                    (t.__ul.style.height = 'auto'))
            }
            t.__resize_handle &&
              m_.defer(function () {
                t.__resize_handle.style.height = t.__ul.offsetHeight + 'px'
              }),
              t.__closeButton && (t.__closeButton.style.width = t.width + 'px')
          },
          onResizeDebounced: m_.debounce(function () {
            this.onResize()
          }, 50),
          remember: function () {
            if (
              (m_.isUndefined(ty) &&
                ((ty = new K_()).domElement.innerHTML = Y_),
              this.parent)
            )
              throw new Error('You can only call remember on a top level GUI.')
            var t = this
            m_.each(Array.prototype.slice.call(arguments), function (e) {
              0 === t.__rememberedObjects.length && fy(t),
                -1 === t.__rememberedObjects.indexOf(e) &&
                  t.__rememberedObjects.push(e)
            }),
              this.autoPlace && gy(this, this.width)
          },
          getRoot: function () {
            for (var t = this; t.parent; ) t = t.parent
            return t
          },
          getSaveObject: function () {
            var t = this.load
            return (
              (t.closed = this.closed),
              this.__rememberedObjects.length > 0 &&
                ((t.preset = this.preset),
                t.remembered || (t.remembered = {}),
                (t.remembered[this.preset] = vy(this))),
              (t.folders = {}),
              m_.each(this.__folders, function (e, n) {
                t.folders[n] = e.getSaveObject()
              }),
              t
            )
          },
          save: function () {
            this.load.remembered || (this.load.remembered = {}),
              (this.load.remembered[this.preset] = vy(this)),
              ly(this, !1),
              this.saveToLocalStorageIfPossible()
          },
          saveAs: function (t) {
            this.load.remembered ||
              ((this.load.remembered = {}),
              (this.load.remembered.Default = vy(this, !0))),
              (this.load.remembered[t] = vy(this)),
              (this.preset = t),
              dy(this, t, !0),
              this.saveToLocalStorageIfPossible()
          },
          revert: function (t) {
            m_.each(
              this.__controllers,
              function (e) {
                this.getRoot().load.remembered
                  ? cy(t || this.getRoot(), e)
                  : e.setValue(e.initialValue),
                  e.__onFinishChange && e.__onFinishChange.call(e, e.getValue())
              },
              this,
            ),
              m_.each(this.__folders, function (t) {
                t.revert(t)
              }),
              t || ly(this.getRoot(), !1)
          },
          listen: function (t) {
            var e = 0 === this.__listening.length
            this.__listening.push(t), e && _y(this.__listening)
          },
          updateDisplay: function () {
            m_.each(this.__controllers, function (t) {
              t.updateDisplay()
            }),
              m_.each(this.__folders, function (t) {
                t.updateDisplay()
              })
          },
        }),
        _i.registerPlugin(no, wo, qo, ia)
      var xy = (function () {
        function t(e) {
          !(function (t, e) {
            if (!(t instanceof e))
              throw new TypeError('Cannot call a class as a function')
          })(this, t),
            (this.smooth = e.scrl),
            (this.params = {
              baseFirstP: [6, 175, 217],
              baseSecondP: [255, 255, 105],
              baseAccent: [0, 0, 0],
              divider: 1700,
              speed: 0.4,
              basePatterOffset: -0.25,
              secondPatternOffset: 0,
              xMult: 10,
              rotation: 1.5,
              noiseScale: 1,
              noiseDistA: 0.5,
              noiseDistB: 5.8,
              opacity: 0.8,
            }),
            document.body.classList.contains('darkmode') &&
              ((this.params.baseAccent = [255, 255, 255]),
              console.log(this.params.baseAccent)),
            (this.time = 0),
            (this.devicePixelRatio = 1),
            (this.container = e.dom),
            (this.scene = new Fp()),
            (this.width = this.container.offsetWidth),
            (this.height = this.container.offsetHeight),
            (this.camera = new Iu(70, this.width / this.height, 100, 2e3)),
            (this.camera.position.z = 600),
            (this.camera.fov =
              2 * Math.atan(this.height / 2 / 600) * (180 / Math.PI)),
            (this.renderer = new Lp({ antialias: !0, alpha: !0 })),
            this.renderer.setPixelRatio(this.devicePixelRatio),
            this.container.appendChild(this.renderer.domElement),
            (this.loader = new Jg()),
            (this.dracoLoader = new kv()),
            this.dracoLoader.setDecoderPath('./static/draco/'),
            this.loader.setDRACOLoader(this.dracoLoader)
          var n = new _g(0)
          this.scene.add(n)
          var i = new mg(16777215, 0.5, 0)
          i.position.set(0, 200, 0),
            this.scene.add(i),
            (this.light2 = new mg(13161552, 0.35, 0)),
            this.light2.position.set(100, 200, 100),
            this.scene.add(this.light2),
            (this.light3 = new mg(1796905, 0.15, 0)),
            this.light3.position.set(-100, -200, -100),
            this.scene.add(this.light3)
        }
        var e, i
        return (
          (e = t),
          (i = [
            {
              key: 'start',
              value: function () {
                var t = this,
                  e = [
                    new Promise(function (t, e) {
                      Uv()(
                        document.querySelectorAll('img'),
                        { background: !0 },
                        t,
                      )
                    }),
                  ]
                Promise.all(e).then(function () {
                  var e = _i.utils.toArray('.text-reveal > *')
                  _i.set(e, { autoAlpha: 1 })
                  var n = _i.timeline({
                      onStart: function () {
                        _i.set('#wrapper', { opacity: 1 })
                      },
                      onComplete: function () {
                        document.querySelector('.loader').classList.add('end')
                      },
                    }),
                    i = []
                  e.forEach(function (t) {
                    new qo(t, { type: 'words', wordsClass: 'hide' })
                    var e = new qo(t, { type: 'words', wordsClass: 'words' })
                    i.push(e.words)
                  }),
                    new qo('.page__title', {
                      type: 'words',
                      wordsClass: 'hide',
                    })
                  var r = new qo('.page__title', {
                    type: 'words',
                    wordsClass: 'words ',
                  })
                  n
                    .add('bg')
                    .to(
                      '#canvas-container',
                      { duration: 0.5, opacity: 1, ease: 'power3.out' },
                      'bg',
                    )
                    .add('showin')
                    .from(
                      r.words,
                      {
                        duration: 1.2,
                        yPercent: 100,
                        ease: 'power3.out',
                        stagger: 0.04,
                        delay: 0.25,
                      },
                      'showin',
                    )
                    .from(
                      '.smile-wrap',
                      {
                        duration: 1.2,
                        yPercent: 100,
                        opacity: 0,
                        ease: 'power3.out',
                        delay: 0.25,
                      },
                      'showin',
                    )
                    .from(
                      '.arrow-start',
                      {
                        duration: 1.2,
                        opacity: 0,
                        yPercent: 100,
                        ease: 'power3.out',
                        delay: 0.25,
                      },
                      'showin',
                    )
                    .from(
                      i,
                      {
                        duration: 1.2,
                        yPercent: 100,
                        ease: 'power3.out',
                        stagger: 0.04,
                        delay: 0.25,
                      },
                      'showin',
                    )
                    .from(
                      '.page-reveal',
                      {
                        duration: 1.2,
                        opacity: 0,
                        yPercent: 100,
                        ease: 'power3.out',
                        delay: 0.25,
                      },
                      'showin',
                    )
                    .add(function () {
                      window.dispatchEvent(new Event('loadexscript')),
                        window.dispatchEvent(new Event('resize'))
                    }, 'showin')
                    .to(
                      t.params,
                      {
                        secondPatternOffset: 0,
                        duration: 1,
                        delay: 0.25,
                        ease: 'power3.out',
                        onUpdate: function () {
                          this.material.uniforms.secondPatternOffset.value = this.params.secondPatternOffset
                        }.bind(t),
                      },
                      'showin',
                    )
                    .to(
                      t.params,
                      {
                        noiseDistA: -0.6,
                        duration: 1.5,
                        delay: 0.25,
                        ease: 'power3.out',
                        onUpdate: function () {
                          this.material.uniforms.noiseDistA.value = this.params.noiseDistA
                        }.bind(t),
                      },
                      'showin',
                    ),
                    t.setupResize(),
                    t.addObjects(),
                    t.resize(),
                    t.render()
                })
              },
            },
            {
              key: 'destroy',
              value: function () {
                ;(this.container.innerHTML = ''), cancelAnimationFrame(this.raf)
              },
            },
            {
              key: 'setupResize',
              value: function () {
                window.addEventListener('resize', this.resize.bind(this))
              },
            },
            {
              key: 'resize',
              value: function () {
                ;(this.width = this.container.offsetWidth),
                  (this.height = this.container.offsetHeight),
                  this.renderer.setSize(this.width, this.height),
                  (this.camera.aspect = this.width / this.height),
                  (this.camera.fov =
                    2 * Math.atan(this.height / 2 / 600) * (180 / Math.PI)),
                  this.camera.updateProjectionMatrix()
              },
            },
            {
              key: 'addObjects',
              value: function () {
                var t = n(73),
                  e = n(411)
                this.material = new Pu({
                  uniforms: {
                    time: { value: 0 },
                    baseFirstP: { value: this.params.baseFirstP },
                    baseSecondP: { value: this.params.baseSecondP },
                    baseAccent: { value: this.params.baseAccent },
                    divider: { value: this.params.divider },
                    speed: { value: this.params.speed },
                    basePatterOffset: { value: this.params.basePatterOffset },
                    secondPatternOffset: {
                      value: this.params.secondPatternOffset,
                    },
                    xMult: { value: this.params.xMult },
                    rotation: { value: this.params.rotation },
                    noiseScale: { value: this.params.noiseScale },
                    noiseDistA: { value: this.params.noiseDistA },
                    noiseDistB: { value: this.params.noiseDistB },
                    opacity: { value: this.params.opacity },
                  },
                  side: 2,
                  vertexShader: t,
                  fragmentShader: e,
                })
                var i = 900
                window.matchMedia('(max-width: 992px)') && (i = 600)
                var r = new Rm(i, 32, 32),
                  s = new Eu(r, this.material)
                this.scene.add(s)
              },
            },
            {
              key: 'render',
              value: function () {
                ;(this.time += 0.015),
                  (this.material.uniforms.time.value = this.time),
                  this.renderer.render(this.scene, this.camera),
                  (this.raf = window.requestAnimationFrame(
                    this.render.bind(this),
                  ))
              },
            },
          ]),
          i && yy(e.prototype, i),
          Object.defineProperty(e, 'prototype', { writable: !1 }),
          t
        )
      })()
      function by(t) {
        return (
          (by =
            'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
              ? function (t) {
                  return typeof t
                }
              : function (t) {
                  return t &&
                    'function' == typeof Symbol &&
                    t.constructor === Symbol &&
                    t !== Symbol.prototype
                    ? 'symbol'
                    : typeof t
                }),
          by(t)
        )
      }
      function wy(t, e) {
        if (!(t instanceof e))
          throw new TypeError('Cannot call a class as a function')
      }
      function My(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n]
          ;(i.enumerable = i.enumerable || !1),
            (i.configurable = !0),
            'value' in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i)
        }
      }
      function Sy(t, e, n) {
        return (
          e && My(t.prototype, e),
          n && My(t, n),
          Object.defineProperty(t, 'prototype', { writable: !1 }),
          t
        )
      }
      function Ty(t, e) {
        if ('function' != typeof e && null !== e)
          throw new TypeError(
            'Super expression must either be null or a function',
          )
        ;(t.prototype = Object.create(e && e.prototype, {
          constructor: { value: t, writable: !0, configurable: !0 },
        })),
          Object.defineProperty(t, 'prototype', { writable: !1 }),
          e && Ey(t, e)
      }
      function Ey(t, e) {
        return (
          (Ey =
            Object.setPrototypeOf ||
            function (t, e) {
              return (t.__proto__ = e), t
            }),
          Ey(t, e)
        )
      }
      function Dy(t) {
        var e = (function () {
          if ('undefined' == typeof Reflect || !Reflect.construct) return !1
          if (Reflect.construct.sham) return !1
          if ('function' == typeof Proxy) return !0
          try {
            return (
              Boolean.prototype.valueOf.call(
                Reflect.construct(Boolean, [], function () {}),
              ),
              !0
            )
          } catch (t) {
            return !1
          }
        })()
        return function () {
          var n,
            i = Cy(t)
          if (e) {
            var r = Cy(this).constructor
            n = Reflect.construct(i, arguments, r)
          } else n = i.apply(this, arguments)
          return Ay(this, n)
        }
      }
      function Ay(t, e) {
        if (e && ('object' === by(e) || 'function' == typeof e)) return e
        if (void 0 !== e)
          throw new TypeError(
            'Derived constructors may only return object or undefined',
          )
        return (function (t) {
          if (void 0 === t)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called",
            )
          return t
        })(t)
      }
      function Cy(t) {
        return (
          (Cy = Object.setPrototypeOf
            ? Object.getPrototypeOf
            : function (t) {
                return t.__proto__ || Object.getPrototypeOf(t)
              }),
          Cy(t)
        )
      }
      _i.registerPlugin(no, wo, qo, ia)
      var Ly = !0,
        Ry = [
          new Promise(function (t) {
            new (sa())('Druk Cond Web Super').load().then(function () {
              t()
            })
          }),
          new Promise(function (t) {
            new (sa())('Chivo').load().then(function () {
              t()
            })
          }),
        ]
      Promise.all(Ry).then(function () {
        _i.timeline({
          onComplete: function () {
            document.querySelector('.loader').classList.add('end'), (Ly = !1)
          },
        })
          .to('body', { duration: 0.25, opacity: 1 })
          .to('.loader__text span', {
            duration: 2,
            scrambleText: {
              text: 'SWAYCHAIN',
              chars: 'upperCase',
              revealDelay: 0.5,
              tweenLength: !1,
            },
          })
          .to('.loader__text span', {
            duration: 0.5,
            yPercent: 100,
            ease: 'power3.out',
          })
          .from('.header', {
            duration: 1,
            yPercent: -100,
            ease: 'power3.out',
            clearProps: !0,
          })
          .add(function () {
            window.dispatchEvent(new Event('endloading'))
          }, '-=1')
      })
      var Py = wo.create({
          wrapper: '#wrapper',
          content: '#content',
          smooth: 1,
          smoothTouch: 0,
          normalizeScroll: !0,
          ignoreMobileResize: !1,
          effects: !0,
          preventDefault: !0,
          onUpdate: function (t) {
            null != Fy && Fy.setDavidPositions(),
              t.scrollTop() > 120
                ? document.querySelectorAll('header')[0].classList.add('sticky')
                : document
                    .querySelectorAll('header')[0]
                    .classList.remove('sticky'),
              t.getVelocity() > 0
                ? t.scrollTop() > 64 &&
                  document.querySelectorAll('header')[0].classList.add('hide')
                : document
                    .querySelectorAll('header')[0]
                    .classList.remove('hide')
          },
        }),
        Fy = null,
        Iy = null,
        Oy = null,
        Ny = (function (t) {
          Ty(n, t)
          var e = Dy(n)
          function n() {
            return wy(this, n), e.apply(this, arguments)
          }
          return (
            Sy(n, [
              {
                key: 'onEnter',
                value: function () {
                  window.dispatchEvent(new Event('resize')),
                    Py.scrollTo(0, !1),
                    (Iy = new xy({
                      dom: document.getElementById('canvas-container'),
                    })),
                    0 == Ly
                      ? Iy.start()
                      : window.addEventListener('endloading', function () {
                          Iy.start()
                        })
                },
              },
              {
                key: 'onLeave',
                value: function () {
                  Iy.destroy(),
                    no.getAll().forEach(function (t) {
                      t.kill()
                    })
                },
              },
              { key: 'onEnterCompleted', value: function () {} },
              { key: 'onLeaveCompleted', value: function () {} },
            ]),
            n
          )
        })(ma.Renderer),
        ky = (function (t) {
          Ty(n, t)
          var e = Dy(n)
          function n() {
            return wy(this, n), e.apply(this, arguments)
          }
          return (
            Sy(n, [
              {
                key: 'onEnter',
                value: function () {
                  document.body.classList.add('folio'),
                    window.dispatchEvent(new Event('resize')),
                    Py.scrollTo(0, !1),
                    (Oy = new h_({
                      dom: document.getElementById('canvas-container'),
                    })),
                    0 == Ly
                      ? Oy.start()
                      : window.addEventListener('endloading', function () {
                          Oy.start()
                        })
                },
              },
              {
                key: 'onLeave',
                value: function () {
                  Oy.destroy(),
                    document.body.classList.remove('folio'),
                    no.getAll().forEach(function (t) {
                      t.kill()
                    })
                },
              },
              { key: 'onEnterCompleted', value: function () {} },
              { key: 'onLeaveCompleted', value: function () {} },
            ]),
            n
          )
        })(ma.Renderer),
        By = (function (t) {
          Ty(n, t)
          var e = Dy(n)
          function n() {
            return wy(this, n), e.apply(this, arguments)
          }
          return (
            Sy(n, [
              {
                key: 'onEnter',
                value: function () {
                  Py.scrollTo(0, !1),
                    (Fy = new Gv({
                      dom: document.getElementById('canvas-container'),
                      scrl: Py,
                    })),
                    0 == Ly
                      ? Fy.start()
                      : window.addEventListener('endloading', function () {
                          Fy.start()
                        }),
                    _i
                      .timeline({
                        scrollTrigger: {
                          trigger: '.hero',
                          scrub: !0,
                          start: 'top top',
                          end: 'bottom top',
                        },
                      })
                      .add('start')
                      .to(
                        Fy.params.baseFirstP,
                        { endArray: [82, 183, 136], overwrite: !0 },
                        'start',
                      )
                      .to(
                        Fy.params,
                        {
                          noiseDistA: 0.5,
                          onUpdate: function () {
                            void 0 !== Fy.material &&
                              (Fy.material.uniforms.noiseDistA.value =
                                Fy.params.noiseDistA)
                          },
                          overwrite: !0,
                        },
                        'start',
                      ),
                    _i
                      .timeline({
                        scrollTrigger: {
                          trigger: '.hintro',
                          scrub: !0,
                          start: 'top top',
                          end: 'bottom top',
                        },
                      })
                      .add('start')
                      .to(
                        Fy.params.baseFirstP,
                        { endArray: [201, 94, 190], overwrite: !0 },
                        'start',
                      )
                      .to(
                        Fy.params,
                        {
                          noiseDistA: -0.6,
                          onUpdate: function () {
                            void 0 !== Fy.material.uniforms &&
                              (Fy.material.uniforms.noiseDistA.value =
                                Fy.params.noiseDistA)
                          },
                          overwrite: !0,
                        },
                        'start',
                      ),
                    _i
                      .timeline({
                        scrollTrigger: {
                          trigger: '.hvision',
                          scrub: !0,
                          start: 'top top',
                          end: 'bottom top',
                        },
                      })
                      .add('start')
                      .to(
                        Fy.params.baseFirstP,
                        { endArray: [29, 176, 98], overwrite: !0 },
                        'start',
                      )
                      .to(
                        Fy.params,
                        {
                          noiseDistA: 0.6,
                          onUpdate: function () {
                            void 0 !== Fy.material.uniforms &&
                              (Fy.material.uniforms.noiseDistA.value =
                                Fy.params.noiseDistA)
                          },
                          overwrite: !0,
                        },
                        'start',
                      ),
                    _i
                      .timeline({
                        scrollTrigger: {
                          trigger: '.hstart',
                          scrub: !0,
                          start: 'top center',
                          end: 'bottom center',
                          markers: !1,
                        },
                      })
                      .add('start')
                      .to(
                        Fy.params.baseFirstP,
                        { endArray: [0, 167, 225], overwrite: !0 },
                        'start',
                      )
                      .to(
                        Fy.params,
                        {
                          noiseDistA: 0.6,
                          onUpdate: function () {
                            void 0 !== Fy.material.uniforms &&
                              (Fy.material.uniforms.noiseDistA.value =
                                Fy.params.noiseDistA)
                          },
                          overwrite: !0,
                        },
                        'start',
                      )
                  var t = _i.utils.toArray('.text-reveal > *')
                  _i.set(t, { autoAlpha: 1 }),
                    t.forEach(function (t) {
                      new qo(t, { type: 'words', wordsClass: 'hide' })
                      var e = new qo(t, { type: 'words', wordsClass: 'words' })
                      _i.from(e.words, {
                        duration: 1.2,
                        yPercent: 100,
                        ease: 'power3.out',
                        stagger: 0.04,
                        delay: 0.25,
                        scrollTrigger: {
                          trigger: t,
                          start: 'top bottom-=32px',
                        },
                      })
                    })
                  var e = _i.utils.toArray('.title-reveal > *')
                  _i.set(e, { autoAlpha: 1 }),
                    e.forEach(function (t) {
                      new qo(t, { type: 'words', wordsClass: 'hide' })
                      var e = new qo(t, {
                        type: 'chars,words',
                        wordsClass: 'words',
                      })
                      _i.from(e.chars, {
                        duration: 1.2,
                        yPercent: 100,
                        ease: 'power3.out',
                        stagger: 0.04,
                        delay: 0.25,
                        scrollTrigger: {
                          trigger: t,
                          start: 'top bottom-=104px',
                        },
                      })
                    }),
                    document
                      .querySelectorAll('.svg-draw')
                      .forEach(function (t, e) {
                        var n = 'svg-' + e
                        t.classList.add(n)
                        var i = new (aa())({
                          selector: '.' + n,
                          duration: '1000',
                          easing: function (t) {
                            return t * t
                          },
                        })
                        no.create({
                          trigger: t,
                          start: 'top bottom-=104px',
                          onEnter: function () {
                            i.draw(),
                              setTimeout(function () {
                                '' != t.dataset.image &&
                                  document
                                    .getElementById(t.dataset.image)
                                    .classList.add('in')
                              }, 1e3)
                          },
                        })
                      })
                  var n = _i.utils.toArray([
                    '.gmarquee__btop',
                    '.gmarquee__bbottom',
                  ])
                  _i.set(n, { autoAlpha: 1 }),
                    n.forEach(function (t) {
                      _i.from(t, {
                        duration: 1.2,
                        width: 0,
                        ease: 'power3.out',
                        delay: 0.25,
                        scrollTrigger: { trigger: t, start: 'top bottom' },
                        onComplete: function () {
                          t.classList.add('w-100')
                        },
                      })
                    })
                  var i = _i.utils.toArray('.gmarquee__txt')
                  _i.set(i, { autoAlpha: 1 }),
                    i.forEach(function (t) {
                      _i.from(t, {
                        duration: 1.2,
                        opacity: 0,
                        ease: 'power3.out',
                        delay: 0.25,
                        scrollTrigger: { trigger: t, start: 'top bottom' },
                      })
                    })
                  var r = _i.utils.toArray('.hworkflow__gallery-panel'),
                    s = document.querySelector('.hworkflow__gallery-container')
                  _i.to(r, {
                    xPercent: -100 * (r.length - 1),
                    ease: 'none',
                    duration: 6,
                    scrollTrigger: {
                      trigger: '.hworkflow__gallery-container',
                      pinSpacing: !0,
                      pin: !0,
                      scrub: !0,
                      markers: !1,
                      onEnter: function () {},
                      onUpdate: function (t) {
                        Fy.dmodel.rotation.y += 1e-4 * t.getVelocity()
                      },
                      end: '+='.concat(s.offsetWidth),
                    },
                  }),
                    no.create({
                      trigger: '.hworkflow__marquee',
                      start: 'top top+=8px',
                      end: '+='.concat(s.offsetWidth),
                      pin: !0,
                      pinSpacing: !1,
                      scrub: !0,
                      markers: !1,
                    }),
                    no.create({
                      trigger: '.hworkflow__gallery-d',
                      end: '+='.concat(s.offsetWidth),
                      pin: !0,
                      pinSpacing: !1,
                      scrub: !0,
                      markers: !1,
                    }),
                    r.forEach(function (t, e) {
                      no.create({
                        trigger: t,
                        start:
                          'top top-=' +
                          (t.offsetLeft - window.innerWidth / 2) *
                            (document.querySelector(
                              '.hworkflow__gallery-container',
                            ).offsetWidth /
                              (t.offsetWidth * (r.length - 1))),
                        end:
                          '+=' +
                          t.offsetWidth *
                            (document.querySelector(
                              '.hworkflow__gallery-container',
                            ).offsetWidth /
                              (t.offsetWidth * (r.length - 1))),
                        toggleClass: { targets: t, className: 'active' },
                      })
                    }),
                    document
                      .querySelector('.hero__scroll')
                      .addEventListener('click', function () {
                        _i.to(Py, {
                          scrollTop: Py.offset('.hintro', 'top 104px'),
                          duration: 1.2,
                          ease: 'power3.inOut',
                        })
                      })
                },
              },
              {
                key: 'onLeave',
                value: function () {
                  Fy.destroy(),
                    (Fy = null),
                    no.getAll().forEach(function (t) {
                      t.kill()
                    })
                },
              },
              { key: 'onEnterCompleted', value: function () {} },
              { key: 'onLeaveCompleted', value: function () {} },
            ]),
            n
          )
        })(ma.Renderer),
        zy = (function (t) {
          Ty(n, t)
          var e = Dy(n)
          function n() {
            return wy(this, n), e.apply(this, arguments)
          }
          return (
            Sy(n, [
              {
                key: 'in',
                value: function (t) {
                  var e = t.from,
                    n = (t.to, t.done)
                  new _i.timeline({
                    onStart: function () {
                      e.remove(), n()
                    },
                  })
                    .add('start')
                    .to(
                      '.menu-mobile',
                      { duration: 1, ease: 'power3.inOut', x: '100%' },
                      'start',
                    )
                    .add(function () {
                      document
                        .querySelector('.header__mmenu-btn')
                        .classList.remove('show')
                    })
                },
              },
              {
                key: 'out',
                value: function (t) {
                  t.from
                  var e = t.done
                  new _i.timeline({
                    onComplete: function () {
                      e()
                    },
                  })
                    .add('start')
                    .to(
                      '#wrapper',
                      { opacity: 0, ease: 'power3.out', duration: 0.5 },
                      'start',
                    )
                    .to(
                      '#canvas-container',
                      { opacity: 0, ease: 'power3.out', duration: 0.5 },
                      'start',
                    )
                },
              },
            ]),
            n
          )
        })(ma.Transition)
      new ma.Core({
        renderers: { about: Ny, home: By, folio: ky },
        transitions: { about: zy, home: zy, folio: zy },
      }),
        document.body.classList.contains('homepage'),
        document.body.classList.contains('folio') &&
          new h_({ dom: document.getElementById('canvas-container') }),
        document
          .querySelector('.site-mode')
          .addEventListener('click', function () {
            var t
            document.body.classList.contains('darkmode')
              ? ((t = new _i.timeline({
                  onComplete: function () {
                    document.body.classList.remove('darkmode')
                  },
                }))
                  .add('start')
                  .to(
                    ':root',
                    { '--main-txt-color': '#FFF', duration: 1 },
                    'start',
                  )
                  .to(
                    ':root',
                    { '--main-bg-color': '#0e0e0e', duration: 1 },
                    'start',
                  )
                  .to(
                    ':root',
                    {
                      '--main-tr-color': 'rgb(255 255 255 / 25%)',
                      duration: 1,
                    },
                    'start',
                  )
                  .to(
                    '.hero__marquee-txt svg path',
                    { fill: '#FFF', duration: 1 },
                    'start',
                  )
                  .to(
                    '.site-mode .border',
                    { fill: '#FFF', duration: 1 },
                    'start',
                  )
                  .to(
                    '.site-mode .fill',
                    { fill: 'none', duration: 1 },
                    'start',
                  )
                  .to('.smile path', { stroke: '#FFF', duration: 1 }, 'start')
                  .to('.smile circle', { stroke: '#FFF', duration: 1 }, 'start')
                  .to(
                    '.smile ellipse',
                    { stroke: '#FFF', duration: 1 },
                    'start',
                  )
                  .to(
                    '.wpcf7-form .wpcf7-form-control-wrap input',
                    { borderColor: '#FFF', color: '#FFF', duration: 1 },
                    'start',
                  )
                  .to(
                    '.wpcf7-form textarea',
                    { borderColor: '#FFF', color: '#FFF', duration: 1 },
                    'start',
                  )
                  .to(
                    '.gmarquee__txt svg g',
                    { stroke: '#FFF', duration: 1 },
                    'start',
                  ),
                null != Fy &&
                  t.to(
                    Fy.params.baseAccent,
                    { endArray: [0, 0, 0], overwrite: !0, duration: 1 },
                    'start',
                  ),
                null != Iy &&
                  t.to(
                    Iy.params.baseAccent,
                    { endArray: [0, 0, 0], overwrite: !0, duration: 1 },
                    'start',
                  ),
                null != Oy &&
                  (console.log(Oy.matDark),
                  t.to(
                    Oy.matDark.color,
                    { r: 255, g: 255, b: 255, overwrite: !0, duration: 1 },
                    'start',
                  )))
              : ((t = new _i.timeline({
                  onComplete: function () {
                    document.body.classList.add('darkmode')
                  },
                }))
                  .add('start')
                  .to(
                    ':root',
                    { '--main-txt-color': '#333', duration: 1 },
                    'start',
                  )
                  .to(
                    ':root',
                    { '--main-bg-color': '#FFF', duration: 1 },
                    'start',
                  )
                  .to(
                    ':root',
                    { '--main-tr-color': 'rgb(30 30 30 / 25%)', duration: 1 },
                    'start',
                  )
                  .to(
                    '.hero__marquee-txt svg path',
                    { fill: '#333', duration: 1 },
                    'start',
                  )
                  .to(
                    '.site-mode .border',
                    { fill: '#333', duration: 1 },
                    'start',
                  )
                  .to(
                    '.site-mode .fill',
                    { fill: '#333', duration: 1 },
                    'start',
                  )
                  .to('.smile path', { stroke: '#333', duration: 1 }, 'start')
                  .to('.smile circle', { stroke: '#333', duration: 1 }, 'start')
                  .to(
                    '.smile ellipse',
                    { stroke: '#333', duration: 1 },
                    'start',
                  )
                  .to(
                    '.wpcf7-form .wpcf7-form-control-wrap input',
                    { borderColor: '#333', color: '#333', duration: 1 },
                    'start',
                  )
                  .to(
                    '.wpcf7-form textarea',
                    { borderColor: '#333', color: '#333', duration: 1 },
                    'start',
                  )
                  .to(
                    '.gmarquee__txt svg g',
                    { stroke: '#333', duration: 1 },
                    'start',
                  ),
                null != Fy &&
                  t.to(
                    Fy.params.baseAccent,
                    { endArray: [255, 255, 255], overwrite: !0, duration: 1 },
                    'start',
                  ),
                null != Iy &&
                  t.to(
                    Iy.params.baseAccent,
                    { endArray: [255, 255, 255], overwrite: !0, duration: 1 },
                    'start',
                  ),
                null != Oy &&
                  (console.log(Oy.matDark),
                  t.to(
                    Oy.matDark.color,
                    { r: 0, g: 0, b: 0, overwrite: !0, duration: 1 },
                    'start',
                  )))
          }),
        document.querySelector('.header__mmenu-btn').addEventListener(
          'click',
          function (t) {
            if (
              (t.preventDefault(),
              document
                .querySelector('.header__mmenu-btn')
                .classList.contains('show'))
            )
              (e = new _i.timeline())
                .add('start')
                .to(
                  '.menu-mobile',
                  { duration: 1, ease: 'power3.inOut', x: '100%' },
                  'start',
                )
                .add(function () {
                  document
                    .querySelector('.header__mmenu-btn')
                    .classList.remove('show')
                })
            else {
              var e = new _i.timeline()
              document
                .querySelector('.header__mmenu-btn')
                .classList.add('show'),
                e
                  .add('start')
                  .to(
                    '.menu-mobile',
                    { duration: 1, ease: 'power3.inOut', x: 0 },
                    'start',
                  )
            }
          },
          !1,
        )
    })()
})()
